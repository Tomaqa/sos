;;;; Function choosing model in SMT+ODE format
;; `y' is continuous state

;;; Constants

#define T 1.0
;#define T 0.1

#define T_MIN()    1
#define T_MAX()   10

#define STEPS $d(+ $(/ (- #T_MAX #T_MIN) #T) )
#define STEPS-1 $d(- #STEPS 1)

;;; Constant invariants


;;; Declarations

#def DECL_CONSTS(const type)
#for (i 0 #STEPS)
    (declare-fun #const##_#i () #type)
#endfor
#enddef

#DECL_CONSTS(t     Real)
#DECL_CONSTS(high  Real)
#DECL_CONSTS(low   Real)
#DECL_CONSTS(y     Real)

#DECL_CONSTS(dhigh Dt)
#DECL_CONSTS(dlow  Dt)
#DECL_CONSTS(dy    Dt)

;;; Initializations

#define INIT_T()   (= t_0 #T_MIN)

#def _INIT_INTERVAL(var val max step)
#if $(<= #val #max)
    (= #var #val)
    #_INIT_INTERVAL(#var $(+ #val #step) #max #step)
#endif
#enddef
#def INIT_INTERVAL(var min max step)
    (or #_INIT_INTERVAL(#var #min #max #step))
#enddef

#define INIT_HIGH() (= high_0 #T_MIN)
#define INIT_LOW() (= low_0 0)

#define INIT_Y() #INIT_INTERVAL(y_0 0 #T_MIN 0.25)

(assert (and #INIT_T
             #INIT_HIGH
             #INIT_LOW
             #INIT_Y
))

;;; Steps definition

#def T_STEPS
#for (i 0 $(- #STEPS 1))
#let j $d(+ #i 1)
    (= t_#j  (+ t_#i  #T))
#endlet j
#endfor
#enddef

(assert (and #T_STEPS))

;;; Derivatives definition

(define-dt high dhigh () (- t (* high (sin high))))

(define-dt low dlow () 1)

(define-dt y dy_exp_inc () y)
(define-dt y dy_exp_dec () (- (/ 2 t)))
(define-dt y dy_lin_inc () 1)
(define-dt y dy_lin_dec () -1)

;;; Invariants

(define-fun invariant ( (t Real) (high Real) (low Real) (y Real)
                        (dhigh_ Dt) (dlow_ Dt) (dy_ Dt)
                      ) Bool
    (and (<= low y high)
         (= dhigh_ dhigh) (= dlow_ dlow)
         ;(or (= dy_ dy_exp_inc) (= dy_ dy_exp_dec))
         (or (= dy_ dy_exp_inc) (= dy_ dy_exp_dec)
             (= dy_ dy_lin_inc) (= dy_ dy_lin_dec))
))

#def INVARIANTS
#for (i 0 #STEPS)
    (invariant t_#i high_#i low_#i y_#i
               dhigh_#i dlow_#i dy_#i)
#endfor
#enddef

(assert (and #INVARIANTS))

;;; Derivatives connection

;;; Jump conditions

;;; Integration

#def ASSERT_INT_ODE(f)
(assert (and
#for (i 0 $(- #STEPS 1))
#let j $d(+ #i 1)
    (= #f##_#j (int-ode #f d#f##_#i (#f##_#i t_#i t_#j) ()) )
#endlet j
#endfor
))
#enddef

#ASSERT_INT_ODE(high)
#ASSERT_INT_ODE(low )
#ASSERT_INT_ODE(y   )
