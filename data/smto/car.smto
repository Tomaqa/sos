;;;; Car steering model in SMT+ODE format
;; `(p, gam, c)' is continuous state
;; `p' denotes horizontal position of car
;; `gam' denotes heading angle
;; `c' denotes internal timer
;; `(correct, left, ahead, canal)' is discrete state


;;; Constants

(define-fun T () Real 0.5)

(define-fun pi () Real 3.14159265)

(define-fun p_lo  () Real (- 1))
(define-fun p_hi  () Real    1 )
(define-fun p_min () Real (- 1.5 ))

(define-fun r  () Real 5)
(define-fun om () Real 2)

(define-fun t0   () Real 0)

(define-fun p0   () Real 0)
(define-fun gam0 () Real 0.15)
(define-fun c0   () Real 0)

(define-fun correct0 () Bool false)
(define-fun left0    () Bool false)
(define-fun ahead0   () Bool true)
(define-fun canal0   () Bool false)

;;; Constant invariants

(assert (and (>  p_hi  p_lo)
             (<  p_min p_lo)
             (>= p0    p_lo)
             (<= p0    p_hi)
             (>= gam0 (- (/ pi 4)))
             (<= gam0    (/ pi 4) )
))

;;; Declarations

(declare-fun t_0 () Real)
(declare-fun t_1 () Real)
(declare-fun t_2 () Real)
(declare-fun t_3 () Real)
(declare-fun t_4 () Real)
(declare-fun t_5 () Real)

(declare-fun p_0 () Real)
(declare-fun p_1 () Real)
(declare-fun p_2 () Real)
(declare-fun p_3 () Real)
(declare-fun p_4 () Real)
(declare-fun p_5 () Real)

(declare-fun gam_0 () Real)
(declare-fun gam_1 () Real)
(declare-fun gam_2 () Real)
(declare-fun gam_3 () Real)
(declare-fun gam_4 () Real)
(declare-fun gam_5 () Real)

(declare-fun c_0_1 () Real)
(declare-fun c_1_1 () Real)
(declare-fun c_2_1 () Real)
(declare-fun c_3_1 () Real)
(declare-fun c_4_1 () Real)
(declare-fun c_5_1 () Real)
(declare-fun c_0_2 () Real)
(declare-fun c_1_2 () Real)
(declare-fun c_2_2 () Real)
(declare-fun c_3_2 () Real)
(declare-fun c_4_2 () Real)
(declare-fun c_5_2 () Real)

(declare-fun correct_0 () Bool)
(declare-fun correct_1 () Bool)
(declare-fun correct_2 () Bool)
(declare-fun correct_3 () Bool)
(declare-fun correct_4 () Bool)
(declare-fun correct_5 () Bool)

(declare-fun left_0 () Bool)
(declare-fun left_1 () Bool)
(declare-fun left_2 () Bool)
(declare-fun left_3 () Bool)
(declare-fun left_4 () Bool)
(declare-fun left_5 () Bool)

(declare-fun ahead_0 () Bool)
(declare-fun ahead_1 () Bool)
(declare-fun ahead_2 () Bool)
(declare-fun ahead_3 () Bool)
(declare-fun ahead_4 () Bool)
(declare-fun ahead_5 () Bool)

(declare-fun canal_0 () Bool)
(declare-fun canal_1 () Bool)
(declare-fun canal_2 () Bool)
(declare-fun canal_3 () Bool)
(declare-fun canal_4 () Bool)
(declare-fun canal_5 () Bool)

(declare-fun dp_0 () Dt)
(declare-fun dp_1 () Dt)
(declare-fun dp_2 () Dt)
(declare-fun dp_3 () Dt)
(declare-fun dp_4 () Dt)
(declare-fun dp_5 () Dt)

(declare-fun dgam_0 () Dt)
(declare-fun dgam_1 () Dt)
(declare-fun dgam_2 () Dt)
(declare-fun dgam_3 () Dt)
(declare-fun dgam_4 () Dt)
(declare-fun dgam_5 () Dt)

(declare-fun dc_0 () Dt)
(declare-fun dc_1 () Dt)
(declare-fun dc_2 () Dt)
(declare-fun dc_3 () Dt)
(declare-fun dc_4 () Dt)
(declare-fun dc_5 () Dt)

;;; Initializations

(assert (and (= t_0 t0)
             (= p_0 p0) (= gam_0 gam0)
             (= c_0_1 c_0_2 c0)
             (= correct_0 correct0) (= left_0 left0)
             (= ahead_0 ahead0) (= canal_0 canal0)
))

;;; Steps definition

(assert (and (= t_1  (+ t_0  T))
             (= t_2  (+ t_1  T))
             (= t_3  (+ t_2  T))
             (= t_4  (+ t_3  T))
             (= t_5  (+ t_4  T))
))

;;; Derivatives declaration and definition

(declare-ode p (dp_move dp_fail) (gam r))
(define-dt dp_move (gam r) (* (- r) (sin gam)))
(define-dt dp_fail (gam r) 0)

(declare-ode gam (dgam_left dgam_right dgam_ahead) (om))
(define-dt dgam_left  (om) (- om))
(define-dt dgam_right (om)    om )
(define-dt dgam_ahead (om) 0)

(declare-ode c (dc_inc dc_dec dc_idle) ())
(define-dt dc_inc  ()    1 )
(define-dt dc_dec  () (- 2))
(define-dt dc_idle ()    0 )

;;; Integration

(assert (and (= p_1 (int-ode p dp_0 (p_0 t_0 t_1) (gam_0 r)) )
             (= p_2 (int-ode p dp_1 (p_1 t_1 t_2) (gam_1 r)) )
             (= p_3 (int-ode p dp_2 (p_2 t_2 t_3) (gam_2 r)) )
             (= p_4 (int-ode p dp_3 (p_3 t_3 t_4) (gam_3 r)) )
             (= p_5 (int-ode p dp_4 (p_4 t_4 t_5) (gam_4 r)) )
))

(assert (and (= gam_1 (int-ode gam dgam_0 (gam_0 t_0 t_1) (om)) )
             (= gam_2 (int-ode gam dgam_1 (gam_1 t_1 t_2) (om)) )
             (= gam_3 (int-ode gam dgam_2 (gam_2 t_2 t_3) (om)) )
             (= gam_4 (int-ode gam dgam_3 (gam_3 t_3 t_4) (om)) )
             (= gam_5 (int-ode gam dgam_4 (gam_4 t_4 t_5) (om)) )
))

(assert (and (= c_1_1 (int-ode c dc_0 (c_0_2 t_0 t_1) ()) )
             (= c_2_1 (int-ode c dc_1 (c_1_2 t_1 t_2) ()) )
             (= c_3_1 (int-ode c dc_2 (c_2_2 t_2 t_3) ()) )
             (= c_4_1 (int-ode c dc_3 (c_3_2 t_3 t_4) ()) )
             (= c_5_1 (int-ode c dc_4 (c_4_2 t_4 t_5) ()) )
))

;;; Derivatives connection

(define-fun connect ( (dp Dt) (dgam Dt) (dc Dt)
                      (correct Bool) (left Bool)
                      (ahead Bool) (canal Bool) ) Bool
    (and (=>      canal           (and (= dp dp_fail     )
                                       (= dgam dgam_ahead)
                                       (= dc dc_idle     ) ))
         (=> (not canal)               (= dp dp_move     )  )
         (=>      ahead           (and (= dgam dgam_ahead)
                                       (= dc dc_idle     ) ))
         (=> (and      left             )    (= dgam dgam_left )  )
         (=> (and (not canal) (not left) (not ahead)) (= dgam dgam_right))
         (=> (and (not canal) (not ahead)      correct)  (= dc dc_dec )  )
         (=> (and (not canal) (not ahead) (not correct)) (= dc dc_inc )  )
))

(assert (and (connect dp_0 dgam_0 dc_0 correct_0 left_0 ahead_0 canal_0)
             (connect dp_1 dgam_1 dc_1 correct_1 left_1 ahead_1 canal_1)
             (connect dp_2 dgam_2 dc_2 correct_2 left_2 ahead_2 canal_2)
             (connect dp_3 dgam_3 dc_3 correct_3 left_3 ahead_3 canal_3)
             (connect dp_4 dgam_4 dc_4 correct_4 left_4 ahead_4 canal_4)
             (connect dp_5 dgam_5 dc_5 correct_5 left_5 ahead_5 canal_5)
))

;;; States conditions

(define-fun states ( (correct Bool) (left Bool)
                      (ahead Bool) (canal Bool) ) Bool
    (and (=>      canal           (and (not correct) (not left) (not ahead) ))
         (=>    correct           (and (not canal)                          ))
         (=>      ahead           (and (not canal)   (not left)             ))
         (=>       left           (and (not canal)              (not ahead) ))
))

(assert (and (states correct_0 left_0 ahead_0 canal_0)
             (states correct_1 left_1 ahead_1 canal_1)
             (states correct_2 left_2 ahead_2 canal_2)
             (states correct_3 left_3 ahead_3 canal_3)
             (states correct_4 left_4 ahead_4 canal_4)
             (states correct_5 left_5 ahead_5 canal_5)
))

;;; Jump conditions

(define-fun jump ((correct1 Bool) (correct2 Bool)
                  (left1    Bool) (left2    Bool)
                  (ahead1   Bool) (ahead2   Bool)
                  (canal1   Bool) (canal2   Bool)
                  (p2       Real)
                  (c2_1     Real) (c2_2     Real)) Bool
    (and (=> (and (not correct1) (not left1)      ahead1  (not canal1) )
             (and (=> (and (> p2  p_lo) (< p2  p_hi))
                      (and (not correct2) (not left2)      ahead2  (not canal2)
                           (= c2_2 c2_1) ))
                  (=> (and (<= p2  p_lo))
                      (and (not correct2)      left2  (not ahead2) (not canal2)
                           (= c2_2 0) ))
                  (=> (and (>= p2  p_hi))
                      (and (not correct2) (not left2) (not ahead2) (not canal2)
                           (= c2_2 0) ))
         ))
         (=> (and (not correct1)      left1  (not ahead1) (not canal1) )
             (and (=> (and (>  p2 p_min) (< p2  p_lo))
                      (and (not correct2)      left2  (not ahead2) (not canal2) ))
                  (=> (and (>= p2 p_lo))
                      (and      correct2  (not left2) (not ahead2) (not canal2) ))
                  (=> (and (<= p2 p_min))
                      (and (not correct2) (not left2) (not ahead2)      canal2  ))
                  (= c2_2 c2_1)
         ))
         (=> (and (not correct1) (not left1) (not ahead1) (not canal1) )
             (and (=> (and (<  p2 p_hi))
                      (and (not correct2) (not left2) (not ahead2) (not canal2) ))
                  (=> (and (>= p2 p_hi))
                      (and      correct2       left2  (not ahead2) (not canal2) ))
                  (= c2_2 c2_1)
         ))
         (=> (and (not correct1) (not left1) (not ahead1)      canal1  )
             (and (not correct2) (not left2) (not ahead2)      canal2
                  (= c2_2 c2_1)
         ))
         (=> (and      correct1       left1  (not ahead1) (not canal1) )
             (and (=> (and (>  c2_1 0) (>  p2 p_lo))
                      (and      correct2       left2  (not ahead2) (not canal2)
                           (= c2_2 c2_1) ))
                  (=> (and (<= c2_1 0))
                      (and      correct2  (not left2)      ahead2  (not canal2)
                           (= c2_2 c2_1) ))
                  (=> (and (<= p2 p_lo))
                      (and (not correct2)      left2  (not ahead2) (not canal2)
                           (= c2_2 0) ))
         ))
         (=> (and      correct1  (not left1) (not ahead1) (not canal1) )
             (and (=> (and (>  c2_1 0) (<  p2 p_hi))
                      (and      correct2  (not left2) (not ahead2) (not canal2)
                           (= c2_2 c2_1) ))
                  (=> (and (<= c2_1 0))
                      (and      correct2  (not left2)      ahead2  (not canal2)
                           (= c2_2 c2_1) ))
                  (=> (and (>= p2 p_hi))
                      (and (not correct2) (not left2) (not ahead2) (not canal2)
                           (= c2_2 0) ))
         ))
         (=> (and      correct1  (not left1)      ahead1  (not canal1) )
             (and      correct2  (not left2)      ahead2  (not canal2)
                  (= c2_2 c2_1)
         ))
))

(assert (and (jump correct_0 correct_1 left_0 left_1 ahead_0 ahead_1 canal_0 canal_1 p_1 c_1_1 c_1_2)
             (jump correct_1 correct_2 left_1 left_2 ahead_1 ahead_2 canal_1 canal_2 p_2 c_2_1 c_2_2)
             (jump correct_2 correct_3 left_2 left_3 ahead_2 ahead_3 canal_2 canal_3 p_3 c_3_1 c_3_2)
             (jump correct_3 correct_4 left_3 left_4 ahead_3 ahead_4 canal_3 canal_4 p_4 c_4_1 c_4_2)
             (jump correct_4 correct_5 left_4 left_5 ahead_4 ahead_5 canal_4 canal_5 p_5 c_5_1 c_5_2)
))
