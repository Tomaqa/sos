% options:
% thesis=B bachelor's thesis
% thesis=M master's thesis
% czech thesis in Czech language
% slovak thesis in Slovak language
% english thesis in English language
% hidelinks remove colour boxes around hyperlinks
\documentclass[thesis=M,czech]{FITthesis}[2012/06/26]

\usepackage[utf8]{inputenc} % LaTeX source encoded as UTF-8

\usepackage{graphicx} %graphics files inclusion
\usepackage{dirtree} %directory tree visualisation

\usepackage{csvsimple} % For csv importing.
% \usepackage{longtable}

\usepackage{amsmath} %advanced maths
\usepackage{mathtools}

\usepackage{microtype}

\usepackage{fancyvrb}

\usepackage{pdfpages}
%% includepdf is used in 'FITthesis.cls'

%%%%%%%%%%%%%%%%%

\renewcommand{\arraystretch}{1.15}

\usepackage{enumitem}
\setitemize{noitemsep,topsep=2pt,parsep=4pt}
\setenumerate{noitemsep,topsep=2pt,parsep=4pt}
\setenumerate[2]{label=\roman*.}
\setdisplayed{topsep=4pt}

% \clubpenalty=500

%%%%%%%%%%%%%%%%%

\setcounter{tocdepth}{1}

%%%% List of acronyms
\usepackage[acronym,toc,numberedsection=autolabel]{glossaries}

\newcommand{\acrlabel}[1]{acr:#1}
\newcommand{\acr}[1]{\acrshort{\acrlabel{#1}}}
\newcommand{\acrl}[1]{\acrlong{\acrlabel{#1}}}
\newcommand{\acrf}[1]{\acrfull{\acrlabel{#1}}}
\newcommand{\acrfc}[1]{\acrl{#1}, \acr{#1}}

\newcommand{\newacr}[3]{\newacronym{\acrlabel{#1}}{#2}{#3}}

\makeglossaries


\newacr{cvut}{{\v C}VUT}{{\v C}esk{\' e} vysok{\' e}
   u{\v c}en{\' i} technick{\' e} v~Praze}
\newacr{fit}{FIT}{Fakulta informa{\v c}n{\' i}ch technologi{\' i}}

\newacr{api}{API}{Application programming interface}
\newacr{ansi}{ANSI}{American National Standards Institute}
\newacr{ascii}{ASCII}{American Standard Code for~Information Interchange}
\newacr{pdf}{PDF}{Portable Document Format}
\newacr{cpu}{CPU}{Central processing unit}
\newacr{gpu}{GPU}{Graphics processing unit}

\newacr{gpl}{GPL}{General Public License}
\newacr{gnu}{GNU}{GNU's Not Unix!}
\newacr{mit}{MIT}{Massachusetts Institute of~Technology}
\newacr{os}{OS}{Operační systém}
\newacr{posix}{POSIX}{Portable Operating System Interface}
\newacr{cc}{CC}{Creative Commons}

\newacr{simd}{SIMD}{Single instruction multiple data}
\newacr{omp}{OpenMP}{Open Multi-Processing}
\newacr{mpi}{MPI}{Message Passing Interface}

\newacr{stl}{STL}{Standard Template Library}
\newacr{tmp}{TMP}{Template Metaprogramming}

\newacr{bmc}{BMC}{Bounded Model Checking}
\newacr{cnf}{CNF}{Conjunctive normal form}
\newacr{dpll}{DPLL}{Davis--Putnam--Logemann--Loveland}
\newacr{sat}{SAT}{Boolean satisfiability problem}
\newacr{smt}{SMT}{Satisfiability Modulo Theories}
\newacr{np}{NP}{Nondeterministic polynomial time}
\newacr{qbf}{QBF}{Quantified Boolean formulas}
\newacr{fol}{FOL}{First-order logic}
\newacr{ltl}{LTL}{Linear time logic}
\newacr{ctl}{CTL}{Computation tree logic}
\newacr{dimacs}{DIMACS}{Center for Discrete
   Mathematics and Theoretical Computer Science}
\newacr{cvc}{CVC}{Cooperating Validity Checker}

\newacr{ode}{ODE}{Ordinary differential equation}
\newacr{dae}{DAE}{Differential-algebraic equation}
\newacr{ivp}{IVP}{Initial value problem}
\newacr{sundials}{SUNDIALS}{SUite of Nonlinear and
   DIfferential/ALgebraic Equation Solvers}
\newacr{bdf}{BDF}{Backward differentiation formula}

\newacr{sos}{SOS}{\acr{smt}+\acr{ode} Solver}

%%%%%%%%%%%%%%%%%
%%%% Debug commands

\newcommand{\cmt}[1]{\textit{/* #1 */}}

%%%%%%%%%%%%%%%%%
%%%% Text mode commands

\newcommand{\id}[1]{\texttt{#1}}

\newcommand{\hl}[1]{\textit{#1}}
\newcommand{\hll}[1]{\textbf{#1}}

\newcommand{\name}[1]{\hl{#1}}

\newcommand{\cit}[1]{\cite{#1}}
\newcommand{\rf}[1]{\ref{#1}}
\newcommand{\rfeq}[1]{(\rf{eq:#1})}

\newcommand{\reg}{\textsuperscript{\textregistered}}

% \newcommand{\itab}[1]{\hspace{0em}\rlap{#1}}
% \newcommand{\tab}[1]{\hspace{.2\textwidth}\rlap{#1}}

%%%%%%%%%%%%%%%%%
%%%% Math mode commands

\newcommand{\tg}{\mathop{\mathrm{tg}}} %cesky tangens
\newcommand{\cotg}{\mathop{\mathrm{cotg}}} %cesky cotangens

%% Vectors and matrices
\renewcommand{\vec}[1]{\ensuremath{\boldsymbol{#1}}}
\newcommand{\mat}[1]{\ensuremath{\mathbb{#1}}}
\newcommand{\set}[1]{\ensuremath{\mathcal{#1}}}

\newcommand{\trans}[1]{\ensuremath{#1^\top}}
\newcommand{\conj}[1]{\ensuremath{\overline{#1}}}
\newcommand{\ctrans}[1]{\ensuremath{#1^*}}
\newcommand{\inv}[1]{\ensuremath{#1^{-1}}}
\newcommand{\norm}[1]{\ensuremath{\left\lVert#1\right\rVert}}

\newcommand{\der}[1]{\ensuremath{\dot{#1}}}
\newcommand{\dvec}[1]{\der{\vec{#1}}}

\newcommand{\pred}[1]{\ensuremath{\tilde{#1}}}
\newcommand{\pvec}[1]{\pred{\vec{#1}}}
\newcommand{\pmat}[1]{\pred{\mat{#1}}}

\newcommand{\gues}[1]{\ensuremath{\hat{#1}}}
\newcommand{\gvec}[1]{\gues{\vec{#1}}}
\newcommand{\gmat}[1]{\gues{\mat{#1}}}
%%

%%%%%%%%%%%%%%%%%

\newcommand{\binDir}{\id{bin}}
\newcommand{\binFn}[1]{\id{\binDir{}/\-#1}}
\newcommand{\appletDir}{\id{\binDir{}/\-applet}}
\newcommand{\appletFn}[1]{\id{\appletDir{}/\-#1}}
\newcommand{\srcDir}{\id{src}}
\newcommand{\srcFn}[1]{\id{\srcDir{}/\-#1}}

%%%%%%%%%%%%%%%%%

\newcommand{\picFn}[1]{../img/#1}
\newcommand{\picL}{pic}
\newcommand{\rfPic}[1]{(\rf{\picL:#1})}

% 1-File basename
% 2-Label
% 3-Width ratio
% 4-Caption
% 5-Details
\newcommand{\pic}[5]{
\begin{figure}
{\centering
\includegraphics[width=#3\linewidth]{\picFn{#1}}
\caption{#4}
\label{\picL:#2}
}\smallskip
#5
\end{figure}
}

\newcommand{\tabFn}[1]{../data/#1}
\newcommand{\tabL}{tab}
\newcommand{\rfTab}[1]{(\rf{\tabL:#1})}

% 1-File basename
% 2-Label
% 3-Width ratio
% 4-Caption
% 5-Details
% \newcommand{\tab}[5]{
% \begin{table}
% \caption{#4}
% \medskip
% #5
% \centering
% \vskip 0.5\baselineskip
% \resizebox{#3\columnwidth}{!}{
% % \csvautotabular[respect all]{\tabFn{#1}}
% \csvautotabular{\tabFn{#1}}
% }
% \label{\tabL:#2}
% \end{table}
% }

% 1-Label
% 2-Width ratio
% 3-Caption
% 4-Details
% 5-Column desription
% 5-Tabular body
\newcommand{\tab}[6]{
\begin{table}
\caption{#3}
{\centering
\vskip 0.5\baselineskip
\resizebox{#2\columnwidth}{!}{
\begin{tabular}{#5}
\toprule
#6
\end{tabular}
}
\label{\tabL:#1}\\
}\medskip
#4
\end{table}
}


%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%

\department{Katedra číslicového návrhu}
\title{SAT s~diferenciálními rovnicemi}
\authorGN{Tomáš} %(křestní) jméno autora
\authorFN{Kolárik} %příjmení autora
\authorWithDegrees{Bc. Tomáš Kolárik} %jméno autora
                                      %včetně současných akademických titulů
\author{Tomáš Kolárik} %jméno autora bez akademických titulů
\supervisor{doc. Dipl.-Ing. Dr. techn. Stefan Ratschan}
\acknowledgements{Děkuji celé své rodině
za~veškerou podporu a motivaci během celého studia.
Dále panu vedoucímu doc. Dipl.-Ing. Dr. techn. Stefanu Ratschanovi
za~navržené téma práce
a profesionální a velmi ochotnou asistenci s~jejím vypracováním.}

% Sun 06 May 2018 08:22:32 PM CEST
\abstractCS{
% Úvod
Na~mnoho dnešních systémů, např. vestavných,
jsou kladeny vysoké nároky na~splnění specifikací,
které často závisí na~jevech z~fyzikálního okolí.
Pro~rozsáhlé systémy se osvědčuje
použití formální verifikace jako nástroje
pro~garanci splnění specifikací.

% Motivace
Formální verifikace exaktně ověřuje
matematický model systému;
jedním z~používaných postupů je např. \acr{sat}.
Problém nastává, když potřebujeme
v~modelu použít také diferenciální rovnice (\acr{ode}),
které jsou pro~popis fyzikálních jevů zcela přirozené.

% Cíl
Práce se zabývá ověřením konceptu,
který kombinuje \acr{sat} i~\acr{ode}
a lze použít např. pro~formální verifikaci
modelů vestavných systémů.
Takové řešiče již existují
(např. dReal),
ale jsou v~praxi těžko použitelné,
jelikož při~řešení \acr{ode}
více dbají na~přesnost,
ale jsou pomalé.
Cílem bylo pro~\acr{ode} použít
klasických numerických metod,
které mohou být méně přesné,
ale jsou rychlejší.

% Postupy, metody
Součástí práce je prototyp nástroje
nazvaný \acr{sos} (\acrl{sos}),
který kombinuje \acr{smt} (rozšíření problému \acr{sat})
s~diferenciálními rovnicemi.
\acr{smt} a \acr{ode} řešiče
jsou oba nezávislé od~ostatních komponent.
Použit byl řešič odeint,
a z~\acr{smt} řešičů to byly \acr{cvc}4 a z3.

% Výsledky, užitek
Hlavními výstupy jsou zjištění,
že použití klasických numerických metod
urychluje celkový výpočet,
a dále, že výpočet úloh
s~přesnými počátečními podmínkami (\acr{ivp})
je mnohem rychlejší,
než úloh s~intervaly (I\acr{ivp}).
Intervaly lze přitom efektivně aproximovat
výčty hodnot v~logickém součtu.
Tato zjištění potvrzují náš zvolený koncept,
a byla ověřena v~některých příkladech,
kdy byl náš postup rychlejší,
než u~stávajícího řešiče dReal.

% Závěr
Tím bylo dosaženo cíle
v~praxi použitelnějšího
přístupu k~formální verifikaci
systémů s~diferenciálními rovnicemi.
Práce by měla sloužit jako zdroj inspirace
pro~vývojáře průmyslových nástrojů,
anebo by také mohla být nadále vyvíjena
a zefektivňována
v~rámci stávajícího projektu
s~otevřenými zdrojovými kódy.
}
\abstractEN{
Many nowadays systems, namely embedded,
are insisted to~satisfy high specification requirements,
which often depend on~physical features of~real world.
Formal verification showed to~be convenient method
to~guarantee fulfillment of~specifications
of~complex systems.

Formal verification checks mathematical model of~a~system exactly;
one of~used approaches is e.g.~\acr{sat}.
Problem arises when one needs to~use
another means of~modelling---%
differential equations (\acr{ode}s),
which describe physical features natively.

Goal of~this paper is to~prove a~concept
which combines \acr{sat} with~\acr{ode}s
and can be used e.g.~to~formally verify
models of~embedded systems.
Such solvers already exist (e.g.~dReal),
but their usage in~industry is limited
due to~their preference of~accuracy over~speed
in~\acr{ode}s.
The objective was to~apply
classic numerical methods for~solving \acr{ode}s,
which are less accurate, but faster.

This work includes prototype implementation
named \acr{sos} (\acrl{sos}),
which combines \acr{smt}
(extension of~\acr{sat})
with~\acr{ode}s.
\acr{smt} and \acr{ode} solvers
are both independent of~rest components.
Used solvers are odeint
and from~\acr{smt} solvers \acr{cvc}4 and z3.

The~major observations are
that using classic numerical methods
fastens overall computation,
and that computation time of~tasks
with precise initial values (\acr{ivp})
is much smaller than at~tasks with~intervals (I\acr{ivp}).
And intervals can be effectively approximated
by value enumerations in~logical sum.
These observations approve our chosen concept
and were verified in~some examples,
where our procedure was faster
than in~current solver dReal.

Thus the~goal of~a~more appropriate method
for~industry needs,
in~the~field of~formal verification with~\acr{ode}s,
has been reached.
This work is assumed to~serve
as~a~source of~inspiration
to~designers of~industry tools.
Or, it can be developing and improving henceforth
inside the~current open-source project.
}
\placeForDeclarationOfAuthenticity{V~Praze}
\declarationOfAuthenticityOption{2} %volba Prohlášení (číslo 1--6)
\keywordsCS{\acr{sat}, \acr{smt}, \acr{smt}-LIB,
numerické metody řešení~\acr{ode},
formální verifikace,
vestavné systémy,
analýza modelů hybridních systémů}
\keywordsEN{\acr{sat}, \acr{smt}, \acr{smt}-LIB,
numerical methods for~\acr{ode}s,
formal verification,
embedded systems,
hybrid systems model analysis}
\website{https://github.com/Tomaqa/sos} %volitelná URL práce,
%% objeví se v tiráži~---~úplně odstraňte, nemáte-li URL práce

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Sun 06 May 2018 08:33:20 PM CEST
\begin{introduction}\label{ch:intro}
% Úvod
Většina veřejnosti, a nejen té laické,
si z~informačních technologií
jako první vybaví stolní počítače,
notebooky či mobily.
Dnešní mobilní telefony jsou specifické tím,
že jejich funkce souvisí s~vnějšími podněty z~reálného světa:
komunikují přes různá bezdrátová připojení,
pořizují zvukové i~obrazové záznamy,
ovládají se dotykovou obrazovkou, atd.
To všechno znamená interakci s~fyzikálním světem
pomocí různých snímačů a akčních členů.
Existuje však odvětví zařízení,
které se např. od~mobilů liší v~jedné
naprosto zásadní specifikaci.
Jsou to bezpečnostně kritické systémy reálného času,
jejichž hlavní rozdíl tkví v~tom,
že dané akce, které závisí na~vnějších podnětech,
\hl{musí} být bezpodmínečně vykonány
v~rámci daného \hl{časového intervalu}.
Jakmile se to nestane (ať už opožděně nebo vůbec),
dojde k~nějaké katastrofě,
jejíž následky budou drahé
(finanční prostředky, ale i~lidské životy).
Pokud se jedinci opozdí příjem mobilního hovoru,
bude ho to jistě mrzet méně
(alespoň to předpokládejme),
než když se opozdí reakce na~sešlápnutí brzdového pedálu.
Je tedy nutné zavést určité \hl{garance}.
Typickým příkladem takových systémů
jsou např. dopravní prostředky (letadla, tramvaje),
průmyslová zařízení (robotické stroje)
a obecně \name{vestavné systémy}.
S~rostoucími požadavky na~tyto systémy
závratně roste počet různých stavů,
ve~kterých se mohou nacházet,
a které také chceme rozlišovat
na~přípustné a nepřípustné.
Jak lze ale uchopit takto komplexní problémy,
které ještě musí splňovat časové požadavky?
Jak specifikace garantovat?

% Význam tématu pro společnost
Takové systémy už lidstvo používá mnoho desítek let,
přesto je téma této práce aktuální.
Je to způsobeno tím,
že do~určité doby stačilo tyto systémy jen simulovat,
tj. vygenerovat reprezentativní sadu vstupních dat
a kontrolovat výstupy, zda odpovídají zadání.
Tento postup se nazývá \name{funkční verifikace}.
To naráží na~potíž,
že u~bezpečnostně kritických aplikací je záhodno
testovat téměř všechny možné přípustné vstupy.
Vzhledem k~tomu,
že množství kombinací různých vstupních dat
roste exponenciálně s~počtem sledovaných specifikací,
došli někteří vývojáři do~bodu,
kdy byl tento postup testování již příliš
dlouhý, drahý a nespolehlivý.
Tehdy se začal používat i~jiný způsob
ověření spolehlivosti systémů,
pomocí jejich \name{modelu}~---~matematického popisu,
který zanedbává nedůležitá hlediska
a soustředí se na~funkce systému.
Pro~takový zjednodušený model systému
potom lze formálně (tj.~exaktně, zcela přesně) dokázat,
zda mohou či nemohou nastat zakázané stavy.
Tento postup se nazývá \name{formální verifikace}.

% Zaměření
Ve~své práci se zabývám možnými nástroji
sloužícími k~ověření takových modelů systémů.
Jedním z~nejznámějších přístupů
je aplikace problému splnitelnosti Booleovské formule:
\name{\acr{sat}} (angl. \name{\acrl{sat}}),
v~němž lze např. ověřit splnitelnost
formule reprezentující chování vestavného systému.
Tento problém je podrobně prozkoumán
a v~praxi často používán.
Přesto, že se jedná o~\acr{np}-úplný problém,
jsou jeho dnešní řešiče velmi efektivní.
Tyto řešiče jsou ale relativně limitující
v~tom smyslu, že povolují pouze proměnné Booleovského typu.
V~minulém desetiletí započal fenomén
zobecněného problému,
který operuje i~s~dalšími typy proměnných,
zejména aritmetických: \name{\acr{smt}}
(angl. \name{\acrl{smt}})~\cit{smt-de_moura}\cit{smt}.
Vstupní formule tohoto problému mají
větší vyjadřovací schopnost
a jsou lépe uchopitelné pro~návrháře,
jelikož zpravidla umožňují použití
aritmetických rovnic a nerovnic.
Takovými formulemi lze popsat velké množství modelů systémů,
přesto jsou však v~některých případech stále nedostatečné.
A~těchto případů rozhodně není málo:
jedná se právě o~případy, kdy je nutné
do~modelu zahrnout fyzikální, chemické aj.
jevy z~reálného světa,
pro~které je zcela přirozené,
že jsou popsány \name{obyčejnými diferenciálními rovnicemi}
(\name{\acr{ode}}, angl. \name{\acrl{ode}})~\cit{ode-lec}\cit{ode},
které v~obecném případě problém \acr{smt} neovládá.

Takový nástroj by měl mnoho možných uplatnění,
např. ověření modelů regulátorů,
které mají udržovat danou veličinu ve~stanovených mezích;
návrh modelů popisujících dynamiku nějakých těles
tak, aby nedocházelo ke~kolizím s~ostatními;
experimentování se~specifikacemi
spolehlivostních modelů,
atd.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Fri 04 May 2018 05:35:04 PM CEST
\begin{section}{Cíl práce}\label{s:intro:goal}
\acr{smt} řešiče~\cit{opensmt-art}\cit{cvc4-art}
a řešiče diferenciálních rovnic~\cit{sundials-art}\cit{odeint-art}
již existují, ale většinou jen separátně.
Existují i~řešiče, které již obě domény kombinují
(např. dReal~\cit{dreal-art}),
nicméně zatím se jeví jako těžko uplatnitelné v~praxi,
protože jsou příliš pomalé.
Příčinou je to, že používají intervalovou aritmetiku,
čímž kladou důraz na~přesnost
a umožňují garanci maximální chyby.
Tento přístup se týká strany
\acr{ode} řešiče.

Mým úkolem bylo ověřit
odlišný přístup v~řešení \acr{ode}
pomocí \name{klasických numerických metod}~\cit{ode-nsolve-intro},
které neposkytují exaktní garance chyb
a mohou být méně přesné.
Tyto metody pracují s~úlohami,
které mají přesné vstupní podmínky (\acr{ivp}).
Od~tohoto postupu se očekávalo,
že bude mnohem rychlejší,
a tedy i~lépe použitelný v~praxi.
Součástí práce je prototyp nástroje,
který implementuje avizované postupy,
pro~účely ověření zvoleného konceptu.

%%%

% Mon 07 May 2018 04:45:48 PM CEST
\begin{paragraph}{Výsledky.}\label{p:intro:goal:results}
Navržený koncept se podařilo potvrdit.
Největší rozdíl byl pozorován
mezi úlohami \acr{ivp} a úlohami s~intervaly
(I\acr{ivp}), a to bez~ohledu
na~použitý řešič.
Úlohy \acr{ivp} se ukázaly jako mnohem
snazší pro~výpočet,
a jak náš řešič, tak řešič dReal,
tyto úlohy počítal relativně rychle.

V~příkladech, kde tomu nebránila
naše nedostatečná implementace,
si počínalo naše řešení rychleji, než řešič dReal.
Konkrétně se jednalo např. o~modelový příklad
elektrického oscilátoru, jehož změny diskrétního stavu
závisí pouze na~čase,
v~němž naše nejlepší testovaná konfigurace
dosáhla téměř pětinásobně kratšího času.
Tím se potvrdilo,
že je zvolený koncept pro~\acr{ode} řešič efektivnější.

Úspěchu jsme dosáhli i~přesto,
že se zatím jedná pouze o~prototypovou implementaci,
zatímco dReal pochází z~disertační práce
na~Carnegie Mellon University
pod~vedením Edmund M. Clarka (nositel Turingovy ceny)
a je již několik let ve~vývoji.
\end{paragraph} %%Výsledky.

%%%

\end{section} %%Cíl práce

%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Thu 03 May 2018 11:16:31 PM CEST
\begin{section}{Požadavky zadání}\label{s:intro:req}
Zadání požaduje propojení existujících \acr{smt} a \acr{ode} řešičů
a s~tím související úkoly:
\begin{itemize}
\item provést potřebnou rešerši (viz.~dále),
\item navrhnout společné rozhraní
   a vstupní jazyk pro~\acr{smt} i~\acr{ode}
   na~základě \name{\acr{smt}-LIB} standardu~\cit{smtlib},
\item připojit \acr{ode} řešič používající klasické numerické metody,
\item navrhnout řídící algoritmus,
\item implementovat návrh,
\item \hl{srovnat výkonnost navrženého konceptu}
   s~existujícím řešičem dReal a dosáhnout pokud možno větší výkonnosti.
\end{itemize}

%%%

% Fri 04 May 2018 05:54:11 PM CEST
\begin{paragraph}{Rešerše.}\label{p:intro:req:search}
Zadání vyžadovalo seznámení se
s~uvedenými problémy a existujícími nástroji:
\begin{itemize}
\item teoretické podklady problémů \acr{sat}, \acr{smt} a \acr{ode},
\item obecné možnosti řešení problémů,
\item rešerše samostatných \acr{sat} či \acr{smt} řešičů
   a analýza jejich použití,
\item studování \acr{smt}-LIB standardu,
\item rešerše \acr{ode} řešičů, které používají klasické numerické metody,
   a analýza jejich použití,
\item seznámení se se~stávajícími řešiči kombinujícími
   \acr{sat} a \acr{ode},
   které ale používají pomalou intervalovou aritmetiku,
\item inspirovat se zejména těmito řešiči
   při~návrhu vstupního jazyka a řídícího algoritmu.
\end{itemize}
\end{paragraph} %%Rešerše.

%%%

\end{section} %%Požadavky zadání

%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Fri 04 May 2018 06:14:31 PM CEST
\begin{section}{Struktura a návaznost}\label{s:intro:struct}
Předpokládaným postupem práce
bylo vhodně zvolit
oba jednotlivé existující řešiče,
definovat společný vstupní jazyk,
implementovat řešiče či jejich adaptéry
a propojit je.
A~na~závěr to nejdůležitější:
ve~výsledném nástroji
experimentovat s~různými modely systémů
a výsledky porovnat se~stávajícím řešičem dReal.

% Motivace
Mou osobní motivací k~tématu bylo zejména mé zalíbení
v~\acr{sat} řešičích, se kterými jsem v~minulosti reálně pracoval,
a obecně ve~formální verifikaci.

Text této práce postupuje od~teoretických podkladů
přes rozbor možných řešení formulovaných problémů,
návrh a následně realizaci zvoleného řešení,
a končí experimentální částí,
která se zabývá konkrétními příklady modelů,
měřením výkonnosti a srovnáním nástroje s~řešičem dReal.
Zvídavému čtenáři by nemělo uniknout
množství příloh obsahujících
přídavné informace a příklady.
\end{section} %%Struktura a návaznost práce

%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{introduction}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Sat 24 Mar 2018 10:19:00 AM CET
\chapter{Teoretická část}\label{ch:theory}
V~této kapitole se zabývám
teoretickými podklady problémů spjatými s~touto prací.
Pojmy neuvádím zcela přesně,
spíše dávám přednost srozumitelnosti.
Tato práce klade větší důraz na~praktickou část.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Mon 07 May 2018 05:18:37 PM CEST
\begin{section}{Formulace problémů}\label{s:theory:formulation}
Tato sekce popisuje konkrétní problémy a jejich varianty,
kterými se v~této práci zabývám.
Možnosti jejich řešení jsou uvedeny až v~následující kapitole.

%%%%%%%%%%%%%

% Tue 20 Mar 2018 09:36:48 PM CET
\begin{subsection}{Problém splnitelnosti: \acr{sat}}
\label{ss:theory:formulation:sat}
Problém splnitelnosti Booleovské formule
je základním problémem
ze~třídy \acr{np}-úplných problémů%
\footnote{U~tohoto \acr{np} problému
bylo jako u~prvního prokázáno,
že na~něj lze v~polynomiálním čase převést
jakoukoli úlohu ze třídy \acr{np}~\cit{cook-art}.}
v~oboru teorie složitosti.
Jedná se o~široce studovaný problém
implementovaný v~řadě velmi efektivních specializovaných řešičů,
které jsou využívány v~různých aplikacích,
díky možnosti převoditelnosti.
Přestože se jedná o~těžký problém,
i~rozsáhlé praktické instance
(např. se stovkami tisíc proměnných)
je možné řešit rychle,
neboť výskyt instancí s~těmi nejobtížnějšími kombinacemi
je v~praxi nepravděpodobný.

\acr{sat} je definován jako úloha nalezení ohodnocení
Booleovských proměnných \vec{y}
ve~formuli $F$ v~Booleově algebře,
tj.
\begin{equation}\label{eq:sat}
   \exists \vec{y} : \: F(\vec{y}) = 1
\end{equation}
Výstupem je buď nalezené ohodnocení \vec{y},
nebo (typicky) \id{unsat} v~případě, že formule není splnitelná.

Základní verze obsahuje existenční kvantifikátor $\exists$.
Pokud je použit obecný kvantifikátor $\forall$,
jedná se o~problém tautologie, který je co-\acr{np}-úplný
(doplněk k~\acr{np}-úplnému).
Pokud je povolena kombinace obou kvantifikátorů,
hovoříme o~problému \name{kvantifikované Booleovské proměnné}
(angl. \name{\acr{qbf}})
a dostáváme se o~třídu složitosti výše.

Existují i~optimalizační varianty tohoto problému,
často ve~formě vážené splnitelnosti,
kde proměnné nebo klauzule mají přiřazeny váhy
a úkolem je nalézt řešení s~maximální vahou
proměnných či klauzulí, které jsou či nejsou splněny, apod.

%%%

% Wed 07 Mar 2018 04:44:23 PM CET
\begin{paragraph}{\acrf{bmc}}\label{p:theory:formulation:sat:bmc}
(omezené ověření modelu)
je jedna z~hlavních aplikací \acr{sat} problému,
které slouží k~automatizované formální verifikaci
systému reprezentovaného přechodovým systémem~\cit{bmc-art}.
Hlavním cílem je dokázání správnosti modelu,
tj. zda není možné dospět do~zakázaných stavů.
K~účelům specifikace takových přechodových systémů
lze použít temporální logiku,
většinou \acr{ltl} nebo \acr{ctl}.

Základní myšlenka techniky \acr{bmc} spočívá
v~symbolickém nalezení protipříkladu,
který má omezenou délku, vůči zkoumané formuli ze specifikací.
Využívá \acr{sat} řešiče~---~nalezení
ohodnocení proměnných znamená nalezení protipříkladu,
neboli porušení specifikací.
Opačný případ je obtížnější,
neboť teprve projití cest pokrývajících všechny dosažitelné stavy
dokazuje, že zakázané stavy nemohou nastat,
což může vyžadovat prohledání obrovského stavového prostoru.
Algoritmus se tedy opakuje se zvyšující délkou zkoumaných cest
dokud není nalezen protipříklad,
nebo dokud není dosaženo maximální meze.

Alternativní použití \acr{bmc} spočívá ve~zkoumání
negované formule~---~potom nalezení protipříkladu
omezené délky naopak znamená,
že formule je vždy splněna.
\end{paragraph} %% \acrf{bmc}

%%%

\end{subsection} %%Problém splnitelnosti: \acr{sat}

%%%%%%%%%%%%%

% Sat 24 Mar 2018 07:06:03 PM CET
\begin{subsection}{\acrf{smt}}\label{ss:theory:formulation:smt}
Jedná se o~rozšíření problému \acr{sat}
o~další domény než je Booleova algebra,
tzn. dokáže operovat i~s~proměnnými,
jejichž definiční obor je rozsáhlejší než jen
${\{0,1\}}$, nemusí být dokonce ani \hl{konečný}%
\footnote{Zatím se bavíme o~matematickém modelu,
v~konečném důsledku jsou však domény v~implementacích
vždy konečné, protože počítače mají omezenou velikost.
Univerzum však není v~\acr{smt} podstatné.}
(např. v~našem případě kombinování s~\acr{ode}
jsou typickou doménou reálná čísla).
Stále je hlavním zájmem ověřování
splnitelnosti vstupních formulí.

Klíčovým pojmem v~\acr{smt} je \name{teorie},
která je zodpovědná za~definování
funkcí a pravidel nad~jejími prvky.
Speciálním případem teorie je
též teorie Booleovy algebry,
která bývá v~\acr{smt} řešičích
implementována jako teorie základní.

Hlavní motivací \acr{smt} oproti \acr{sat}
je využití aritmetických funkcí a pravidel,
které zlepšují vyjadřovací schopnosti daného jazyka.
Řešení \acr{smt} může být také efektivnější,
než kdyby byla formule celá zakódována do~\acr{sat}.
Složitost rozhodování \acr{smt} se ale dramaticky liší
s~ohledem na~zvolenou teorii: může být i~polynomiální,
ale i~horší než exponenciální~\cit{theories-book}.

%%%%%%%

% Sat 24 Mar 2018 10:28:42 AM CET
\begin{subsubsection}{Teorie}\label{p:theory:formulation:smt:theory}
Teorie prvního řádu (angl. \name{First-order theory})
je vyjádřena v~predikátové logice prvního řádu%
\footnote{Vyšší řády povolují predikáty uvnitř predikátů či funkcí apod.}.
Teorie definuje konečně mnoho pravidel
nad~\hl{abstraktními} prvky,
tj.~aniž by definovala jejich univerzum;
postup je opačný~---~přípustné prvky
jsou určeny výhradně jako důsledek pravidel teorie.

%%%

% Sat 24 Mar 2018 11:23:29 AM CET
\begin{paragraph}{(Predikátová) logika prvního řádu}
\label{p:theory:formulation:smt:theory:fol}
(angl. \name{\acrfc{fol}}).
Hlavní rozdíl oproti Booleově algebře
(resp. výrokové logice)
je ten, že termy formulí mohou být hodnoty
libovolné domény~\cit{theories-book}.

Formule \acr{fol} se skládají
z~proměnných a konstant, predikátů, funkcí,
logických operací a kvantifikátorů.
Termy jsou konstanty, proměnné a funkce.
Predikáty jsou funkce,
které nabývají jen logických hodnot.
Literál je logická proměnná či konstanta,
predikát, nebo jejich negace.

Interpretace formule přiřazuje
elementy, funkce a predikáty nad~nějakou konkrétní doménou
symbolům konstant či proměnných, funkcí a predikátů formule.
Formule je nazývána jako splnitelná,
pokud existuje interpretace,
v~níž je formule vyhodnocena jako pravdivá.
Splnitelnost je primárním rozhodovacím problémem ve~\acr{fol}.

Formální jazyk \acr{fol} je definován jako množina
správně formovaných formulí,
které jsou splnitelné.
Jazyk je \name{rozhodnutelný},
pokud existuje konečný algoritmus,
který korektně rozhoduje,
zda libovolné slovo patří či nepatří do jazyka.
\end{paragraph} %%(Predikátová) logika prvního řádu

%%%

\bigskip

\acr{fol} obecně není rozhodnutelná,
některé teorie však ano.
Důležité u~teorií
(či alespoň některých jejich podmnožin)
je zejména to,
aby byly rozhodnutelné efektivně,
a ne nutně obecně,
ale v~praktických případech.
Díky rozhodnutelnosti lze pak formule
automatizovaně analyzovat.

%%%

% Sat 24 Mar 2018 01:06:59 PM CET
\begin{paragraph}{Definice.}\label{p:theory:formulation:smt:theory:def}
Teorie je definována
\name{značením} a množinou \name{axiomů}.
Značení je množina symbolů konstant, funkcí a predikátů
bez konkrétního významu.
Axiom je uzavřená \acr{fol} formule
obsahující pouze prvky ze~značení teorie.
Formule teorie mohou proti axiomům
navíc obsahovat proměnné, logické operace
a kvantifikátory.
\end{paragraph} %%Definice.

%%%

\bigskip

\name{Fragment} teorie je její podmnožina přípustných formulí.
Častým fragmentem teorií
je fragment bez~kvantifikátorů%
\footnote{Tyto formule však stále implicitně obsahují
univerzální kvantifikátory pro~všechny proměnné.}.
Fragmenty jsou užitečné zejména v~případech,
kdy jsou lépe rozhodnutelné.
Obecně lze říci,
že čím limitovanější teorie je,
tím má blíže k~rozhodnutelnosti%
\footnote{\acr{fol} je též teorie,
ale nijak limitovaná~---~bez axiomů.}.

Součástí každé formule teorie
jsou implicitně také všechny její axiomy.
Proto je nutné vždy uvést, jaká teorie má být použita.
Příklady teorií jsou teorie celých či reálných čísel
a teorie různých datových struktur
(pole, seznam, bitový vektor, fronta, hash tabulka, \dots)
apod. Základní příklady jsou rozvedeny dále podle~\cit{theories-book}.

%%%

% Sat 24 Mar 2018 01:59:38 PM CET
\begin{paragraph}{Teorie rovnosti.}
\label{p:theory:formulation:smt:theory:equal}
Kromě symbolů konstant, funkcí a predikátů
obsahuje jen jediný interpretovaný binární predikát $=$,
jehož chování je definováno axiomy:
\begin{enumerate}
\item \name{Reflexivita}:
   $\forall x : \: x = x$
\item \name{Symetrie}:
   $\forall x,y : \: x = y \Rightarrow y = x$
\item \name{Tranzitivita}:
   $\forall x,y,z : \: x = y \: \land \: y = z \Rightarrow x = z$
\item \name{Funkční kongruence}:
   $\forall \vec{x},\vec{y} : \:
      \left( \forall i = 1, \dots, n : \: x_i = y_i \right)
      \Rightarrow f(\vec{x}) = f(\vec{y})$ \\
   pro~všechna kladná přirozená čísla $n$ a $n$-ární funkce $f$.
\item \name{Predikátová kongruence}:
   $\forall \vec{x},\vec{y} : \:
      \left( \forall i = 1, \dots, n : \: x_i = y_i \right)
      \Rightarrow p(\vec{x}) \Leftrightarrow p(\vec{y})$ \\
   pro~všechna kladná přirozená čísla $n$ a $n$-ární predikáty $p$.
\end{enumerate}

Teorie rovnosti je nerozhodnutelná stejně jako \acr{fol},
protože povoluje všechna značení (obsahující $=$).
Nicméně, fragment bez~kvantifikátorů
už je efektivně rozhodnutelný.
\end{paragraph} %%Teorie rovnosti.

%%%

% Sat 24 Mar 2018 04:29:35 PM CET
\begin{paragraph}{Teorie celých čísel.}
\label{p:theory:formulation:smt:theory:int}
Existují tři základní teorie celých čísel:

\hll{Peanova aritmetika} má značení
$\{ {0, 1}, {+, \cdot}, = \}$
(${0,1}$ jsou konstanty;
${+,\cdot}$ binární funkce;
a $=$ binární predikát)
a následující axiomy:
\begin{enumerate}
\item $\forall x : \: \neg ( x + 1 = 0 )$
\item $\forall x,y : \: x+1 = y+1 \Rightarrow x = y$
\item \label{i:theory:int:ind}
   $F(0) \: \land \: \left( \forall x : \: F(x) \Rightarrow F(x+1) \right)
      \Rightarrow \forall x : \: F(x)$
\item $\forall x : \: x+0 = x$
\item $\forall x,y : \: x + (y+1) = (x+y) + 1$
\item \label{i:theory:int:times0}
   $\forall x : \: x \cdot 0 = 0$
\item \label{i:theory:int:timessuc}
   $\forall x,y : \: x \cdot (y+1) = x \cdot y + x$
\end{enumerate}
Tyto axiomy definují sčítání, násobení a rovnost
přirozených čísel a také \name{indukci}
(axiom \rf{i:theory:int:ind}).
Tato teorie bohužel není rozhodnutelná
(ani bez~kvantifikátorů;
na vině je operace násobení)
a dokonce není ani úplná%
\footnote{Tj.~existují v~ní formule, které nelze dokázat.}.

\hll{Presburgerova aritmetika} vychází z~Peanovy,
ale vynechává operaci násobení,
a tedy i~axiomy \rf{i:theory:int:times0} a \rf{i:theory:int:timessuc}.
Tato teorie je již rozhodnutelná,
a to dokonce i~s~kvantifikátory.
Operace odčítání a nerovností je možné modelovat%
\footnote{Odčítání převedením na~druhou stranu rovnosti,
a nerovnosti přičtením nové konstanty do~rovnosti.},
a je tedy možné vyjádřit celou teorii celých čísel
bez~násobení.

\hll{Teorie celých čísel} má stejné vyjadřovací schopnosti
jako Presburgerova aritmetika,
ale má přirozenější a přívětivější značení:
obsahuje všechna celá čísla jako konstanty,
operaci odčítání a predikáty nerovností.
Také obsahuje unární funkce
umožňující používat celočíselné násobky proměnných.

Nadále budou používány dva pojmy:
\hl{lineární}, resp. \hl{nelineární}
teorie celých čísel
jako teorie celých čísel bez~násobení,
resp. s~násobením.
\end{paragraph} %%Teorie celých čísel.

%%%

% Sat 24 Mar 2018 05:39:05 PM CET
\begin{paragraph}{Teorie reálných čísel.}
\label{p:theory:formulation:smt:theory:real}
I~zde se teorie dělí na \hl{lineární} a \hl{nelineární}
s~ohledem na~použití operace násobení.

\hll{Nelineární teorie reálných čísel}
bývá také označována jednoduše jako teorie reálných čísel.
Má značení $\{ {0, 1}, {+, -, \cdot}, =, \geq \}$
a obsahuje komplexní axiomatizaci
zahrnující všechny axiomy:
\begin{enumerate}
\item \hl{tělesa} nad~${(+, \cdot)}$
   (tj.~axiomy Abelovské grupy nad~${(+)}$ a okruhu nad ${(\cdot)}$),
\item úplného uspořádání $\geq$,
\item uspořádaného tělesa
   (navíc uspořádanost sčítání a násobení),
\item existence kvadratického kořene pro~všechny elementy,
\item existence alespoň jednoho kořene všech polynomů lichého stupně.
\end{enumerate}
Tato teorie je rozhodnutelná i~s~násobením,
nicméně asymptotická složitost rozhodovací procedury
je dvojnásobně exponenciální.

\hll{Lineární teorie reálných čísel},
také označována jako teorie racionálních čísel%
\footnote{Důvod je ten, že každá interpretace teorie,
vzhledem k~jejím axiomům,
je ekvivalentní s~použitím
jak domény reálných, tak racionálních čísel.},
omezuje nelineární teorii reálných čísel
vyjmutím operace násobení
a s~tím i~axiomů pro~násobení a existenci kořenů;
k~tomu přidává axiom, že neutrální prvek ($0$)
je jediným prvkem s~konečným řádem v~Abelovské grupě nad~($+$);
a axiom o~dělitelnosti prvků
(každý prvek je sumou jiného prvku).
Horní asymptotická složitost se u~této teorie sice nezměnila,
ale v~průměru je tato teorie efektivně rozhodnutelná,
zejména její fragment bez~kvantifikátorů.
\end{paragraph} %%Teorie reálných čísel.

%%%

\bigskip

Teorie mohou být navzájem \hl{kombinovány}
(např. teorie polí společně s~teorií celých čísel)
při~splněných určitých podmínek,
např. jejich značení by měla být,
až na výjimku predikátu $=$, disjunktní
(jinak je nutné společné symboly
zavést nově).
Tato možnost je poměrně důležitá,
jinak by bylo zavádění kombinace teorií
jako explicitní nové teorie komplikované.
\end{subsubsection} %%Teorie

%%%%%%%

\end{subsection} %%\acrf{smt}

%%%%%%%%%%%%%

% Wed 21 Mar 2018 01:56:56 AM CET
\begin{subsection}{\acrf{ode}}\label{ss:theory:formulation:ode}
Diferenciální rovnice je rovnice pro~nějakou \hl{neznámou} funkci
a obsahující její derivace,
což je běžné pro~fyzikální vztahy reálného světa.
\hl{Obyčejná} diferenciální rovnice (\name{\acr{ode}})
obsahuje derivace vztažené pouze
k~\hl{jediné nezávislé proměnné},
což je zpravidla čas.
Řešení tohoto speciálního případu je obecně mnohem jednodušší,
přesto však stále není obecně možné nalézt analytické řešení,
a proto se používají numerické metody~\cit{odeint-art}\cit{ode}.

Kromě omezení na~\acr{ode} dále vymezuji
následující vlastnosti:
diferenciální rovnice je \name{prvního řádu}%
\footnote{Rovnice obsahuje pouze první derivace,
což však není omezující,
neboť každá rovnice vyšších řádů
lze přepsat na~soustavu rovnic prvního řádu%
~\cit{ode-valid-runge_kutta-art}\cit{ode-lec}.},
má pevné počáteční podmínky~---~\name{\acrf{ivp}},
a je \name{explicitní}%
\footnote{Derivace funkce je řešena explicitně,
tj.~nevyskytuje se jako argument jiné funkce.}.

Existuje několik možných formulací tohoto problému,
zde je definován jako hledání řešení soustavy rovnic
$n$ neznámých funkcí
(s~výše uvedenými vlastnostmi):
\begin{equation}\label{eq:ode}
\begin{split}
   \vec{\der{y}}(t) &= \vec{f} \! \left( t, \vec{y}(t) \right) \\
   \vec{y}(t_0)     &= \vec{y_0}
\end{split}
\end{equation}
kde ${t \in \set{R}}$ je nezávislá proměnná a \set{R}
je množina reálných čísel;
${\forall i = 1,} \dots, n : \:
{y^i \in \vec{y}} : \: {\set{R} \rightarrow \set{R}}$
je neznámá diferencovatelná funkce $t$,
${\der{y}^i \in \vec{\der{y}}}$ je derivace $y^i$ podle $t$,
a ${f^i \in \vec{f}} : \: {\set{R}^{n+1} \rightarrow \set{R}}$
je funkce Lipschitz-spojitá v~\vec{y}\,%
\footnote{Tento předpoklad podle Picard--Lindelöfova teorému zaručuje,
že řešení takové \acr{ode} existuje právě jedno; viz.~\cit{ode-lec}.};
${t_0 \in \set{R}}$ je počáteční hodnota nezávislé proměnné $t$,
která společně s~${\vec{y_0} \in \set{R}^{n}}$ určuje počáteční podmínky.
Pro~jednoduchost nejsou uvažovány případy,
kdy některá funkce není definována na~celé \set{R}.

Vztahy \rfeq{ode}
lze přepsat do~ekvivalentního tvaru s~integrálem~\cit{ode-lec}:
\begin{equation}
   \vec{y}(t) = \vec{y_0} + \int_{t_0}^{t} \vec{f} \!
      \left( \tau, \vec{y}(\tau) \right) \, \text{d}\tau
\end{equation}
proto bývají někdy numerická řešení \acr{ode}
nazývány jako \name{numerická integrace}.
\end{subsection} %%\acrf{ode}

%%%%%%%%%%%%%

\end{section} %%Formulace problémů}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Mon 07 May 2018 05:40:38 PM CEST
\begin{section}{Hybridní systémy}\label{s:theory:hybrid}
(Dynamický) systém se nazývá \name{hybridním},
pokud vykazuje jak diskrétní, tak spojité změny.
Diskrétní změny jsou charakterizovány \name{skoky} (angl. \name{jumps}),
spojité \name{toky} (angl. \name{flows});
tyto pojmy ale nebudou příliš používány.
Skoky jsou obvykle popsány \name{konečným automatem},
toky pomocí soustav \acr{ode}.

Diskrétní systémy se používají pro~jejich snadný návrh a analýzu;
spojité zejména proto, že popisují procesy z~reálného světa
(fyzikální, chemické, biologické, \dots),
jelikož čas je spojitý.
Všechny digitální počítače jsou diskrétními systémy
s~omezenou přesností,
je na~nich však možné spojité jevy aproximovat.

Hybridní systémy musejí interagovat s~vnějším světem,
často v~reálném čase.
Jedná se tedy o~\name{reaktivní} systémy.
Obvyklými požadavky na~tyto systémy
jsou (kromě jiných) spolehlivost a bezpečnost%
\footnote{V~tomto případě je míněna
bezpečnost z~hlediska spolehlivého selhání
neohrožující majetek či lidi (angl. safety).
Bezpečnost ve~významu zabezpečení
vůči neautorizovanému přístupu (angl. security)
je často také důležitá.}.
Aby mohly být tyto vlastnosti do~vysoké míry zaručeny,
je nutné využít matematický aparát.

%%%

% Mon 07 May 2018 05:32:13 PM CEST
\begin{paragraph}{Hybridní automat.}\label{s:theory:hybrid:auto}
Hybridní systém lze jako celek
matematicky modelovat jako \name{hybridní automat}.
\name{Stav} hybridního automatu
je definován diskrétním řídícím \name{módem}
a spojitými \name{proměnnými}.
Diskrétní změna stavu odpovídá skoku
(v~konečném automatu),
spojitá změna pak toku
(průběhu \acr{ode}).
Módy mohou mít také definovány \name{invarianty}.
Jednoduchá ukázka hybridního automatu
je uvedena na~obrázku \rfPic{thermostat:model}.

\pic{thermostat_model.pdf}{thermostat:model}{0.65}
   {Ukázka hybridního automatu modelu termostatu}
   {$x$ značí teplotu.}

Dále budou v~textu preferovány pojmy
diskrétní stav před~módem
a spojitý stav před~(spojitými) proměnnými.

Analýza hybridního systému pak spočívá
v~rozhodování o~množině stavů,
zda je dosažitelná či naopak
a za jakých podmínek.

Existuje několik nástrojů
analyzujících hybridní systémy
modelované jako hybridní automaty,
ale většinou nejsou založeny
na~problému \acr{sat}.
\end{paragraph} %%Hybridní automat.

%%%

\bigskip

Obě domény samostatně se dnes
používají standardně pro~modelování systémů
a jejich analýzu;
k~tomu jsou hojně využívány
\acr{sat} či \acr{smt} řešiče pro~diskrétní
a \acr{ode} řešiče pro~spojité systémy
(a nebo i~jiné postupy).
Výzvou této práce je ověřit koncept,
který obě domény kombinuje
a současně využívá nástrojů
vycházejících z~fenoménu problému \acr{sat}
a používá klasické numerické metody pro~řešení \acr{ode}.
\end{section} %%Hybridní systémy

%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Mon 07 May 2018 05:16:55 PM CEST
\chapter{Možnosti řešení problematiky}\label{ch:search}
V~této kapitole rozebírám možnosti řešení problémů
uvedených v~kapitole \rf{ch:theory}
a provádím rešerši existujících řešičů.
V~této kapitole rovněž nezabíhám příliš do~detailů.

Uvedené řešiče jsou jak izolované (jen \acr{smt} či \acr{ode}),
tak hybridní (kombinují oba problémy),
ale s~odlišným typem \acr{ode} řešiče, než na jaký jsme cílili.
Pro~úplnost také uvádím sekci ohledně řešení problému \acr{sat}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Tue 06 Mar 2018 11:22:22 PM CET
\begin{section}{\acr{sat} řešiče}\label{s:search:sat}
Ač zde uvádím tuto kategorii řešičů,
používal jsem je jen nepřímo,
neboť jsou součástí \acr{smt} řešičů.

Z~důvodů implementačních a konvence
je většinou vstup do~řešičů uváděn
v~konjunktivní normální formě (angl. \acr{cnf}),
neboli jako konjunkce klauzulí,
kde klauzule je disjunkce literálů.
Standardně se používá \acr{dimacs}-\acr{cnf} formát.

Většina dnešních \acr{sat} řešičů
využívá v~základu algoritmus \acrf{dpll},
který používá několik hlavních operací~\cit{smt-de_moura}:
\begin{itemize}
\item základní simplifikace klauzulí,
\item \hl{substituce}~---~přiřazení hodnoty proměnné,
\item \hl{propagace}~---~aplikace deduktivních pravidel,
   zejména pravidla jednotkové klauzule%
   \footnote{Klauzule s~jediným literálem
   vynucuje jednoznačné ohodnocení této proměnné, aby mohla být celá
   \acr{cnf} formule splněna.},
\item \hl{návrat}~---~navrácení do~nějakého předchozího bodu substituce
   při~nalezení konfliktních ohodnocení.
\end{itemize}

Každý lepší řešič také implementuje nějakou formu učení,
které spočívá v~přidávání dalších klauzulí
na~základě průběžně nacházených konfliktů.

Známými \acr{sat} řešiči jsou např. Mini\acr{sat}~\cit{minisat}%
\footnote{Mini\acr{sat} zvítězil
ve~všech průmyslových kategoriích
v~soutěži \name{\acr{sat} 2005 competition}
a je často integrován pro~svůj
minimalistický a snadno rozšiřitelný návrh.},
Pico\acr{sat} a CryptoMini\acr{sat}.
Příklady použití \acr{sat} řešičů jsou:
\begin{itemize}
\item \acrf{bmc},
\item funkční testování obvodů:\\
   logický obvod s~injektovanou poruchou
   je převeden do~Booleovské formule
   a je ověřena její splnitelnost,
\item statická analýza kódu programu,
\item plánování a grafové problémy
\end{itemize}
a mnoho dalších. Obecně se však většinou jedná
o~nějakou formu formální verifikace.
\end{section} %% \acr{sat} řešiče

%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Mon 09 Apr 2018 02:31:50 PM CEST
\begin{section}{Řešení \acr{smt} problému}\label{s:search:smt}
Jak už bylo zmíněno v~sekci \rf{ss:theory:formulation:smt},
zásadní vliv na~výpočet má teorie použitá ve~vstupní formuli.
\acr{smt} řešiče typicky ovládají jen některé teorie
a jejich fragmenty, nebo některé rozhodují jen s~omezenou efektivitou.

Řešič má za~úkol nalézt splňující ohodnocení
pro~všechny termy vstupní formule,
které se nazývá \name{model}.
Výstupem pak je zpravidla \id{sat} a (volitelně) model.
Pokud formule není splnitelná,
řešiče většinou umožňují vygenerovat
\hl{důkaz} jako certifikát dokládající nesplnitelnost.
Výstupem pak je zpravidla \id{unsat}
a (volitelně) důkaz.
Také se může stát,
že o~splnitelnosti vstupu není možné rozhodnout
(např. pokud řešič nemá implementovány
všechny funkcionality nutné pro~daný vstup).
Výstupem pak může být např. \id{unknown}.

Existují dva základní přístupy k~řešení \acr{smt} problémů:
\name{pilný} (angl. \name{eager}) a \name{líný} (angl. \name{lazy}),
nebo i~jejich kombinace~\cit{smt-stanford}.

%%%

% Mon 07 May 2018 11:51:07 PM CEST
\begin{paragraph}{Pilný přístup}\label{p:search:smt:eager}
soustředí většinu výpočtů
do~\hl{externího} \acr{sat} řešiče tak,
že se snaží v~\hl{jediném kroku} celou \acr{smt} formuli zakódovat
do~\acr{sat} formule (např. celá čísla pomocí bitů
jako Booleovských proměnných).

Do~\acr{sat} řešiče jsou kódovány
také axiomy teorie,
což může potenciálně problém vyřešit rychle.
Slabinou této metody je hrozba exploze
velikosti přeložené formule~\cit{smt-stanford}.

Výkonnost tohoto postupu je kriticky závislá na~použitém \acr{sat} řešiči.
Na~druhou stranu je z~hlediska rozhraní a výpočtu
v~podstatě nezávislý na~použitém \acr{sat} řešiči.
Je flexibilnější než líný přístup,
protože část specifickou pro~teorii tvoří \uv{jen}
optimalizovaný překlad formule,
samotný výpočet už ne.
\end{paragraph} %%Pilný přístup

%%%

% Sun 18 Mar 2018 10:32:18 PM CET
\begin{paragraph}{Líný přístup}\label{p:search:smt:lazy}
spočívá v~použití \acr{sat} řešiče
založeném na~\acr{dpll}
a \set{T}-řešiče
jako dvou více či méně \hl{spolupracujících komponent}
(varianty \name{online} a \name{offline}~\cit{smt-stanford}),
kde \set{T} je nějaká teorie.

Predikáty teorie (resp. omezení, např. lineární nerovnice)
jsou překládány \set{T}-řešičem
na~abstraktní Booleovské literály,
které je interní \acr{sat} řešič schopen pojmout.
V~případě, že je taková formule splnitelná (nutná podmínka),
\set{T}-řešič je použit pro~ověření vytvořeného modelu,
zda je ohodnocení predikátů splnitelné i~v~dané teorii \set{T}.
Tento proces probíhá opakovaně
dokud není dosaženo konvergence~\cit{smt-de_moura}.
Tedy, oba řešiče navzájem intenzivně komunikují
a formování Booleovské formule probíhá (typicky) inkrementálně%
\footnote{To také umožňuje dynamicky
přidávat a odebírat formule s~omezeními.}
s~možností návratů.
V~případě \name{online} varianty jsou oba řešiče
více propojeny a \set{T}-řešič využívá funkce \acr{sat} řešiče přímo.

\set{T}-řešič musí být navržen
speciálně pro~danou teorii \set{T}, typicky \hl{ad hoc}.
\end{paragraph} %%Líný přístup

%%%

\bigskip

Dalším hlediskem je, zda je \acr{smt} řešič jako celek
\name{inkrementální}, který umožňuje
dynamické formování vstupních formulí
a vícenásobné ověřování splnitelnosti nad různými kontexty.
Neinkrementální řešič pracuje jen nad~jediným statickým kontextem
jakožto celým vstupem. Inkrementální umožňuje
průběžně přidávat či odebírat omezení,
která se typicky ukládají do~\hl{zásobníku}.
Ověření splnitelnosti pak lze provést kdykoliv
nad~obsahem vrcholu zásobníku.

\acr{smt} řešiče často pracují nad~kombinací více teorií
kvůli větší expresivitě.
V~takovém případě je z~hlediska výkonu
důležité udržovat teorie v~hierarchii
a v~každém kroku použít
jen nezbytně nutnou úroveň~\cit{smt-stanford}.

%%%%%%%%%%%%%

% Mon 09 Apr 2018 02:39:23 PM CEST
\begin{subsection}{\acr{smt}-LIB standard}\label{ss:search:smt:smtlib}
\acr{smt}-LIB je iniciativa
založená pro~účely rozvoje výzkumu a vývoje \acr{smt} řešičů,
jejíž nejvýznamnější činností
je standardizace teorií
a vstupně-výstupního jazyka pro~řešiče~\cit{smtlib}.
S~tím souvisí udržování komunity vývojářů
a souboru standardizovaných výkonnostních úloh (benchmarků),
ve~kterých jednotlivé týmy soutěží např. v~rámci \name{\acr{smt}-COMP},
podobně jako tomu je u~komunity \acr{sat} řešičů.

\acr{smt}-LIB jako teorie označuje
teorie v~základním znění bez~dalších omezení.
Pro~konkrétní fragment teorie,
ve~kterém je daná vstupní formule vyjádřena,
se používá termín \name{logika}.
Tyto logiky se pak navzájem kombinují
či se redukují jejich restrikce.
Z~pohledu řešiče (konformního s~tímto standardem)
se operuje pouze s~logikami;
teorie slouží pouze jako teoretický základ.

Pro~odlišení prvků pocházejících z~různých teorií
se používají \name{druhy} prvků (angl. \name{sort}),
které připomínají datové typy programovacích jazyků.
Proměnné ve~formuli jsou označovány jako konstanty%
\footnote{Proměnná by mohla vyvolávat dojem,
že lze do~proměnných, podobně jako v~programovacích jazycích,
dynamicky přiřazovat hodnoty, což nelze.};
pojmy term a predikát
nejsou používány~---~všechny konstrukty
formule \acr{fol} jsou vyjádřeny
pomocí konstant a funkcí,
které jsou případně logického druhu.

Momentálně existuje verze 2 standardu,
která definuje hierarchii dílčích logik,
z~důvodu možnosti aplikace efektivnějších výpočtů pro~jednodušší formule,
a protože pak lze v~rámci izolovaných logik
efektivněji srovnávat řešiče navzájem.
Logiky povolují jen některé druhy konstant a funkcí
(podle použitých teorií)
a případně povolují i~definici volných druhů.

%%%

% Sat 24 Mar 2018 10:45:22 PM CET
\begin{paragraph}{Názvosloví logik.}\label{p:search:smt:smtlib:name}
Standard definuje konvence pro~pojmenování jednotlivých logik
podle použitých teorií, např.:
\begin{itemize}
\item \id{BV} (bit vectors)~---~teorie bitových vektorů omezené šířky,
\item \id{IA} (integer arithmetic)~---~teorie celých čísel,
\item \id{RA} (reals arithmetic)~---~teorie reálných čísel,
\item \id{IRA}~---~kombinace \id{IA} a \id{RA},
\end{itemize}
a jejich fragmentů jako předpony:
\begin{enumerate}
\item \id{QF\_} (quantifier-free)~---~fragment bez~kvantifikátorů,
\item \id{UF} (uninterpreted functions)~---~fragment povolující
   použití volných druhů prvků a neinterpretovaných funkcí,
\item \id{L}, resp. \id{N} (linear, resp. non-linear)~---~lineární,
   resp. nelineární fragment aritmetické logiky.
\end{enumerate}

Příklady některých logik:
\id{BV}, \id{UF}, \id{QF\_\-LRA}, \id{QF\_\-UFNRA}, \id{UFNIA}, \dots
\end{paragraph} %%Názvosloví logik.

%%%

\bigskip

Základní příkazy jazyka jsou deklarace či definice konstant a funkcí,
nových druhů, a přidávání formulí do \name{asercí}.
neboli podmínek, které musí být splněny.
Ověření splnitelnosti pak spočívá v~hledání ohodnocení
všech konstant a funkcí splňující konjunkci všech asercí,
podobně jako v~\acr{sat} řešičích.

Jazyk lze použít i~pro~inkrementální řešiče,
pro~které lze využít operací přidávání a odebírání
asercí ze~zásobníku.
Ověření splnitelnosti pak vždy probíhá
nad~vrcholem zásobníku.

Základní vlastnosti standardu verze~2
uvádí např. tento tutoriál~\cit{smtlib-tutorial-art}.
Podrobný popis \acr{smt}-LIB standardu verze 2.6
je k~nalezení v~referenčním dokumentu~\cit{smtlib-reference-art}.
\end{subsection} %%\acr{smt}-LIB standard

%%%%%%%%%%%%%

% Sun 06 May 2018 10:02:17 PM CEST
\begin{subsection}{\acr{smt} řešiče}\label{ss:search:smt:solver}
Použití \acr{smt} řešičů se do~značné míry kryje se \acr{sat} řešiči,
často je nahradily, resp. rozšířily.
Uvádím jen malé množství řešičů,
v~porovnání s~celkovým počtem.

%%%

% Sun 06 May 2018 09:51:57 PM CEST
\begin{paragraph}{\acr{cvc}4}\label{p:search:smt:solver:cvc4}
je inkrementální open-source \acr{smt} řešič~\cit{cvc4}\cit{cvc4-art},
který je navržen pro~snadné rozšiřování
a poskytuje rozhraní v~C++
a také rozhraní textové přes vstupní jazyk,
tzn. že nástroj lze použít jak jako knihovnu,
tak samostatně,
tj.~jako \name{černou skříňku} (angl. \name{black box}).
Jedná se o~poměrně rozsáhlý projekt.

\acr{cvc}4 přijímá vlastní vstupní jazyk,
nebo standard \acr{smt}-LIB verze 1 nebo 2.
Podporuje řadu teorií (resp. logik):
číselné aritmetiky, bit vektory, pole, řetězce\dots
Podporuje také kvantifikátory
a nelineární logiky.

Nástroj původně používal vlastní \acr{sat} řešič,
nyní používá Mini\acr{sat}~\cit{cvc4-art}.
K~řešení \acr{smt} používá líný přístup
založený na~algoritmu \acr{dpll}.

Řešič se celkově umístil na~1.~pozici
v~mezinárodní soutěži
\name{\acr{smt}-COMP}~\cit{smtcomp}\cit{smtcomp-art}
v~roce 2015 a 2017.
\end{paragraph} %%\acr{cvc}4

%%%

% Sun 06 May 2018 09:41:58 PM CEST
\begin{paragraph}{Open\acr{smt}}\label{p:search:smt:solver:opensmt}
(konkrétně jeho druhá verze)
je inkrementální open-source \acr{smt} řešič napsán v~jazyce C++,
který podporuje standardní iniciativu
\acr{smt}-LIB~\cit{opensmt}\cit{opensmt-art}.
Je postaven
nad~\acr{sat} řešičem Mini\acr{sat}2.
Nástroj byl implementován
s~důrazem na~snadnou rozšiřitelnost o~nové \set{T}-řešiče,
současně však zůstává efektivní%
\footnote{V~letech 2008 a 2009
byl oceněn v~soutěži
\name{\acr{smt}-COMP}~\cit{smtcomp}\cit{smtcomp-art}
jako nejrychlejší open-source \acr{smt} řešič
ve~čtyřech logikách ze~\acr{smt}-LIB.
V~pozdějších ročnících se už ale vysoko neumisťoval.}.
Řešič není tak rozsáhlý,
jako např. \acr{cvc}4,
a jeho nasazení může být snazší.

Open\acr{smt} používá líný přístup.
Jeho architektura je dekomponována do~tří hlavních bloků:
preprocesor a \acr{sat} a \set{T}-řešič.
\set{T}-řešiče mají standardizované rozhraní,
které slouží ke~komunikaci se \acr{sat} řešičem a také vzájemné,
je-li použita kombinace více logik, a tedy \set{T}-řešičů.
\set{T}-řešiče lze také přizpůsobovat
konkrétním problémům,
v~případě že je lze řešit efektivněji než v~obecném případě.

Řešič lze v~aplikacích používat také odděleně
jako černou skříňku,
a to buď prostřednictvím programového rozhraní (\acr{api}),
nebo zpracováním formule jako textového vstupu
(např. ve~formátu \acr{smt}-LIB).
Mně se však nepodařilo řešič v~textovém módu uspokojivě používat.

Řešič mj. podporuje logiky
\id{QF\_\-LRA}, \id{QF\_\-UFLRA} a \id{QF\_\-BV}
(podle \acr{smt}-LIB standardu).
Bohužel nepodporuje žádnou nelineární logiku.
\end{paragraph} %%Open\acr{smt}

%%%

% Mon 07 May 2018 12:14:32 AM CEST
\begin{paragraph}{z3}\label{p:search:smt:solver:z3}
je důkazní nástroj pocházející od~Microsoft\reg Research,
nicméně má otevřené zdrojové kódy
a je publikován pod~licencí \acr{mit}~\cit{z3-art}\cit{z3}.
Je napsán převážně v~jazyce C++
a podporuje většinu rozšířených \acr{os}.
V~Microsoftu se používá
pro~účely softwarové analýzy a verifikace
a generování testů.

Nástroj přijímá několik vstupních textových formátů,
mj.~vlastní formát a \acr{smt}-LIB.
Je možné jej použít také jako knihovnu
s~programových rozhraním
v~několika jazycích (C++, Java, Python, \dots).

z3 provádí poměrně důkladné předzpracování vstupu
a podle povahy vstupu používá různé nástroje.
Ovládá oba přístupy k~řešení
\acr{smt}: pilný i~líný,
a zvolí ten, který usoudí jako vhodnější.
Např. v~teorii bit vektorů bývá mnohdy
vhodnější použít pilný přístup,
protože zakódování do~Booleovských proměnných je snadné.

Kromě komponent \set{T}-řešičů
se dále používá \acr{sat} řešič
založený na~\acr{dpll} algoritmu
a také samostatná komponenta
pro~práci s~kvantifikátory~\cit{z3-art}.
\end{paragraph} %%z3

%%%

\end{subsection} %%\acr{smt} řešiče}

%%%%%%%%%%%%%

\end{section} %%Řešení \acr{smt} problému

%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Mon 07 May 2018 06:51:07 PM CEST
\begin{section}{Numerické metody řešení \acr{ode}}\label{s:search:ode}
Tyto metody numericky \hl{aproximují} průběh \acr{ode}.
Obecně používají nějaký \name{krok},
který určuje vzdálenost mezi sousedními vypočítávanými body.
Krok může být fixní či variabilní.
Některé metody používají více kroků,
což kromě různých vzdáleností také znamená,
že hodnota bodů závisí na~více než jednom předchozím bodu.
Obecně platí, že čím menší je zvolený krok,
tím je menší odchylka od exaktního řešení,
ale současně vzrůstá výpočetní složitost.

%%%

% Mon 12 Mar 2018 10:16:43 PM CET
\begin{paragraph}{Značení.}\label{p:search:ode:sign}
$t_n$ je hodnota nezávislé proměnné $t$ v~$n$-tém kroku;
$h_n = {t_{n+1} - t_{n}}$ je vzdálenost mezi kroky v~$n$-tém kroku
($h$ pokud je délka konstantní);
${y_n \sim y(t_n)}$;
${f_n \sim f(t_n, y_n)}$.

O~metodě je volně řečeno, že je (má přesnost) \name{řádu} $p$,
pokud její odchylka aproximace od~exaktního řešení
konverguje k~${\set{O}( h^{\set{O}(p)} )}$\:%
\footnote{Jedná se o~intuitivní definici,
přesné definice řádu metody,
lokální a globální chyby a dalších termínů
nalezne čtenář např. zde~\cit{ode-nsolve-intro}.}.
\end{paragraph} %%Značení.

%%%

\bigskip

Metody řešení \acr{ode} se dělí
na~\name{explicitní} a \name{implicitní}.
Explicitní metody počítají každý bod explicitně
pouze na~základě dosud zjištěných hodnot, např.
\begin{equation}\label{eq:ode:explicit}
   y_{n+1} = y_n + h f_n
\end{equation}
kdežto implicitní získávají každý bod implicitně z~řešení rovnice,
která obsahuje i~dosud neznámé hodnoty, např.
\begin{equation}\label{eq:ode:implicit}
   y_{n+1} = y_{n} + h f_{n+1}
\end{equation}
Explicitní metody jsou časově efektivnější,
ale nehodí se pro~řešení
\name{rovnic se silným tlumením} (angl. \name{stiff})%
\footnote{Pro rovnice se silným tlumením
neexistuje přesná definice.
Jsou volně definovány
jako takové, kde je pro~explicitní metody buď nutné nastavit
velmi malou velikost kroku,
nebo je řešení nestabilní,
na rozdíl od implicitních metod,
které mohou naopak být stabilní
i~pro~jakoukoli zvolenou
velikost kroku~\cit{ode-nsolve-intro}\cit{ode-nsolve}.
Tyto rovnice často obsahují funkce s~několika
časovými škálami s~rozdílnými granularitami.},
u~kterých je výpočet \hl{nestabilní}.
Implicitní metody jsou mnohem pomalejší, ale obecně stabilnější
a právě vhodné pro~tyto těžké rovnice~\cit{ode-nsolve-intro}.
Míra nestability se odvíjí od nutnosti nastavit co nejmenší krok tak,
aby byla odchylka od~exaktního řešení přijatelná.

Základní metodou pro~řešení \acr{ode}
je \name{Eulerova metoda},
která má jak explicitní
(vztah \rfeq{ode:explicit}),
tak implicitní
(vztah \rfeq{ode:implicit})
variantu,
kde $h$ může a nemusí být konstantní.
Metoda vychází ze standardní derivační aproximace~\cit{ode-nsolve-book}:
\begin{equation}\label{eq:der:apx}
   \der{y}(t) \approx \frac{y(t+h) - y(t)}{h}
\end{equation}
neboli posunu po~tečně ke křivce funkce.
Tato metoda je poměrně nepřesná,
ale je snadno pochopitelná
a většina numerických metod z~ní vychází~\cit{ode-nsolve-intro}.

Existují dvě známé rodiny metod pro~numerické řešení \acr{ode}:
\name{lineární vícekrokové metody}
a \name{metody Runge--Kutta}.
Obě skupiny souhrnně nazývám
\name{klasickými numerickými metodami}
a jsou uvedeny v~následující podsekci.
Již existující hybridní řešiče
však používají jiné metody než tyto,
případně jejich nadstavby.
Liší se tím,
že na~rozdíl od~klasických \acr{ode} řešičů
garantují rozsah chyby aproximace, ale jsou příliš pomalé.
Jejich princip je popsán v~další podsekci.

\pic{ode-nsolve_example.pdf}{ode:nsolve:example}{0.35}
   {Ukázka numerické integrace Eulerovy funkce s~délkou kroku~1}
   {Červená čára značí exaktní řešení, modrá explicitní Eulerovu metodu,
    zelená lichoběžníkovou metodu.\\
   Zdroj: Krishnavedala (\acr{cc}0), Wikimedia Commons, \cit{ode-nsolve}.}

Na~obrázku \rfPic{ode:nsolve:example}
je znázorněn příklad numerické integrace
Eulerovy funkce. Použité metody jsou popsány v~následujících podsekcích.

%%%%%%%%%%%%%

% Mon 12 Mar 2018 10:17:05 PM CET
\begin{subsection}{Klasické numerické metody}\label{ss:search:ode:classic}
Použití těchto metod bylo hlavním cílem této práce,
neboť jsou rychlejší než metody použité ve~stávajících hybridních řešičích.

Lineární vícekrokové i~Runge--Kutta metody sdílejí několik společných rysů:
\begin{itemize}
\item řeší \acr{ivp} \acr{ode} prvního řádu,
\item průběh funkce počítají na~základě jedné a více předchozích hodnot,
\item vyskytují se v~nich jak explicitní, tak implicitní metody,
\item spadá do~nich Eulerova metoda,
\item garantují konvergenci aproximační chyby
   ve~vztahu k~velikosti kroku $h$ a k~řádu $p$~\cit{ode-nsolve-book},
   nikoliv však její přesný rozsah,
\item výstupem jsou páry ${(t_n, y_n)}$.
\end{itemize}

Obě skupiny spadají do~\name{obecných lineárních metod}
jako speciální případy~\cit{ode-nsolve-intro},
toto zobecnění ale nebude v~tomto dokumentu diskutováno.

%%%%%%%

% Mon 12 Mar 2018 10:17:15 PM CET
\begin{subsubsection}{Lineární vícekrokové metody}
\label{sss:search:ode:classic:lmm}
Jedná se o~obvyklou variantu (obecných) vícekrokových metod.
Vícekrokové metody při~výpočtech využívají hodnoty několika předchozích kroků,
které se uchovávají a mohou být použity i~vícekrát.
Lineární varianta používá \hl{lineární kombinaci}
těchto hodnot~\cit{ode-nsolve-lec}:
\begin{equation}\label{eq:ode:lmm}
   \sum_{j=0}^{k} \alpha_{j} y_{n+j} =
      h \sum_{j=0}^{k} \beta_{j} f_{n+j}
\end{equation}
kde $k$ je počet zpětně sledovaných kroků,
${\alpha_{j} \in \set{R}}$ a ${\beta_{j} \in \set{R}}$ jsou konstanty,
přičemž ${\alpha_{k} \neq 0}$ a ${\alpha_{0} \neq 0 \lor \beta_{0} \neq 0}$.
Pro~${\beta_k = 0}$ je metoda explicitní, jinak je implicitní.
Podle $k$ je konkrétní metoda nazývána jako $k$-kroková.

Funkce $f$ je vyčíslována v~pravidelně rozložených bodech
(vyskytuje se vždy ve~formě $f_n$),
což umožňuje zpětné používaní těchto hodnot
při větším počtu kroků.
Je to hlavní důvod,
proč je počet vyhodnocení $f$
obecně menší, než u~Runge--Kutta metod,
které hodnoty předchozích mezikroků nevyužívají.
Pokud je vyčíslení $f$ náročné,
pak významně závisí na~jejím počtu~---~v~těchto případech
jsou tyto metody
většinou efektivnější než metody Runge--Kutta
v~rámci požadované přesnosti.
Nevýhodou těchto metod však je,
že je nutné prvních ${k-1}$ kroků spočítat jinou metodou
(kromě počátečních podmínek nejsou známy)~\cit{ode-nsolve-book}.

Následují příklady těchto metod
podle~\cit{ode-nsolve-lec} a \cit{ode-nsolve-book}.

%%%

% Sat 24 Mar 2018 08:09:54 PM CET
\begin{paragraph}{Eulerova metoda}\label{p:search:ode:classic:lmm:euler}
(vztahy \rfeq{ode:explicit} a \rfeq{ode:implicit}).
Získáme ji dosazením ${k = 1}$, ${\alpha_{1} = 1}$, ${\alpha_{0} = -1}$
a ${\beta_{1} = 0}$, ${\beta_{0} = 1}$ pro~explicitní,
resp. ${\beta_{1} = 1}$, ${\beta_{0} = 0}$ pro~implicitní variantu,
do~\rfeq{ode:lmm}.
Jedná se o~\hl{jednokrokovou} metodu řádu ${p = 1}$.
\end{paragraph} %%Eulerova metoda

%%%

\pic{trapezoid_step.pdf}{trapezoid:step}{0.65}
   {Ilustrace kroku lichoběžníkové metody}
   {Červená křivka značí exaktní řešení.}

% Sat 24 Mar 2018 08:24:43 PM CET
\begin{paragraph}{Lichoběžníková metoda:}\label{p:search:ode:classic:lmm:trap}
\begin{equation}\label{eq:ode:lmm:trap}
   y_{n+1} - y_{n} = \frac{h}{2} \left( f_{n+1} + f_{n} \right)
\end{equation}
(${k = 1}$, ${\alpha_{1} = 1}$, ${\alpha_{0} = -1}$,
${\beta_{1} = \beta_{0} = \frac{1}{2}}$)
je \hl{implicitní} a \hl{jednokroková}
metoda řádu ${p = 2}$.
Metoda je ilustrována na~obrázku \rfPic{trapezoid:step}.
\end{paragraph} %%Lichoběžníková metoda:

%%%

% Sat 24 Mar 2018 08:27:40 PM CET
\begin{paragraph}{Adams--Bashforthovy metody}
\label{p:search:ode:classic:lmm:adamsb}
jsou tvaru ${\alpha_{k} = 1}$, ${\alpha_{k-1} = -1}$,
$\alpha_{k-2} = \dots = \alpha_{0} = \beta_k = 0$,
a ${\forall_{j \neq k} \: \beta_{j}}$ jsou zvolena jednoznačně
pomocí interpolace polynomem%
\footnote{Jedná se o~aproximaci průběhu funkce $y$ pomocí polynomu $P$
tak, aby ${y(x_i) = P(x_i)}$ pro ${x_0, \dots, x_n}$.}
stupně~$q$ funkcí $f$ v~bodech ${t_{n+k-1}, \dots, t_{n}}$ tak,
aby ${q+1 = p = k}$.
Spadá sem tedy i~explicitní Eulerova metoda
(${q = 0}$, ${k = p = 1}$, vztah \rfeq{ode:explicit}).

Příklady dalších metod:
\begin{alignat*}{99}
   &q = 1, \: k~= p = 2 &&: \  y_{n+2} - y_{n+1} &&= \:
      & \frac{h}{2}\: & ( &    &         \: \: &    &         \: \:
      &  3 & f_{n+1} \:-\: &   & f_{n} ) \\
   &q = 2, \: k~= p = 3 &&: \  y_{n+3} - y_{n+2} &&= \:
      & \frac{h}{12}  & ( &    &         \: \: & 23 & f_{n+2} \:-\:
      & 16 & f_{n+1} \:+\: & 5 & f_{n} ) \\
   &q = 3, \: k~= p = 4 &&: \  y_{n+4} - y_{n+3} &&= \:
      & \frac{h}{24}  & ( & 55 & f_{n+3} \:-\: & 59 & f_{n+2} \:+\:
      & 37 & f_{n+1} \:-\: & 9 & f_{n} )
\end{alignat*}

Jsou to efektivní \hl{explicitní} $k$-krokové metody,
často používané pro~rovnice bez~silného tlumení.
\end{paragraph} %%Adams--Bashforthovy metody

%%%

% Sat 24 Mar 2018 08:32:38 PM CET
\begin{paragraph}{Adams--Moultonovy metody}
\label{p:search:ode:classic:lmm:adamsm}
mají shodný tvar s~Adams--Bashforthovými metodami
s~těmi rozdíly, že jsou \hl{implicitní},
tj.~${\beta_k \neq 0}$,
a ${q+1 = p = k+1}$
s~výjimkou pro~${q = 0}$, kde ${k = 1}$
(implicitní Eulerova metoda, vztah \rfeq{ode:implicit}).
Spadá sem i~lichoběžníková metoda
(${q = k = 1}, {p = 2}$, vztah \rfeq{ode:lmm:trap}).

Další příklady:
\begin{alignat*}{99}
   &q = k~= 2, \: p = 3 &&: \quad y_{n+2} - y_{n+1} &&= \:
      & \frac{h}{12} & ( &   &         \: \: &  5 & f_{n+2} \:+\:
      & 8 & f_{n+1} \:-\: &   & f_{n} ) \\
   &q = k~= 3, \: p = 4 &&: \quad y_{n+3} - y_{n+2} &&= \:
      & \frac{h}{24} & ( & 9 & f_{n+3} \:+\: & 19 & f_{n+2} \:-\:
      & 5 & f_{n+1} \:+\: &   & f_{n} )
\end{alignat*}
\end{paragraph} %%Adams--Moultonovy metody

%%%

% Sat 24 Mar 2018 08:34:17 PM CET
\begin{paragraph}{\acrf{bdf}}\label{p:search:ode:classic:lmm:bdf}
jsou \hl{implicitní} $k$-krokové metody často používané
pro~rovnice se silným tlumením
pro~jejich vlastnosti stability
(ač jen pro~${k \leq 6}$).

Jejich tvar je
${\beta_{k-1} = \dots} = {\beta_{0} = 0}$,
ostatní koeficienty ($\beta_{k}$ a ${\forall \alpha_{j}}$)
jsou zvoleny tak, aby ${q = p = k}$
(opět pomocí interpolace,
tentokrát ale pro~funkce $y$).
Spadá sem opět implicitní Eulerova metoda
(${q = k = p = 1}$~%
\footnote{Pro~vztah \rfeq{ode:implicit}
jakožto Adams--Moultonovy metody platilo ${q = 0}$,
tentokrát se však jedná o~polynom na~levé straně rovnosti \rfeq{ode:lmm},
tedy ${q = 1}$.}).

Příklady:
\begin{alignat*}{99}
   &q = k~= p = 2&&: \quad &    &               &  3 & y_{n+2} \:-\:
      & 4 & y_{n+1} \:+\: &   & y_{n} &&= \: & 2 & h f_{n+2} \\
   &q = k~= p = 3&&: \quad & 11 & y_{n+3} \:-\: & 18 & y_{n+2} \:+\:
      & 9 & y_{n+1} \:-\: & 2 & y_{n} &&= \: & 6 & h f_{n+3}
\end{alignat*}
\end{paragraph} %%\acrf{bdf}}

%%%

\end{subsubsection} %%Lineární vícekrokové metody

%%%%%%%

% Sun 11 Mar 2018 03:42:25 PM CET
\begin{subsubsection}{Runge--Kutta metody}\label{sss:search:ode:classic:rk}
Tyto iterativní metody vycházejí z~aproximace
pomocí rozvoje Taylorova polynomu,
které jsou ale pomalé z~důvodu požadavku
na~výpočet derivací vyšších řádů~\cit{ode-nsolve-book}.
Runge--Kutta metody toto obchází
vícenásobným vyčíslováním funkce $f$
v~několika bodech (mezikrocích)
z~intervalu $[t_{n}, t_{n+1}]$.
Tím je dosaženo vyšších řádů přesnosti $p$.

Přesto se jedná o~metodu \hl{jednokrokovou},
kde každý krok sestává z~několika mezikroků, \name{fází}.
Jedná se o~to,
že hodnoty mezikroků jsou obecně různé
a nemohou být znovu využívány tak,
jak tomu je u~vícekrokových metod,
obecně totiž platí,
že po~každém kroku Runge--Kutta metod
jsou všechny mezikroky zapomenuty.

To může činit potíže,
pokud je vyčíslení funkce $f$ náročné,
neboť je nutné ji počítat často.
Nicméně, tyto metody
mají odlišné vlastnosti stability
od~vícekrokových metod
a jejich použití může být mnohdy výhodnější,
zejména u~rovnic se silným tlumením.
Dále tyto metody umožňují lepší průběžné řízení chyby aproximace
či adaptaci na~ni
a mohou být použity jako základ
řešičů s~garancí rozsahu chyby~\cit{ode-valid-runge_kutta-art}.

Obecná $s$-fázová Runge--Kutta metoda je definována
podle~\cit{ode-nsolve-book}\cit{ode-valid-runge_kutta-art} vztahy
\begin{equation}\label{eq:ode:rk}
\begin{split}
   y_{n+1} &= y_{n} + h \sum_{i=1}^{s} b_{i} k_{i} \\
   k_{i}   &= f \! \left( t_{n} + c_{i} h, z_{i} \right) \\
   z_{i}   &= y_{n} + h \sum_{j=1}^{S_{i}} a_{i,j} k_{j} \\
   c_{i}   &= \sum_{j=1}^{i-1} a_{i,j}
\end{split}
\end{equation}
kde ${\forall b_{i}}, c_{i}, a_{i,j}$ jsou konstanty
plně charakterizující konkrétní Runge--Kutta metodu,
uspořádané do~tzv. \name{Butcherovy tabulky}:
\begin{equation}\label{eq:ode:rk:tab}
\begin{array}{r|cccc}
   c_{1}  & a_{1,1} & a_{1,2} & \cdots & a_{1,s} \\
   c_{2}  & a_{2,1} & a_{2,2} & \cdots & a_{2,s} \\
   \vdots & \vdots  & \vdots  & \ddots & \vdots  \\
   c_{s}  & a_{s,1} & a_{s,2} & \cdots & a_{s,s} \\ \hline
          & b_{1}   & b_{2}   & \cdots & b_{s}
\end{array}
\end{equation}
Jejich hodnoty jsou hledány podle Taylorova rozvoje
a podle požadovaného řádu metody $p$.
Není znám přesný vztah pro $p$ a $s$,
ale obecně platí ${p \leq s}$.

Hodnota $S_{i}$ ve~vztahu pro $z_{i}$ rozlišuje typ metody:
\begin{itemize}
\item \hl{explicitní}: ${S_{i} \coloneqq i-1}$,
   tj. ${\forall_{i,j} \: i \leq j : \: a_{i,j} = 0}$;
   ${c_{1} = 0}$;
   ${\forall k_{i}}$ závisí pouze na ${k_{j}, \: j < i}$;
   Butcherova tabulka je v~striktně dolním trojúhelníkovém tvaru
   s~nulovou diagonálou;
   z~toho vyplývá ${z_{1} = y_{n}}, {k_{1} = f_{n}}$;
\item \hl{implicitní}: ${S_{i} \coloneqq s}$;
   ${\exists_{i,j} \: i \leq j : \: a_{i,j} \neq 0}$.
\end{itemize}

Příklady Runge--Kutta metod:

%%%

% Sat 24 Mar 2018 08:42:08 PM CET
\begin{paragraph}{Eulerova metoda}\label{sss:search:ode:classic:rk:euler}
(vztahy \rfeq{ode:explicit}
a \rfeq{ode:implicit})~---~${s = p = 1}$,
${b_{1} = 1}$ a
${c_{1} = a_{1,1} = 0}$ pro explicitní;
${c_{1} = a_{1,1} = 1}$ pro implicitní metodu:
\begin{equation*}
\begin{split}
   y_{n+1}             &= y_{n} + h k~\\
   k~&= f \! \left( t_{n} + h, y_{n} + h k~\right)
      = f \! \left( t_{n+1}, y_{n+1} \right) \\
   \Rightarrow y_{n+1} &= y_{n} + h f_{n+1}
\end{split}
\end{equation*}

Jejich Butcherovy tabulky:
\begin{equation*}
\begin{array}{r|c}
   0  &   \\ \hline
      & 1
\end{array}
\qquad
\begin{array}{r|c}
   1  & 1 \\ \hline
      & 1
\end{array}
\end{equation*}
\end{paragraph} %%Eulerova metoda

%%%

% Sat 24 Mar 2018 08:43:46 PM CET
\begin{paragraph}{Lichoběžníková metoda}
\label{sss:search:ode:classic:rk:trap}
(vztah \rfeq{ode:lmm:trap})~---~${s = p = 2}$, je implicitní.

Tabulka:
\begin{equation*}
\begin{array}{r|cc}
   0  &           0 &           0 \\
   1  & \frac{1}{2} & \frac{1}{2} \\ \hline
      & \frac{1}{2} & \frac{1}{2}
\end{array}
\end{equation*}
\end{paragraph} %%Lichoběžníková metoda

%%%

% Sat 24 Mar 2018 08:44:02 PM CET
\begin{paragraph}{Klasická Runge--Kutta metoda (RK4):}
\label{sss:search:ode:classic:rk:rk4}
\begin{equation}\label{eq:ode:rk:rk4}
\begin{split}
   y_{n+1} &= y_{n} + \frac{h}{6} ( k_1 + 2 k_2 + 2 k_3 + k_4 ) \\
   k_1     &= f_n \\
   k_2     &= f \! \left( t_n + \frac{h}{2}, y_n + \frac{h}{2} k_1 \right) \\
   k_3     &= f \! \left( t_n + \frac{h}{2}, y_n + \frac{h}{2} k_2 \right) \\
   k_4     &= f \! \left( t_n + h, y_n + h k_3 \right)
\end{split}
\end{equation}
je \hl{explicitní} metoda s~parametry ${s = p = 4}$.

Tabulka:
\begin{equation*}
\begin{array}{r|cccc}
             0  &             &             &             &             \\
   \frac{1}{2}  & \frac{1}{2} &             &             &             \\
   \frac{1}{2}  &           0 & \frac{1}{2} &             &             \\
             1  &           0 &           0 &           1 &             \\
\hline
                & \frac{1}{6} & \frac{1}{3} & \frac{1}{3} & \frac{1}{6}
\end{array}
\end{equation*}
\end{paragraph} %%Klasická Runge--Kutta metoda (RK4):

%%%

\bigskip

Existují také \hl{adaptivní} Runge--Kutta metody,
které v~každém kroku počítají odhad chyby aproximace,
podle níž se dynamicky mění délka kroku $h_n$
(např. Dormand--Prince 5).
\end{subsubsection} %%Runge--Kutta metody

%%%%%%%

% Mon 07 May 2018 11:08:36 AM CEST
\begin{subsubsection}{\acr{ode} řešiče}\label{sss:search:ode:classic:solver}
Následují řešiče, které některé z~uvedených klasických metod implementují.
Nejen z~výkonnostních důvodů jsem zkoumal pouze
řešiče napsané v~jazyce C či C++.

%%%

% Mon 07 May 2018 12:34:52 PM CEST
\begin{paragraph}{\acr{sundials}}\label{p:search:ode:classic:solver:sundials}
(\name{\acrl{sundials}}) je nástroj napsán v~jazyce
\acr{ansi} C~\cit{sundials},
který je možné používat jak v~sériových,
tak v~paralelních prostředích.
\uv{Jedná se o~soubor pokročilých nástrojů
pro~řešení rozsáhlých problémů,
které mohou být modelovány jako systémy
nelineárních algebraických rovnic,
nebo jako \acr{ivp} v~rovnicích \acr{ode}
nebo diferenciálních algebraických rovnicích
(\acr{dae}).}~\cit{sundials-art}.
Tomu odpovídají nástroje KINSOL, CV\acr{ode} a IDA.
Nás zajímají jen \acr{ode}, a tedy jen CV\acr{ode},
který byl přepsán z~Fortranu do~C,
počínaje už rokem 1993.

Nástroje operují s~uživatelsky definovatelnými
strukturami datových vektorů, nad~kterými lze rovněž
definovat potřebné operace.
Tyto struktury mají standardizované programové rozhraní.
Je možné také použít výchozí podoby datových struktur
s~definovanými operacemi nad~sdíleným (např. \acr{omp})
či distribuovaným (výchozí je \acr{mpi}) modelem paměti.
Veškerý (případný) paralelismus je obsažen
výhradně v~rámci vektorových operací,
a tudíž není rozlišováno mezi sériovým a paralelním kódem aplikace.

CV\acr{ode} implementuje lineární vícekrokové metody.
Pro~úlohy bez~silného tlumení používá
Adams--Moultonovy metody,
pro~úlohy se~silným tlumením pak \acr{bdf}.
Tzn. že používá výhradně implicitní metody,
tj.~pomalejší, ale přesnější než explicitní.
\end{paragraph} %%\acr{sundials}

%%%

% Mon 07 May 2018 12:34:47 PM CEST
\begin{paragraph}{odeint}\label{p:search:ode:classic:solver:odeint}
je flexibilní C++ knihovna
pro~numerické řešení \acr{ode}~\cit{odeint}.
Je navržena v~duchu šablonového meta-programování
(\name{\acr{tmp}})~---~veškeré její numerické algoritmy
jsou nezávislé na~použitých datových kontejnerech
a jejich vzájemných operacích~\cit{odeint-art}.
Lze tak např. pracovat i~s~maticemi,
či s~poli umístěnými v~\acr{gpu}.
Operace lze např. předefinovat na~\acr{simd}
operace (např. s~použitím \acr{omp}).
Nasazení řešiče je díky flexibilitě rychlé a snadné.

\acr{tmp} je specifické tím,
že programové rozhraní není definováno
ve~zdrojových kódech,
ale používají se jen koncepty popsané v~dokumentaci,
při~jejichž dodržení se generuje kód
přímo adaptovaný na~konkrétní datové typy.
Jedná se o~tzv. \name{statický polymorfismus}~\cit{odeint-art}.

Knihovna je součástí rodiny C++ knihoven \name{Boost}~\cit{boost-libs}.
Obsahuje pouze hlavičkové soubory,
což prodlužuje délku překladu,
ale umožňuje efektivnější statickou optimalizaci.

Řešič se zaměřuje zejména na~explicitní Runge--Kutta metody
(např. RK4 a Dormand--Prince 5),
lze však implementovat i~jiné, např. vícekrokové.
Integrace je prováděna po~krocích formou in-place,
dle předloženého konceptu;
výchozí variantou je projití všech kroků
až do~koncové hodnoty nezávislé proměnné.
Lze také průběžně ukládat odhad chyby,
který je nutný pro~adaptivní metody.
\end{paragraph} %%odeint

%%%

\end{subsubsection} %%\acr{ode} řešiče

%%%%%%%

\end{subsection} %%Klasické numerické metody

%%%%%%%%%%%%%

% Mon 07 May 2018 01:14:58 PM CEST
\begin{subsection}{Garantovaná řešení}\label{ss:search:ode:valid}
Tato řešení využívají \name{intervalovou aritmetiku}%
\footnote{Nejsou nám známy metody s~garantovaným rozsahem aproximační chyby
založená na~jiném principu, než je intervalová aritmetika.},
což umožňuje jednak specifikovat počáteční podmínky
s~nějakou nejistotou jakožto intervalový rozsah
(pak problém nazývám jako \name{Interval}~\acr{ivp},
\name{I\acr{ivp}}%
\footnote{Některé zdroje tento problém formulují
jako \acr{ivp} s~tím, že počáteční podmínky
jsou nějakými množinami, včetně intervalů.
Já budu \acr{ivp} v~našem pojetí a I\acr{ivp}
striktně rozlišovat.}~\cit{ode-valid-runge_kutta-art}),
druhak obalení úseků výsledku do~intervalových uzávěrů,
tzn.~že meze odchylky aproximace od~exaktního řešení
jsou přesně známy.
Taková řešení se nazývají jako \name{garantovaná}
(angl. \name{guaranteed}
nebo \name{validated})~\cit{ode-valid-runge_kutta-art}.
Garance rozsahu řešení je klíčovým rozdílem
těchto metod
od klasických řešičů \acr{ode}
ze~sekce \rf{ss:search:ode:classic}.

%%%

% Wed 14 Mar 2018 09:20:11 PM CET
\begin{paragraph}{Značení.}\label{p:search:ode:valid:sign}
${[t_n]}$ je interval ${[t_{n}, t_{n+1}]}$ délky $h_n$;
${[y_n]}$ je uzávěr ${[y^{min}_{n}, y^{max}_{n}}]$ v~bodě $t_n$
(tj.~garantované meze řešení v~$t_n$);
${[\pred{y}_n]}$ je uzávěr ${[\pred{y}^{min}_{n}, \pred{y}^{max}_{n}}]$
pro~celé ${[t_n]}$.
\end{paragraph} %%Značení.

%%%

\bigskip

\pic{validated_ode_example.pdf}{validated:ode:example}{0.6}
   {Ukázka podoby kroku garantovaného řešení \acr{ode}
    s~intervalovými uzávěry}
   {}

Celý výpočet je rozdělen do~kroků v~bodech $t_n$.
Přibližná grafická podoba kroku je znázorněna
na~obrázku \rfPic{validated:ode:example}.
Je-li metoda jednokroková,
je její průběh následující~\cit{ode-valid-runge_kutta-art}:
\begin{enumerate}
\item v~každém kroku se operuje nad~intervalem ${[t_{n}]}$,
\item nejprve je hledán volnější uzávěr ${[\pred{y}_n]}$,
\item ${\forall t \in [t_n]}$ je garantována existence
   ${\forall y_n \in [y_n]}$, přičemž
   ${[y_n] \subseteq [\pred{y}_n]}$,
\item délka $h_n$ je největší možná v~souladu s~garantovaným řešením,
\item výpočet ${[y_{n+1}]}$.
\end{enumerate}
Výstupem jsou trojice ${(t_n, [y_n], [\pred{y}_n])}$
obsahující uzávěry (namísto diskrétních hodnot).

Tyto metody používají interní \acr{ode} řešiče
stávajících hybridních řešičů,
které jsou uvedeny v~následující sekci.
\end{subsection} %%Garantovaná řešení

%%%%%%%%%%%%%

\end{section} %%Numerické metody řešení \acr{ode}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Sat 24 Mar 2018 10:30:12 AM CET
\begin{section}{Hybridní řešiče}\label{s:search:hybrid}
Řešiče, které umí analyzovat modely hybridních systémů,
již existují,
nicméně nezachází dobře s~praktickými úlohami z~reálného světa.
A~to proto, že používají řešiče pro~\acr{ode}
s~intervalovou aritmetikou,
která je zbytečně přesná a ve~výsledku pomalá,
neboť je exaktní ve~smyslu zaručení rozsahu chyby aproximace
(viz.~sekce \rf{ss:search:ode:valid}).

Našim cílem bylo sestrojit řešič,
který nemusí být tolik přesný,
ale dokáže analyzovat
modely i~rozsáhlých systémů
v~únosně krátké době,
a tím by byl použitelný i~v~praxi,
použitím klasických numerických metod
(viz.~sekce \rf{ss:search:ode:classic}).

Zkoumané hybridní řešiče nám však posloužily
jako zdroj cenných informací
pramenících z~kombinování \acr{sat} s~\acr{ode}
a také nás inspirovaly v~návrhu vstupního jazyka.
S~řešičem dReal budou také srovnány výsledky našeho produktu.

Uvedené hybridní řešiče
se zaměřují zejména na~analýzu hybridních systémů
formou \acr{bmc}~\cit{hydlogic-art}\cit{dreal-smo-art}.

%%%

% Mon 07 May 2018 03:08:57 PM CEST
\begin{paragraph}{i\acr{sat}-\acr{ode}}\label{p:search:hybrid:isat-ode}
\uv{kombinuje \name{i\acr{sat}},
který řeší rozsáhlé Boolovské kombinace aritmetických omezení,
s~rovnicemi \acr{ode}}~\cit{isat-ode}\cit{isat-ode-art}.

K~řešení \acr{ode} používá interní nástroj
\name{VN\acr{ode}-LP}~\cit{vnode-lp},
který se nejprve pokouší dokázat,
že existuje jediné řešení problému,
a poté hledá meze, do~kterých toto řešení spadá.

Podobně jako v~našem případě kombinuje oba nástroje odděleně,
tj. oba jsou samostatně použitelné na~svou podmnožinu úloh.

Projekt nezveřejnil zdrojové kódy,
přístupný je jen dynamicky linkovaný binární soubor
s~externími závislostmi
a je stále ve~stádiu vývoje.
Tento soubor se mi nepodařilo spustit.
\end{paragraph} %%i\acr{sat}-\acr{ode}

%%%

% Mon 07 May 2018 03:08:57 PM CEST
\begin{paragraph}{hydlogic}\label{p:search:hybrid:hydlogic}
byl vyvinut zejména z~důvodu podpory
nelineárních hybridních systémů,
se~kterými autoři uvádí,
že měly tehdejší nástroje
(včetně i\acr{sat}-\acr{ode})
potíže~\cit{hydlogic-art}.

Interní inkrementální \acr{smt} řešič používá líný přístup
(viz.~sekce \rf{s:search:smt}),
přičemž \set{T}-řešič implementuje
mj.~veškerou spojitou část výpočtu,
tj.~včetně integrace.
Jako jedna z~komponent
je využíván \acr{ode} řešič VN\acr{ode}-LP~\cit{vnode-lp}.

Software tohoto nástroje jsem netestoval.
\end{paragraph} %%hydlogic

%%%

% Mon 07 May 2018 03:35:26 PM CEST
\begin{paragraph}{dReal}\label{p:search:hybrid:dreal}
je open-source nástroj napsán v~jazyce C++, který rozhoduje,
zda je vstupní formule nesplnitelná (\id{unsat}),
nebo $\delta$-splnitelná
(\id{$\delta$-sat})~\cit{dreal-art}\cit{dreal-smo-art}\cit{dreal}.
Nesplnitelnost je rozhodnuta exaktně a volitelně doložena důkazem;
$\delta$-splnitelnost je numericky aproximována
(resp. exaktně rozhodnuta na~zjednodušené formuli)
s~nejistotou $\delta$ (racionální číslo).

Diskutuji jen 3.~verzi nástroje,
ve~vývoji je však již i~4.~verze.

dReal je postaven nad~některými existujícími nástroji,
zejména Open\acr{smt}2~\cit{opensmt} a Mini\acr{sat}~\cit{minisat}
a na~straně diferenciálních rovnic pak CAPD
(viz.~\cit{dreal-smo-art}\cit{dreal-smt-format-art}),
který počítá intervalové uzávěry \acr{ode}.
dReal zpracovává nelineární logiky
reálných čísel, zejména nad~polynomy,
trigonometrickými či exponenciálními funkcemi,
rozšířené o~\acr{ode}.

Propojení nástrojů je v~implementaci řešeno interně.
Základ tvoří lineární \set{T}-řešič v~Open\acr{smt},
který je doplněn o~nelineární logiku a \acr{ode}.
Konkrétně rozšiřuje logiku \id{QF\_\-LRA}
na~\id{QF\_\-NRA} (podle \acr{smt}-LIB standardu) a ještě
o~diferenciální rovnice, nazvanou \id{QF\_\-NRA\_\-\acr{ode}}.
Z~hlediska jazyka spočívá rozšíření v~přidání několika málo příkazů
pro~definice \acr{ode}, nastavení invariant,
propojení diskrétních stavů s~\acr{ode} apod.
Nad tímto vstupem operuje řešič přímo
a \acr{ode} část je součástí \set{T}-řešiče.
Tento vstupní jazyk~\cit{dreal-smt-format-art}
byl hlavním zdrojem naší inspirace
při~návrhu vlastního vstupního jazyka.

Program také používá vlastní specifikační jazyk,
ze~kterého se generují nástrojem dReach \acr{smt} formule
pro~účely \acr{bmc} se~zvoleným počtem kroků.
Tento předstupeň je lépe lidsky čitelný
a navíc brání chybám
vzniklým z~ručního vytváření rozsáhlých \acr{smt} formulí.

Nástroj také explicitně umožňuje efektivnější
kódování paralelní kompozice více systémů
pomocí nových příkazů ve~vstupním jazyce.

dReal poskytuje některé přídavné heuristiky výpočtu
(např. \acr{bmc}), které jsem ale nezkoumal.

V~projektu je zahrnuto několik výkonnostních úloh
ve~vstupních jazycích dReal
(jako \acr{bmc} specifikace i~\acr{smt} formule).
Některé úlohy jsem později použil pro~srovnání s~naším konceptem.
Některé složitější úlohy (viz.~např. \cit{dreal-smo-art})
se počítají velmi dlouho, v~řádu hodin a výše.

Za~zmínku stojí, že dReal (jeho původní verze)
pochází z~disertační práce
na~Carnegie Mellon University
pod~vedením Edmund M. Clarka,
který je nositelem Turingovy ceny
v~roce 2007.
\end{paragraph} %%dReal

%%%

\end{section} %%Hybridní řešiče

%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Mon 16 Apr 2018 09:11:53 PM CEST
\chapter{Návrh zvoleného řešení}\label{ch:design}
V~této kapitole rozebírám teoretický návrh řešení problému
zvolený před~vlastní implementací.
Zatím neuvádím implementační detaily
a konkrétní používané nástroje a programovací jazyky.
Nejprve popíši specifikaci celého nástroje
a jeho vstupy (vstupní jazyk,
v~němž budou přijímány textové vstupy)
a výstupy.
Následně uvedu softwarový model celého řešiče.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Sat 28 Apr 2018 10:53:16 PM CEST
\begin{section}{Specifikace nástroje}\label{s:design:spec}
Nástroj má fungovat jako řešič kombinace
dvou problémů: problému \acr{smt}
podle přístupů diskutovaných v~sekci \rf{s:search:smt},
a problému numerického řešení diferenciálních rovnic
s~použitím klasických numerických metod,
jak bylo diskutováno v~sekci \rf{ss:search:ode:classic}.
Tvar počátečních podmínek není omezen,
avšak není-li množina podmínek konečná
(tj.~např. intervaly),
doba výpočtu není definována a zpravidla neterminuje.
Intervaly však lze aproximovat výčtem hodnot z~intervalu.

Nástroj má sloužit jako \hl{prototyp}
odlišného přístupu ke~zkoumání hybridních modelů systémů
než~dosavadní řešiče
uvedené v~sekci \rf{s:search:hybrid}.
Hlavním účelem práce je \hl{srovnání}
s~některým stávajícím řešičem
z~hlediska efektivity
i~jiných vlastností.
Neformálním požadavkem pak je,
aby pro~alespoň některou podmnožinu
úloh, s~nižšími požadavky na~přesnost, byl náš prototyp
rychlejší než~stávající řešiče,
a to i~přesto, že by nebyl příliš optimalizován,
jelikož náš přístup
klade menší požadavky na~přesnost
a měl by být výpočetně výrazně méně náročný.

Nástroj bude přijímat jako vstup textový soubor
spadající do~námi specifikovaného vstupního jazyka.
Výstupem bude zejména příznak úspěchu
a volitelně také nějaká forma výsledných dat.
Vstupy a výstupy jsou podrobněji popsány ve~vlastních podsekcích.

Jedním z~případů užití nástroje je \acr{bmc}
(viz.~sekce \rf{p:theory:formulation:sat:bmc}),
u~kterého se velikost vstupu a délka výpočtu
odvíjí od~zvoleného počtu kroků ověřování modelu.
Kroky jsou v~tomto případě odděleny
skoky~---~změnami diskrétního stavu
systému~---~ke~kterým dochází při~porušení
nějakého \name{invariantu} vázaného k~aktuálnímu stavu.
Jedná se o~systém \name{řízený událostmi}
(angl. \name{event trigerred}).
Nemusí tedy být předem zřejmé,
ve~kterých časových okamžicích bude docházet k~integraci
a ve~kterém výpočet skončí.
Tento způsob používá např. nástroj dReal
(viz.~sekce \rf{p:search:hybrid:dreal}).

Náš řešič ale s~takovými kroky nepracuje
(alespoň ne v~této verzi),
nýbrž pracuje s~předem specifikovanými časovými okamžiky,
mezi kterými dochází k~integraci po~předem danou dobu,
a poté se mění stav systému závisle na~výstupech integrace
pomocí ověření splnitelnosti \acr{smt} řešičem.
Jedná se tedy o~systém \name{řízený časem}
(angl. \name{time trigerred})%
\footnote{V~našem případě však (pochopitelně) odpadá
výhoda systémů řízených časem oproti těm řízených událostmi,
že je porucha detekována na~straně přijímače,
jelikož zde pracujeme s~\uv{bezporuchovým} řešičem.}.
Tyto úseky výpočtu budu označovat jako \name{fáze}.
Náš řešič kriticky závisí na~zvoleném rozložení fází,
jak z~hlediska přesnosti, tak z~hlediska délky výpočtu.
Pokud změny stavů modelu závisí na~invariantech
integrovaných funkcí,
je nutné zvolit délku fází co nejnižší,
aby bylo porušení invariant detekováno co nejdříve.
Invarianty totiž nejsou kontrolovány v~průběhu integrace.
V~opačném případě, nebo pokud není porušení invariant kritické,
postačují vyšší délky fází,
čímž se urychluje výpočet.

Nástroj není koncipován jako konečný produkt,
není příliš uživatelsky přivětivý
a může obsahovat řadu chyb.
Nástroj má sloužit pro~účely experimentování
s~navrženým způsobem řešení úloh,
a dále buď jako zdroj inspirace
pro~vývojáře průmyslového nástroje,
anebo přímo jako postupně se vyvíjející projekt
na~bázi stávajících otevřených zdrojových kódů.

%%%%%%%%%%%%%

% Tue 24 Apr 2018 12:23:10 PM CEST
\begin{subsection}{Vstupní jazyk}\label{ss:design:spec:ilang}
Vstupním jazykem je záhodno postihnout
použití \acr{smt} formulí
a současně umožnit definovat \acr{ode}
a propojit je s~diskrétními \acr{smt} stavy.
Vycházel jsem z~jazyka \acr{smt}-LIB
(viz.~sekce \rf{ss:search:smt:smtlib})
a ze~vstupního jazyka nástroje dReal
(viz.~sekce \rf{p:search:hybrid:dreal}).
Použité názvosloví vychází z~\acr{smt}-LIB.

Ač je náš vstupní jazyk podobný na~ty referované,
není s~nimi kompatibilní,
zejména \hl{není konformní} se~standardem \acr{smt}-LIB,
který je relativně robustní,
umožňuje nastavovat parametry pro~řešič,
podporuje inkrementální operace, apod.
Také definuje výstupní jazyk.
Náš řešič sice interně tento jazyk hojně využívá,
ale svůj vstup omezuje jen na~některé části.
Vstupní specifikace modelů musí
spadat do~některé \hl{teorie reálných čísel}
(konkrétní logiky jsou uvedeny dále).
Tyto logiky jsou pochopitelně rozšířeny o~\acr{ode}.
Nad těmito vstupy lze provést pouze neinkrementální ověření splnitelnosti.
Většina zodpovědnosti pojená se~vstupní specifikací
\acr{smt} části vstupu je přímo delegována
na~\acr{smt} řešič, včetně kontroly validity vstupu.

Jazyk používá plně uzávorkovanou prefixovou notaci%
\footnote{Tato syntaxe je známa zejména z~jazyka \name{Lisp}.}.
Podmnožina příkazů týkající se~jen specifikace \acr{smt} formulí
je převzata z~\acr{smt}-LIB
a k~nim jsou ortogonálně doplněny
příkazy týkající se nadstavby o~\acr{ode}.
Obě skupiny jsou popsány ve~zvláštních podsekcích.

Vstupní jazyky jsou obecně definovány tak,
aby byly pokud možno nezávislé na~konkrétně použitých řešičích.

%%%

% Tue 20 Mar 2018 11:39:27 PM CET
\begin{paragraph}{Značení.}\label{ss:design:spec:ilang:sign}
Znaky \id{<>} nejsou součástí syntaxe a ohraničují či seskupují argumenty
(nejsou-li již nějak ohraničeny);
\id{*} značí, že dotčený řetězec
se může opakovat vícekrát nebo být prázdný;
\id{+} je jako \id{*}, ale zakazuje prázdný řetězec;
\id{|} značí více možností pro~jednu pozici argumentu.
\end{paragraph} %%Značení.

%%%

%%%%%%%

% Mon 23 Apr 2018 11:40:51 PM CEST
\begin{subsubsection}{Syntaxe jazyka}\label{sss:design:spec:ilang:syntax}
Vstupní jazyk je sekvence \name{tokenů}, \name{výrazů},
bílých znaků a komentářů.
U~znaků abecedy se rozlišuje velikost písmen.

%%%

% Tue 20 Mar 2018 11:39:45 PM CET
\begin{paragraph}{Bílé znaky.}\label{p:design:spec:ilang:struct:ws}
Povolenými bílými znaky jsou:
\begin{center}
\begin{tabular}{r|ccc}
   Název       & mezera & tabulátor & nová řádka \\ \hline
   \acr{ascii} &   $32$ &       $9$ &  $(13+{})10$ \\
\end{tabular}
\end{center}

S~výjimkou oddělení dvojic tokenů jsou bílé znaky ignorovány.
\end{paragraph} %%Bílé znaky.

%%%

% Tue 20 Mar 2018 11:39:53 PM CET
\begin{paragraph}{Komentář.}\label{p:design:spec:ilang:struct:cmt}
Jako komentář je interpretován každý úsek řádku
začínající znakem \hll{\id{;}} až po~konec řádku.
Jejich obsah je ignorován.
\end{paragraph} %%Komentář.

%%%

% Mon 23 Apr 2018 11:42:51 PM CEST
\begin{paragraph}{Token}\label{p:design:spec:ilang:struct:token}
je sekvence znaků závisle na~typu tokenu,
vždy však bez~bílých znaků, které slouží jako jejich oddělovače.
Tokeny se dělí na~\name{identifikátory} a \name{literály}.

\hll{Identifikátory} sestávají z~alfanumerických znaků a znaků
\begin{center}
\id{+ \  - \  * \  / \  \^{} \  = \  < \  > \  \_ \  . \  ?}
\end{center}
Musí být předem deklarovány, definovány nebo rezervovány
a nesmí začínat číslicí%
\footnote{Vzhledem k~jen minimálním restrikcím na~název identifikátoru
je vhodné, aby se uživatel vyvaroval zavádějících názvů,
např. obsahujících symboly operátorů
(\id{a<b} apod.),
a aby důsledně odděloval tokeny bílými znaky
nebo do~výrazů.}.
Reprezentují buď \name{příkazy}
(pak se vždy jedná o~rezervovaný token;
jsou interpretovány výhradně interně v~řešiči),
nebo \name{funkce},
které mohou být i~uživatelsky definované,
či \name{druh} prvků, výrazů apod. (angl. \name{sort}).
Speciálním případem funkce je \name{konstanta},
která nemá žádné argumenty.
Pojem proměnných se nepoužívá,
neboť hodnotám identifikátorů nelze dynamicky přiřazovat nové hodnoty,
stejně jako v~\acr{smt}-LIB.

\hll{Literály} jsou bezejmenné konstanty
nějakého druhu.
Numerické obsahují číslice a případně desetinnou tečku (\id{\hll{.}})
nebo záporné znaménko (\id{-})%
\footnote{Záporné literály v~\acr{smt}-LIB povoleny nejsou,
proto je nutné provést transformaci na~výraz
s~unární funkcí \id{-} a kladným literálem.};
na~začátku nejsou povoleny přídavné \id{0} a kladné znaménko;
desetinná čísla musí obsahovat číslici před i~po~desetinné tečce;
není podporován semilogaritmický tvar.
Booleovské literály jsou \id{true} a \id{false}.
\end{paragraph} %%Token

%%%

% Fri 27 Apr 2018 01:17:21 AM CEST
\begin{paragraph}{Výraz}\label{p:design:spec:ilang:struct:expr}
je vždy uzavřen v~závorkách:
\begin{center}
\id{( <{}<token> | <expr>{}>* )}
\end{center}
kde \id{<expr>} je vnořený výraz
a \id{<token>} token.
Pokud je výraz umístěn v~kořenové úrovni vstupu,
pak se musí jednat o~příkaz.
V~příkazu musí být prvním elementem výrazu
token s~názvem příkazu.
Obecné výrazy toto omezení nemají,
ale pokud se jedná o~funkci,
platí pro ni~totéž co pro~příkazy.
Příkazy nemusí mít druh návratové hodnoty,
funkce ano.

(Bílé znaky a komentáře nejsou v~sekvenci zahrnuty;
při~vyhodnocení je jejich obsah ignorován.)
\end{paragraph} %%Výraz

%%%

\end{subsubsection} %%Syntaxe jazyka

%%%%%%%

% Tue 24 Apr 2018 12:25:17 PM CEST
\begin{subsubsection}{\acr{smt} konstrukty}\label{sss:design:spec:ilang:smt}
Je použita pouze podmnožina konstruktů
týkajících se povolených teorií reálných čísel.
Jedná se o~druhy výrazů
a o~rezervované příkazy a funkce.

%%%

% Tue 20 Mar 2018 11:40:10 PM CET
\begin{paragraph}{Druhy prvků:}\label{p:design:spec:ilang:smt:sorts}
\begin{itemize}
\item \id{Bool}~---~logický typ,
\item \id{Real}~---~typ reálných čísel.
\end{itemize}
Celočíselný druh není akceptován;
pro~diskrétní konstanty je nutno využít výhradně druh \id{Bool},
typicky pro~diskrétní stav systému, který je konečný.
\end{paragraph} %%Druhy prvků:

%%%

% Fri 27 Apr 2018 01:58:57 AM CEST
\begin{paragraph}{Rezervované funkce.}\label{p:design:spec:ilang:smt:reserved}
Zahrnuty jsou následující funkce (resp. operátory)
se~standardní sémantikou:
\begin{itemize}
\item Unární:  \quad \id{not}
\item Binární: \quad \id{/}
\item $n$-ární:
   \begin{itemize}
   \item levá asociativita:
      \begin{itemize}
      \item ${n \geq 1}$: \quad \id{- \ and \  or}
      \item ${n \geq 2}$: \quad \id{+ \  *}
      \end{itemize}
   \item pravá asociativita, ${n \geq 2}$: \quad \id{=>}
   \item se~zřetězením, ${n \geq 2}$:  \quad \id{= \  < \  > \  <= \  >=}
   \end{itemize}
\end{itemize}
a dále tyto funkce:
\begin{itemize}
\item \id{distinct}~---~$n$-ární funkce s~${n \geq 2}$,
   která vrací nerovnost všech dvojic prvků,
\item \id{ite}~---~ternární funkce s~prvním argumentem druhu \id{Bool},
   který když je pravdivý,
   vrací se druhý argument, jinak třetí argument.
\end{itemize}
\end{paragraph} %%Rezervované funkce.

%%%

% Mon 07 May 2018 04:35:22 PM CEST
\begin{paragraph}{\id{set-logic}}\label{p:design:spec:ilang:smt:logic}
nastavuje logiku použitou v~\acr{smt} řešiči:
\begin{center}
\id{(set-logic <logic\_\-name>)}
\end{center}
kde \id{<logic\_\-name>} je jedna z~následujících logik
teorií reálných čísel s~volnými funkčními symboly,
podle \acr{smt}-LIB:
\begin{itemize}
\item \id{QF\_\-UFLRA}~---~lineární bez~kvantifikátorů,
\item \id{QF\_\-UFNRA}~---~nelineární bez~kvantifikátorů,
\item \id{UFLRA}~---~lineární s~kvantifikátory.
\end{itemize}
Použití kvantifikátorů jsme však dosud nezkoumali.

Příkaz smí být volán nejvýše jednou
a musí předcházet všem ostatním uvedeným příkazům.
Není-li příkaz uveden, je jako výchozí logika zvolena \id{QF\_\-UFLRA}.

Pokud to implementace umožňuje,
smí být také podporovány zmíněné logiky
bez~volných funkčních symbolů (názvy jsou bez~znaků \id{UF}).
Pak je jako výchozí logika volena \id{QF\_\-LRA}.
\end{paragraph} %%\id{set-logic}

%%%

% Mon 23 Apr 2018 11:54:12 PM CEST
\begin{paragraph}{\id{declare-fun}}\label{p:design:spec:ilang:smt:declfun}
slouží k~deklaraci nové funkce (resp. konstanty)
bez její interpretace.
Je tvaru
\begin{center}
\id{(declare-fun <fun\_\-name> (<arg\_\-sort>*) <sort>)}
\end{center}
Argumenty příkazu:
\begin{itemize}
\item \id{<fun\_\-name>}~---~název identifikátoru funkce,
\item \id{<arg\_\-sort>*}~---~výčet identifikátorů druhů
   argumentů funkce (prázdné v~případě konstanty),
\item \id{<sort>}~---~identifikátor druhu návratové hodnoty.
\end{itemize}
Příklady:
\begin{center}
\id{(declare-fun y (Real) Real)}\\
\id{(declare-fun empty? () Bool)}
\end{center}

Funkce a konstanty jsou deklarovány globálně
a mohou být za~místem deklarace
libovolně používány uvnitř dalších funkcí.
\end{paragraph} %%\id{declare-fun}

%%%

% Mon 23 Apr 2018 11:57:05 PM CEST
\begin{paragraph}{\id{define-fun}}\label{p:design:spec:ilang:smt:defun}
rozšiřuje%
\footnote{Každá funkce je buď jen deklarována,
nebo definována, ne obojí.}
\id{declare\--fun} o~definici funkce:
\begin{center}
\id{(define-fun <fun\_\-name> ((<arg> <arg\_\-sort>)*) <sort> <expr>)}
\end{center}
se~shodnými argumenty kromě:
\begin{itemize}
\item \id{(<arg> <arg\_\-sort>)*}~---~výčet párů identifikátorů
   názvu argumentů funkce a jejich druhů,
\item \id{<expr>}~---~výraz nebo token definující chování funkce
   s~druhem návratové hodnoty \id{<sort>}
   a (ne nutně) obsahující jednotlivé argumenty \id{<arg>}.
\end{itemize}
Příklad:
\begin{center}
\id{(define-fun v~((s~Real) (t Real)) Real (/ s~t))}
\end{center}
\end{paragraph} %%\id{define-fun}

%%%

% Tue 20 Mar 2018 11:40:25 PM CET
\begin{paragraph}{\id{assert}}\label{p:design:spec:ilang:smt:assert}
zavádí formule modelu, které musejí být splněny:
\begin{center}
\id{(assert <expr>)}
\end{center}
kde \id{<expr>} je výraz nebo token s~druhem návratové hodnoty \id{Bool}.
Příklad:
\begin{center}
\id{(assert (or (= mode a) (= mode b) ))}
\end{center}
\end{paragraph} %%\id{assert}

%%%

\end{subsubsection} %%\acr{smt} konstrukty}

%%%%%%%

% Tue 24 Apr 2018 12:00:22 AM CEST
\begin{subsubsection}{Konstrukty \acr{ode}}
\label{sss:design:spec:ilang:ode}
V~kontextu \acr{ode} lze zjednodušovat
syntaxi příkazů s~následujícími pravidly:
\begin{itemize}
\item název nezávislé proměnné v~\acr{ode} je vždy \id{t},
\item druhy funkcí i~jejich derivací a nezávislé proměnné je \id{Real}.
\end{itemize}
Tyto skutečnosti nebudou nadále zmiňovány.

Vstup může obsahovat vícero závislých či nezávislých
diferenciálních rovnic, označovaných jako \id{ode}.
Každá \id{ode} dále sestává z~jedné či více variant derivací,
z~nichž v~každé fázi je pro~každou \id{ode} platná právě jedna varianta.
Varianty derivací budou označovány jako \id{dt}.
\id{dt} umožňují volit různé předpisy pro~derivace neznámých funkcí
závisle na~aktuálním stavu celého systému.

%%%

% Sat 07 Apr 2018 07:17:16 PM CEST
\begin{paragraph}{Nové druhy prvků:}\label{p:design:spec:ilang:ode:sorts}
\begin{itemize}
\item \id{Dt}~---~druh určující zvolenou variantu derivace \id{dt}.
\end{itemize}
\end{paragraph} %%Nové druhy prvků:

%%%

% Fri 27 Apr 2018 02:09:56 AM CEST
\begin{paragraph}{Nové rezervované funkce.}
\label{p:design:spec:ilang:ode:reserved}
\acr{smt} logiky neumějí dobře zacházet s~některými
nelineárními reálnými funkcemi,
k~nimž lze využít \acr{ode} řešič
a namísto s~funkcemi pracovat s~konstantami,
jimž jsou přiřazeny výsledky integrování.
Přidány jsou následující unární funkce:
\begin{center}
\id{abs \  sqrt \  cbrt \  sin \  cos \  tan \  exp \  ln}
\end{center}
a binární funkce (resp. operátor): \quad \id{\^{}} \\
Tyto však mohou být využity pouze uvnitř příkazu \id{define\--dt}
(viz.~dále).
\end{paragraph} %%Nové rezervované funkce.

%%%

% Tue 24 Apr 2018 12:11:52 AM CEST
\begin{paragraph}{\id{define-dt}}\label{p:design:spec:ilang:ode:dt}
slouží k~definici \id{dt}, tj.~výrazu popisujícího variantu derivace funkce,
a současně k~deklaraci \id{ode} neznámé funkce
u~první zmíněné varianty \id{dt}.
Všechny \id{dt} musí v~rámci \id{ode}
sdílet stejnou signaturu (viz.~dále).

Tvar příkazu:
\begin{center}
\id{(define-dt <fun\_\-name> <dt\_\-name> (<arg>*) <expr>)}
\end{center}
s~argumenty:
\begin{itemize}
\item \id{<fun\_\-name>}~---~název \id{ode},
   tj.~identifikátoru neznámé funkce nezávislé
   proměnné \id{t} obsahující všechny varianty \id{dt},
\item \id{<dt\_\-name>}~---~název \id{dt},
   tj.~identifikátoru varianty derivace funkce \id{<fun\_\-name>},
\item \id{<arg>*}~---~identifikátory argumentů výrazu,
   které jsou druhu \id{Real} a musí být
   \hl{shodné} u~všech variant \id{dt};
   \hl{neobsahují} funkci \id{<fun\_\-name>}
   a nezávislou proměnnou \id{t},
   které jsou zahrnuty implicitně;
   mohou obsahovat i~identifikátory jiných \id{ode},
   více viz.~níže,
\item \id{<expr>}~---~výraz nebo token popisující tvar derivace funkce,
   který může obsahovat funkci \id{<fun\_\-name>}
   a nezávislou proměnnou \id{t}\:%
   \footnote{Funkce se uvádí bez~závislosti na~\id{t},
   tj.~jako konstanta.}
   a jednotlivé argumenty \id{<arg>}.
   Na~rozdíl od~\acr{smt} funkcí
   \id{<expr>} nepřijímá globální funkce a konstanty.
\end{itemize}
Příklady:
\begin{center}
\id{(define-dt x dx () 1)}\\
\id{(define-dt y dy\_\-on () (- (* (/ 3 t) y) 2))}\\
\id{(define-dt z dz\_\-a (k) (+ (/ 1 z) k))}
\end{center}

Identifikátory \id{<fun\_\-name>}
je nutné používat výhradně uvnitř \id{int\--ode} příkazů.
Identifikátory \id{<dt\_\-name>} jsou zavedeny jako konstanty druhu \id{Dt},
které lze používat uvnitř příkazů \id{assert}
pro~účely propojení konstant druhu \id{Dt} se~stavem systému.

Argumenty \id{<arg>} vstupují do~výrazu \id{<expr>}
jako konstanty druhu \id{Real} jakožto počáteční podmínky integrace
a také jako vstupní hodnoty v~každé fázi integrace.
Pokud \id{<arg>} pochází z~konstanty, její hodnota se nemění;
pokud se však jedná o~identifikátor některé \id{ode}
(pocházející z~\id{<fun\_\-name>}),
její hodnota se průběžně mění,
jelikož jsou všechna \acr{ode} integrována synchronně.
Tímto způsobem se definují soustavy více \acr{ode}%
\footnote{Pokud chcete z~nějakého důvodu
použít funkci některé \id{ode}
jako \hl{konstantní} vstup pro jinou \id{ode},
zvolte pro~tento argument \id{<arg>}
název odlišný od~\id{<fun\_\-name>};
vstupní konstanty pro~příkaz \id{int\--ode} zůstávají stejné.}, př.:
\begin{center}
\id{(define-dt x dx (y) (+ x y))}\\
\id{(define-dt y dy (x) (- x y))}
\end{center}
\end{paragraph} %%\id{define-dt}

%%%

% Fri 04 May 2018 07:54:54 PM CEST
\begin{paragraph}{\id{int-ode}}\label{p:design:spec:ilang:ode:int}
obaluje výraz integrace neznámé funkce v~konkrétní fázi
a dosazuje do~\id{ode} hodnoty či konstanty.
Návratová hodnota výrazu je druhu \id{Real} a lze jej používat
uvnitř příkazů \id{assert}.

Tento příkaz se chová jako funkce a musí být umístěn v~místě,
kde jsou funkce povoleny,
což např. není vrcholová úroveň vstupu.

Na~rozdíl od~příkazu \id{define\--dt} pracuje tento
výhradně s~identifikátory, ne s~obecnými klíči.
Slouží k~tomu, aby dosazoval do~rovnic definovaných
příkazem \id{define\--dt} konkrétní
počáteční a koncové hodnoty
a vybíral některou variantu \id{dt}.

Tvar příkazu:
\begin{center}
\id{(int-ode <fun\_\-name> <dt> (<init> <t\_\-1> <t\_\-2>) (<arg\_\-val>*))}
\end{center}
s~argumenty:
\begin{itemize}
\item \id{<fun\_\-name>}~---~název \id{ode},
   tj.~identifikátor neznámé derivované funkce
   zavedený příkazy \id{define\--dt},
\item \id{<dt>}~---~konstanta druhu \id{Dt}, která určuje
   některou z~variant derivací \id{dt} definovaných příkazy \id{define\--dt}%
   \footnote{Nejedná se o~konstanty pocházející z~příkazu \id{define\--dt},
   ale o~pomocné konstanty, které jsou ohodnoceny \acr{smt} řešičem
   na~základě asercí se~stavem modelu.},
\item \id{<init>}~---~počáteční hodnota funkce \id{<fun\_\-name>}
   v~bodě \id{<t\_\-1>},
\item \id{<t\_\-1> <t\_\-2>}~---~počáteční a koncová hodnota
   nezávislé proměnné \id{t},
\item \id{<arg\_\-val>*}~---~počáteční hodnoty argumentů druhu \id{Real}
   předané výrazu zvolené varianty derivace.
\end{itemize}
Názvy všech vstupních konstant mohou být libovolné identifikátory,
jejich struktura a návaznosti jsou zodpovědností uživatele.
Příklady:
\begin{center}
\id{(int-ode x dx\_\-0 (x\_\-0 t\_\-0 t\_\-1) ())} \\
\id{(int-ode x dx\_\-1 (x\_\-1 t\_\-1 t\_\-2) ())} \\
\id{(int-ode y dy\_\-1 (y\_\-1 t\_\-1 t\_\-2) ())} \\
\id{(int-ode y der\_\-25 (var-3 tt\_\-5 xy56) ())} \\
\id{(int-ode z dz\_\-1 (z\_\-1 t\_\-1 t\_\-2) (k))} \\
\id{(int-ode z dz\_\-2 (z\_\-1 t\_\-1 t\_\-3) (k))}
\end{center}

Je možné pro~stejnou \acr{ode}
a pro~stejný pár konstant nezávislé proměnné \id{t}
použít i~více příkazů \id{int\--ode}
s~odlišnými argumenty:
\begin{Verbatim}[samepage=true]
(int-ode x dx.0_0 (x.0_0 t_0 t_1) ())
(int-ode x dx.1_0 (x.1_0 t_0 t_1) ())
\end{Verbatim}
\end{paragraph} %%\id{int-ode}

%%%

% Sat 07 Apr 2018 07:01:24 PM CEST
\begin{paragraph}{\id{define-ode-step}}\label{p:design:spec:ilang:ode:step}
definuje (počáteční) velikost kroku
v~interním \acr{ode} řešiči:
\begin{center}
\id{(define-ode-step <h>)}
\end{center}
kde \id{<h>} je konstanta druhu \id{Real}.
\end{paragraph} %%\id{define-ode-step}

%%%

\end{subsubsection} %%Konstrukty \acr{ode}

%%%%%%%

% Fri 27 Apr 2018 12:19:36 PM CEST
\begin{subsubsection}{Struktura a použití jazyka}
\label{sss:design:spec:ilang:struct}
V~této podsekci je uveden tvar doporučené struktury vstupu,
který by validně popisoval model hybridního systému
a umožňoval jeho analýzu našim nástrojem.

Vzhledem k~tomu, že se v~jazyce nevyskytují žádné proměnné,
není možné, aby se průběh stavu systému
v~rámci jednoho ověření splnitelnosti
dynamicky měnil~---~výsledkem je vždy statické ohodnocení.
Jelikož je vstup statický,
je pro~modelování průběhu nutné použít mnoho konstant
o~předem známém počtu.

Rozložení fází je určeno obecně
podle navazujících časových mezí příkazů \id{int-ode}
(hodnoty konstant nezávislé proměnné \id{t}).

Následují jednotlivé sekce,
které by se měly objevit ve~vstupech.
Kromě těchto smí uživatel používat
i~další \acr{smt} konstrukty tohoto jazyka.

%%%

% Fri 27 Apr 2018 12:58:39 PM CEST
\begin{paragraph}{Deklarace a inicializace konstant.}
\label{p:design:spec:ilang:struct:const}
Všechny konstanty musejí být deklarovány a konstanty
počátečních podmínek
musí být i~definovány.
Každé konstantě se typicky dává jako přípona číslo fáze,
ale řešič na~to nebere žádný ohled.

Je vhodné deklarovat konstanty
nezávislé proměnné \id{t},
průběhů neznámých funkcí, diskrétních stavů
a konstant voleb variant derivací \id{dt}%
\footnote{Pozor na~konflikt identifikátorů konstant \id{dt}
s~identifikátory variant derivací
z~příkazu \id{define\--dt}.}.

Intervalové počáteční podmínky lze aproximovat
pomocí logického součtu několika rovností.

Příklad:
\begin{Verbatim}[samepage=true]
;; Literals definition
(define-fun t0   () Real 0)
(define-fun y0_0 () Real 1) (define-fun y0_1 () Real 2)
(define-fun run0 () Bool false)
;; Constants declaration
(declare-fun t_0    () Real) (declare-fun t_1    () Real)
(declare-fun y_0    () Real) (declare-fun y_1    () Real)
(declare-fun run_0  () Bool) (declare-fun run_1  () Bool)
(declare-fun dy_0   () Dt)
;; Initial conditions
(assert (and (= t_0 t0) (= run_0 run0)
             (or (= y_0 y0_0) (= y_0 y0_1))
))
\end{Verbatim}
\end{paragraph} %%Deklarace a inicializace konstant.

%%%

% Mon 16 Apr 2018 01:34:14 PM CEST
\begin{paragraph}{Definice derivací funkcí}
\label{p:design:spec:ilang:struct:ode}
se provádí pomocí příkazů \id{define\--dt}.
Příklad:
\begin{Verbatim}[samepage=true]
(define-dt y dy_run  ()    1 )
(define-dt y dy_idle () (- 1))
\end{Verbatim}

Identifikátory variant derivací \id{dt}
\hl{nesmí} kolidovat s~konstantami
volených variant v~jednotlivých fázích, př.:
\begin{Verbatim}[samepage=true]
(declare-fun dy_0   () Dt) (declare-fun dy_1   () Dt)
;; ...
(define-dt y dy_1   () 1)  ;; conflict !!
\end{Verbatim}
\end{paragraph} %%Definice derivací funkcí

%%%

% Fri 27 Apr 2018 02:17:14 AM CEST
\begin{paragraph}{Invarianty}
\label{p:design:spec:ilang:struct:inv}
znamenají zavedení podmínek,
které musí být splněny \hl{mezi} všemi fázemi,
ale mohou být porušeny v~průběhu integrace.
Mohou a nemusí být závislé na~aktuálním stavu systému.
Pro~stanovení podmínek pro~konstanty závisle
na~konkrétním diskrétním stavu systému
doporučujeme použít až část definice skoků uvedenou dále.

Pokud to implementace \hl{explicitně} sama neprovádí,
je nutné omezit všechny konstanty jednotlivých fází druhu \id{Dt}
pouze na~výčet možných variant derivací z~příkazů \id{define\--dt}.

Doporučujeme zkonstruovat pomocnou funkci \id{invariant}, př.:
\begin{Verbatim}[samepage=true]
(define-fun invariant ((dy Dt) (y Real)) Bool
    (and (or (= dy dy_run) (= dy dy_idle))
         (<= y ymax)
))
\end{Verbatim}

Příklad s~použitím funkce \id{invariant}:
\begin{Verbatim}[samepage=true]
(assert (and (invariant dy_0 y_0)
             (invariant dy_1 y_1)
))
\end{Verbatim}
\end{paragraph} %%Invarianty

%%%

% Sat 07 Apr 2018 08:05:17 PM CEST
\begin{paragraph}{Nastavení voleb variant derivací}
\label{p:design:spec:ilang:struct:connect}
se provádí pomocí příkazu \id{assert},
ve~kterém se kombinuje libovolný stav systému
a konstanty druhu \id{Dt}.
Tím dochází k~propojení diskrétní a spojité domény modelu.

Doporučujeme zkonstruovat pomocnou funkci \id{connect}, př.:
\begin{Verbatim}[samepage=true]
(define-fun connect ((dy Dt) (run Bool)) Bool
    (and (=>      run  (= dy dy_run ))
         (=> (not run) (= dy dy_idle))
))
\end{Verbatim}

Příklad s~použitím funkce \id{connect}:
\begin{Verbatim}[samepage=true]
(assert (and (connect dy_0 run_0)
             (connect dy_1 run_1)
))
\end{Verbatim}
\end{paragraph} %%Nastavení voleb variant derivací

%%%

% Fri 27 Apr 2018 01:38:44 PM CEST
\begin{paragraph}{Definice skoků.}\label{p:design:spec:ilang:struct:jump}
Skoky, tj.~změny diskrétního stavu,
lze definovat též pomocí asercí
mezi sousedními stavy a dalšími konstantami.

Doporučujeme zkonstruovat pomocnou funkci \id{jump}, př.:
\begin{Verbatim}[samepage=true]
(define-fun jump ((run1 Bool) (run2 Bool) (y2 Real)) Bool
    (and (=> (and      run1  (<  y2 bound_1) )      run2  )
         (=> (and      run1  (>= y2 bound_1) ) (not run2) )
         (=> (and (not run1) (>  y2 bound_2) ) (not run2) )
         (=> (and (not run1) (<= y2 bound_2) )      run2  )
))
\end{Verbatim}

Příklad s~použitím funkce \id{jump}:
\begin{Verbatim}[samepage=true]
(assert (and (jump run_0 run_1 y_1)
             (jump run_1 run_2 y_2)
))
\end{Verbatim}

Pokud je požadavek na~libovolnou změnu
spojitého stavu modelu při~některém skoku
(např. reset časovače),
je nutné tyto konstanty v~jednotlivých fázích zdvojit,
kde první značí např. hodnotu na~začátku fáze
a druhá na~konci fáze.
Příklad:
\begin{Verbatim}[samepage=true]
(declare-fun tau_0_0  () Real) (declare-fun tau_0_1  () Real)
(declare-fun tau_t_0  () Real) (declare-fun tau_t_1  () Real)
;; ...
(define-fun jump ( (run1 Bool)  (run2 Bool)
                   (tau1t Real) (tau20 Real)
                 ) Bool
    (and (=> (and      run1  (<  tau1t 5) )
             (and      run2  (=  tau20 tau1t) ))
         (=> (and      run1  (>= tau1t 5) )
             (and (not run2) (=  tau20 0) ))
         ;; ...
))
(assert (and (jump run_0 run_1 tau_t_0 tau_0_1)
             (jump run_1 run_2 tau_t_1 tau_0_2)
))
\end{Verbatim}
\end{paragraph} %%Definice skoků.

%%%

% Fri 27 Apr 2018 01:06:37 PM CEST
\begin{paragraph}{Nastavení fází}\label{p:design:spec:ilang:struct:step}
znamená definovat časové okamžiky mezi integracemi,
tj.~např. hodnotami konstant \id{t\_\-i}.
Nejjednodušším způsobem je zavedení
konstantní periody \id{T}, např.:
\begin{Verbatim}[samepage=true]
(define-fun T () Real 1)
(assert (and (= t_1 (+ t_0 T)) (= t_2 (+ t_1 T)) ))
\end{Verbatim}
\end{paragraph} %%Nastavení fází.

%%%

% Sat 07 Apr 2018 08:05:17 PM CEST
\begin{paragraph}{Integrace}\label{p:design:spec:ilang:struct:int}
se provádí příkazy \id{int\--ode}.
Dochází tím k~propojení konkrétních vstupních a výstupních konstant
druhu \id{Real} a konstant druhu \id{Dt}.
Podle argumentů mezí nezávislé proměnné \id{t}
těchto příkazů je určeno rozložení fází výpočtu.
Všechna \acr{ode} ve~stejných časových mezích jsou
integrována synchronně.

Příklad:
\begin{Verbatim}[samepage=true]
(assert (and (= y_1 (int-ode y dy_0 (y_0 t_0 t_1) ()))
             (= y_2 (int-ode y dy_1 (y_1 t_1 t_2) ()))
))
\end{Verbatim}
a pro~případ zdvojených konstant fází (viz.~definice skoků):
\begin{Verbatim}[samepage=true]
(assert (and (= y_t_0 (int-ode y dy_0 (y_0_0 t_0 t_1) ()))
             (= y_t_1 (int-ode y dy_1 (y_0_1 t_1 t_2) ()))
))
\end{Verbatim}
\end{paragraph} %%Integrace

%%%

\end{subsubsection} %%Struktura a použití jazyka

%%%%%%%

% Sat 28 Apr 2018 08:55:39 PM CEST
\begin{subsubsection}{Předzpracování vstupu}
\label{sss:design:spec:ilang:macros}
Předzpracování vstupu znamená jeho úpravu
na~úrovni substitucí textu,
před samotným zpracováním,
bez~sémantické analýzy.
Základní funkcí předzpracování vstupu je odstranění komentářů.

Protože vstupy zpravidla obsahují velké množství opakujícího se kódu
plynoucí z~rozdělení výpočtu do fází,
byla do~možností předzpracování vstupního jazyka přidána \name{makra},
která umožňují parametrizované generování textového kódu.
Princip se podobá makrům jazyka C.
Rozlišují se \hl{příkazová} a \hl{uživatelská} makra.
Příkazová makra slouží jako direktivy pro~předzpracovač vstupu
a lze pomocí nich zavést uživatelská makra.
Uživatelská makra umožňují parametrizovanou textovou substituci.

Název každého makra musí být určen jediným tokenem,
který začíná znakem \id{\#}.
Pokud je makro parametrizováno,
musí být token následován výrazem s~parametry.
Pokud makro parametrizováno není,
token může a nemusí být následován prázdným výrazem \id{()},
doporučujeme však prázdný výraz používat,
čímž se zamezuje případné chybné interpretaci následujícího výrazu,
který není (nemá být) seznamem parametrů.
Parametry makra jsou v~jeho těle použita
jako dočasná uživatelská makra. Pokud název parametru
koliduje s~dříve definovaným uživatelským makrem,
má parametr přednost.

Makra mohou obsahovat vnořená makra.
Jsou-li makra expandována, vyhodnocení je provedeno rekurzivně
a není kontrolováno, zda je rekurze konečná.

Makra umí pracovat s~numerickými literály (včetně celočíselných),
ale ne s~literály \id{true} a \id{false} druhu \id{Bool}.

%%%

% Mon 23 Apr 2018 08:24:55 PM CEST
\begin{paragraph}{Příkazová makra}
\label{p:design:spec:ilang:macros:cmd}
se nesmí nacházet uvnitř vstupních výrazů,
ale mohou se nacházet uvnitř jiných maker.
Mezi tato makra patří:
\begin{itemize}
\item
   \begin{enumerate}
   \item \label{i:macro:if:if}
      \id{\#if <cond> <body> \#endif}
   \item \label{i:macro:if:else}
      \id{\#if <cond> <body1> \#else <body2> \#endif}
   \end{enumerate}
   Podmíněně \hl{expanduje} text \id{<body>},
   pokud je \hl{literál} \id{<cond>} vyhodnocen jako pravdivý.
   Ve~variantě \rf{i:macro:if:else}
   je navíc při nesplnění podmínky \id{<cond>}
   expandována část \id{<body2>}.
   Výsledkem může být i~prázdný text.
\item
   \begin{enumerate}
   \item \label{i:macro:def:def}
      \id{\#def <name> <|(<arg>*)> <body> \#enddef}
   \item \label{i:macro:def:define}
      \id{\#define <name> <|(<arg>*)> <body>}
   \end{enumerate}
   Zavádí \hl{globální uživatelské makro} s~názvem \id{<name>},
   s~parametry, nebo bez nich,
   s~obsahem \id{<body>}.
   Je povolena nejvýše jedna definice globálního makra \id{<name>}.
   Makro \id{<name>} \hl{není expandováno} v~místě definice,
   ale až v~místě volání.
   \id{<body>} tedy může obsahovat i~libovolná vnořená makra
   včetně dalších definic; korektnost závisí až na~kontextu
   místa volání makra. Makro smí být definováno i~rekurzivně,
   ale je nutné ohlídat koncové podmínky.

   Ve~variantě \rf{i:macro:def:def} může být tělo i~víceřádkové;
   varianta \rf{i:macro:def:define} je zakončena koncem řádku.
\item \id{\#let <name> <{}<body>|(<body>)> <scope> <|\#endlet <name>{}>} \\
   Zavádí \hl{lokální uživatelské makro}
   v~rámci \id{<scope>} s~názvem \id{<name>}
   bez~parametrů. Smí být definováno i~několik lokálních maker \id{<name>},
   platné je to naposledy definované.
   \id{<body>} je expandováno už v~místě definice,
   výsledkem expanze smí být i~prázdný text.
   Neuzávorkované \id{<body>} je interpretováno jako jediný token.
   \id{\#endlet} ukončuje platnost aktuálního makra.
\item
   \begin{enumerate}
   \item \label{i:macro:for:int}
      \id{\#for (<var> <init> <end>) <body> \#endfor}
   \item \label{i:macro:for:cond}
      \id{\#for (<var> <init> (<cond>) (<step>)) <body> \#endfor}
   \item \label{i:macro:for:list}
      \id{\#for (<var> (<list>)) <body> \#endfor}
   \end{enumerate}
   Expanduje text \id{<body>}, který může záviset na \id{<var>}
   jakožto lokálním uživatelském makru.
   Text je opakovaně expandován s~měnící se hodnotou \id{<var>}
   závisle na~uvedených podmínkách.

   V~těle smí být obsažena vnořená makra \id{\#for}.

   Varianta \rf{i:macro:for:int} generuje \id{<var>}
   s~celočíselnými hodnotami od~\id{<init>} do~\id{<end>} včetně,
   s~jednotkovým krokem.
   Varianta \rf{i:macro:for:cond} generuje \id{<var>}
   s~počáteční hodnotou \id{<init>} a následujícími hodnotami
   odpovídající vyhodnocení výrazu \id{(<step>)},
   dokud je výraz \id{(<cond>)} vyhodnocován jako pravdivý.
   Varianta \rf{i:macro:for:list} generuje \id{<var>}
   postupně se~všemi hodnotami uvedenými ve~výčtu \id{(<list>)}.
\end{itemize}

Příklady příkazových maker:
\begin{Verbatim}
#define TO_BOOL(cond) #if #cond true #else false
\end{Verbatim}
\begin{Verbatim}[samepage=true]
#define N() 5
#def SUM_SQR() (+
   #for (i 0 #N)  ;; equiv. to: #for (i 0 (<= #i #N) (+ #i 1))
                  ;; equiv. to: #for (i (0 1 2 3 4 5))
   #let j ((+ #i 1))  ;; or #let j (+ #i 1)
       (* #i #j)
   #endlet j
   #endfor
) #enddef
\end{Verbatim}
\end{paragraph} %%Příkazová makra

%%%

% Tue 24 Apr 2018 10:51:38 PM CEST
\begin{paragraph}{Uživatelská makra}
\label{p:design:spec:ilang:macros:user}
musejí být před použitím alespoň jednou definována
pomocí příkazových maker \id{\#def}, \id{\#define} nebo \id{\#let},
nebo jako parametry makra.
Parametry maker jsou interně zavedeny pomocí mechanismu
lokálních uživatelských maker
(s~tělem odpovídajícím hodnotě parametru v~místě volání),
a proto mezi nimi
nebude nadále rozlišováno.
Názvy lokálních a globálních maker se mohou navzájem překrývat,
přednost má vždy naposledy definované lokální makro.

V~každém místě volání jsou makra nahrazena za~definovaný text,
který může být závislý na~parametrech
nebo i~na~samotném makru~---~pak hovoříme o~\hll{rekurzi}.
Rekurze mají velkou vyjadřovací schopnost,
jelikož lze používat vnořených podmíněných maker \id{\#if}.
Pomocí těchto rekurzí lze např. zavést
makra \id{\#for}.
Průběh rekurzivních expanzí ale není nijak kontrolován.

Expanze maker je prováděna i~uvnitř tokenů.
Každý token je rozdělen na~části
podle znaků \id{\#}
a každá část je vyhodnocena zvlášť.
Je-li token složen z~více než jedné takové části,
jsou všechny expandované části \hl{složeny do~jediného tokenu},
a to i~v~případě, že těla maker obsahují více než jeden token;
nesmí však obsahovat výrazy.
Vnitřní makra také nemohou mít žádné parametry,
jelikož parametry maker nikdy nejsou součástí tokenu,
protože se uvádí ve~výrazech.
Pouze poslední část tokenu smí obsahovat parametry
umístěné v~následujícím výrazu.

Nejen pro~účely oddělení částí maker a textu v~rámci jednoho tokenu
jsou zavedena dvě rezervovaná makra s~prázdným názvem
a s~názvem \id{\#}
(tj. volají se jako \id{\#} a \id{\#\#}).
\id{\#} je z~textu smazáno%
\footnote{\id{\#} může být použito pouze na~konci tokenu,
jinak je interpretováno jako makro s~názvem,
který následuje za~\id{\#}.};
\id{\#\#} je expandováno na~prázdný token.
Obě makra lze použít na~vynucení složení expanze makra do~jednoho tokenu.

Znak \id{\#} je možné použít jako escape sekvenci:
\id{\textbackslash\#},
čímž se zamezí expanzi makra (nebo je odložena)
a znak \id{\#} je ponechán nedotčen.
Toto je užitečné pro~účely předávání
tokenů, které obsahují lokální uživatelská makra,
jako parametrů globálního uživatelského makra,
pokud je žádoucí, aby bylo lokální makro expandováno až uvnitř těla
na~základě lokální definice.
(Příkazová makra \id{\#def}* svá těla neexpandují,
proto v~nich není potřeba escape sekvence používat.)
Bez použití escape sekvencí
není možné docílit toho, aby makro vygenerovalo znak \id{\#},
tj.~jakékoli neexpandované makro.

Doporučujeme používat tuto konvenci pro~názvy uživatelských maker:
velká písmena pro globální makra (\id{MACRO})
a malá písmena pro lokální makra (\id{macro}).
\end{paragraph} %%Uživatelská makra

%%%

% Fri 27 Apr 2018 02:22:15 AM CEST
\begin{paragraph}{Aritmetická expanze}\label{p:design:spec:ilang:macros:arith}
je dalším nástrojem v~rámci předzpracování vstupu,
který slouží k~nahrazení vstupního výrazu rezervované funkce
za~jeho aritmetické vyhodnocení.
Výraz nesmí obsahovat nepřímé argumenty,
jinak dojde k~chybě při vyhodnocení.
(Ve~fázi předzpracování lze používat pouze literály a makra,
ne konstanty a funkce.)

Expanze se provede předřazením tokenu \id{\$} před výraz (bez~\id{\#}).
(Vnořené výrazy už před sebou mít token \id{\$} nemusí.)
Výchozím typem argumentů vyhodnocovaných výrazů
jsou reálná čísla (resp. čísla s~plovoucí řádovou čárkou).
Typ lze také určit explicitně
přidáním znaku do~tokenu s~\id{\$}:
\begin{itemize}
\item \id{<d | i>} $\rightarrow$ celočíselný typ,
\item \id{f} $\rightarrow$ reálný typ.
\end{itemize}
\end{paragraph} %%Aritmetická expanze


%%%

% Tue 08 May 2018 03:31:35 PM CEST
\begin{paragraph}{Příklad použití maker:}
\label{p:design:spec:ilang:macros:examples}
\begin{Verbatim}[samepage=true]
#define STEPS() 10
#define STEPS-1() $d (- #STEPS 1)
#def INT_ODE(f)
#for (i 0 #STEPS-1)
#let j $d(+ #i 1)
    (= #f##_#j (int-ode #f d#f##_#i (#f##_#i t_#i t_#j) ()))
#endlet j
#endfor
#enddef
(assert (and
    #INT_ODE(x) ;; (= x_1 (int-ode x dx_0 (x_0 t_0 t_1) ()))
                ;; (= x_2 (int-ode x dx_1 (x_1 t_1 t_2) ())) ...
    #INT_ODE(y) ;; (= y_1 (int-ode y dy_0 (y_0 t_0 t_1) ())) ...
))
\end{Verbatim}

Další příklady jsou uvedeny
v~příloze \rf{appendix:macros},
včetně případů užití.
\end{paragraph} %%Příklad použití maker:

%%%

\end{subsubsection} %%Předzpracování vstupu

%%%%%%%

\end{subsection} %%Vstupní jazyk

%%%%%%%%%%%%%

% Sat 28 Apr 2018 11:04:53 PM CEST
\begin{subsection}{Výstupy}\label{ss:design:spec:out}
Výstupem řešiče je především příznak splnitelnosti.
Je-li vstup splnitelný,
pak volitelně také ohodnocení diferencovaných konstant
v~jednotlivých fázích.
Pokud je navíc zadán výstupní soubor,
jsou do~něj zapsány celé trajektorie
všech diferencovaných funkcí
a z~těchto dat je vykreslen společný graf.

V~případě konečné množiny počátečních podmínek
je výstupem \id{sat} nebo \id{unsat}
v~případě splnitelného nebo nesplnitelného vstupu.
S~výjimkou zanedbání aproximačních chyb \acr{ode} řešiče
jsou tyto výstupy exaktní,
jelikož řešič buď nalezne splňující ohodnocení,
nebo prozkoumá všechny možnosti a ověří, že žádná není splnitelná.

V~případě nekonečné množiny počátečních podmínek
je možný výstup \id{sat},
ale pokud je vstup nesplnitelný,
výpočet pravděpodobně nikdy neskončí.

Výstup \id{unknown} \hl{není} navržen,
ač by byl v~některých případech vhodný,
např. pro~nesplnitelné intervalové počáteční podmínky.
\end{subsection} %%Výstupy

%%%%%%%%%%%%%

\end{section} %%Specifikace nástroje

%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Mon 09 Apr 2018 02:15:54 PM CEST
\begin{section}{Softwarová architektura}\label{s:design:arch}
V~následující sekci popíši abstraktní návrh
modelu komponent celého řešiče,
jejich vztahů a rozhraní a rozdělení zodpovědností.
Poté rozeberu interní návrh jednotlivých komponent.

%%%%%%%%%%%%%

% Mon 07 May 2018 08:52:58 PM CEST
\begin{subsection}{Model komponent}\label{ss:design:arch:comp}
Stěžejními komponentami jsou \acr{smt} a \acr{ode} řešič.
Úkolem je zajistit jejich vzájemnou komunikaci
a řídit centrální algoritmus celého procesu
od~přijmutí vstupu ve~vstupním jazyce po výpis výsledků.

Průběh výpočtu se řídí zejména \acr{smt} řešičem.
První otázkou bylo, zda celý systém řídit
z~\acr{smt} řešiče, nebo jej použít jako externí komponentu
a centrální bod umístit mimo něj.
Pokud by byl \acr{smt} řešič centrálním bodem,
mohly by být maximálně využity všechny jeho funkce.
Nevýhodou by však byla nutnost
zvolit konkrétní řešič
a komunikaci s~\acr{ode} řešičem
implementovat uvnitř,
což by vyžadovalo podrobnější obeznámení se
s~fungováním \acr{smt} řešiče.
Je však tento postup nutný?

Pokud by byl \acr{smt} řešič
implementován jako černá skříňka,
bylo by použití celého systému mnohem flexibilnější.
\acr{smt} řešiče jsou stále v~aktivním vývoji
a možnost použít libovolnou verzi
by bylo velkým přínosem.
Proto bylo snahou nalézt řešení
využívající tohoto postupu.

\pic{comp_design.pdf}{comp:design}{0.75}
   {Blokové schema modelu komponent ve~stádiu návrhu}
   {Směry šipek určují směr výstupů z~komponent.}

Obrázek \rfPic{comp:design} zachycuje
blokové schema navržených komponent.

%%%%%%%

% Wed 02 May 2018 07:57:32 PM CEST
\begin{subsubsection}{\acr{smt} řešič jako nezávislá komponenta}
\label{sss:design:arch:comp:smt}
\acr{smt} řešič lze použít
jako téměř nezávislou komponentu,
pokud splňuje tyto požadavky:
\begin{itemize}
\item je inkrementální,
\item je konformní s~\acr{smt}-LIB standardem.
\end{itemize}
Každý takový řešič pak lze používat
a komunikovat s~ním výhradně prostřednictvím
\acr{smt}-LIB jazyka,
tj.~přes soubory nebo standardní vstup a výstup.

Vzhledem k~tomu, že \acr{smt}-LIB
obsahuje operace se~zásobníkem asercí
(viz.~sekce \rf{ss:search:smt:smtlib}),
je možné dynamicky přidávat a odebírat
klauzule, což lze použít
pro~přijímání hodnot z~\acr{ode} řešiče.
Druhá možnost je přidávání
podmíněných a konfliktních klauzulí
s~vypočtenými hodnotami z~\acr{ode} řešiče.
Tyto postupy jsou možné z~toho důvodu,
že \acr{ode} řešič v~našem pojetí
pracuje výhradně s~pevnými počátečními podmínkami
a má tedy i~jednoznačný výstup.
Hodnoty konstant jsou získávány postupně
od~počátečních podmínek a přidávány jako nové aserce.
Při~porušení některých invariant
se provede návrat.
Podrobnější algoritmus je popsán
v~centrální komponentě.

Svým způsobem lze tento postup použít
i~jako opakovaně generované celistvé statické vstupy
pro~neinkrementální \acr{smt} řešič,
ale předpokládá se, že inkrementální řešič
si bude počínat efektivněji.

Tímto je získáno velké flexibility
ze~strany \acr{smt} řešiče,
vzhledem k~tomu, že \acr{smt}-LIB standard
podporuje většina řešičů.
Jediné potenciální riziko
je neefektivní počínání řešičů
v~inkrementálním módu,
tj. pokud by obecně operace ověření splnitelnosti
byla výpočetně náročná,
vzhledem k~tomu, že tato operace bude prováděna často.
Předpokládá se však,
že doba výpočtu by měla být výrazně nižší
v~následujících fázích,
které přidávají jen malé množství nových asercí,
oproti první fázi,
který řeší celý počáteční vstup.

Používání textového rozhraní pomocí \acr{smt}-LIB
by mělo mít zanedbatelný vliv na~výkon
oproti použití programového rozhraní,
v~porovnání s~dobou samotných výpočtů
\acr{smt} a \acr{ode} řešičů.
Implementace si však musí poradit
s~korektními konverzemi čísel s~plovoucí řádovou čárkou
z~textu či do~textu,
protože \acr{smt} řešič pracuje s~exaktními hodnotami.
\end{subsubsection} %%\acr{smt} řešič jako nezávislá komponenta

%%%%%%%

% Fri 04 May 2018 11:35:20 AM CEST
\begin{subsubsection}{\acr{ode} řešič}\label{sss:design:arch:comp:ode}
\acr{ode} řešič postačuje použít jako samostatnou komponentu,
jelikož má fungovat jako
filtr~---~pro~každý vstup vrátí odpovídající výstup.
Výjimkou je jen jeho inicializace,
kdy se musí nastavit tvary diferenciálních rovnic.
Konkrétní rozhraní nehraje důležitou roli,
jen je důležité dávat pozor na~nastavení přesnosti
čísel s~pohyblivou řádovou čárkou,
protože \acr{smt} řešič pracuje s~racionálními čísly,
které jsou exaktní. To může činit potíže zejména
při~komunikaci prostřednictvím znakových řetězců.

Důležitým požadavkem je však to,
aby byl řešič schopen přijímat
specifikace diferenciálních rovnic
dynamicky jako text,
protože tak jsou reprezentovány ve~vstupním jazyce.
Např. řešiče odeint a \acr{sundials}
přijímají specifikace jako kompilované funkce
přímo v~programovacím jazyce,
což je efektivní, ale pro tento účel
nevhodná varianta.
Řešiče, které to umějí, existují
(např.~\acr{gnu} Plotutils,
\acr{gnu} Octave, SageMath;
nemluvě o~komerčních nástrojích),
ale problém je např.~v~tom,
že (pochopitelně) nemají navzájem
nijak standardizován vstupní formát,
jako tomu je třeba u~\acr{smt} řešičů
s~\acr{smt}-LIB standardem.
Pokud bychom zvolili některý z~nich,
mohlo by být následně poměrně obtížné umožnit
nasazení jiného řešiče.

Komponentu s~\acr{ode} řešičem
by bylo možné navrhnout tak,
aby nějakým způsobem obalovala
obecné funkcionality řešiče
bez~ohledu na konkrétní použitý nástroj.
Toho lze docílit navržením komponenty
jako abstraktní třídy
obstarávající veřejné rozhraní
a konkrétní implementaci přenechat
na~odvozených třídách.
Pokud by byl zvolený \acr{ode} řešič
implementován v~jazyce C++ nebo C,
měla by být jeho implementace
uvnitř odvozené třídy snadná,
a navíc by takové řešení mělo být efektivní.

Po~řešiči je však obecně (prozatím) vyžadována
pouze integrace na~základě
exaktních počátečních podmínek (tj.~\acr{ivp})
a koncových podmínek
určených předem danou délkou integrace,
bez~řešení jakýchkoli invariant.
\end{subsubsection} %%\acr{ode} řešič

%%%%%%%

% Wed 02 May 2018 07:57:55 PM CEST
\begin{subsubsection}{Zpracování vstupu}\label{sss:design:arch:comp:parse}
Vstupní jazyk je navržen podobně
jako jazyk \acr{smt}-LIB standardu,
což značně usnadňuje zpracování vstupu,
jelikož stačí zpracovat jen přidané \acr{ode} konstrukty
a celý zbytek vstupu delegovat s~jen minimálními změnami
na~\acr{smt} řešič jako inicializaci.
\acr{ode} řešič je nutné inicializovat
definicemi všech diferenciálních rovnic
a jejich argumentů.

Přidanou hodnotou je umožnění použití maker,
pomocí nichž lze vstupy parametrizovat
a ke generování není zapotřebí dalšího nástroje.
Předzpracování vstupu, tak jak je navrženo,
je zcela nezávislé
na~sémantice vstupního jazyka
a mělo by být implementováno jako samostatná komponenta.

Komponenta zpracování vstupu bude s~konstantami a funkcemi
pracovat výhradně na~úrovni jejich identifikátorů
a nebude řešit jejich možné hodnoty;
to bude zodpovědnost centrální komponenty
a \acr{smt} řešiče.
\end{subsubsection} %%Zpracování vstupu

%%%%%%%

% Fri 27 Apr 2018 10:26:30 PM CEST
\begin{subsubsection}{Centrální komponenta}
\label{sss:design:arch:comp:center}
Zodpovědností centrálního bodu je
na~základě zpracovaného vstupu
nastavit diferenciální rovnice
a ty související sjednotit,
inicializovat oba řešiče
a určit fáze výpočtu.
Následně pak řídit
průběh výpočtu
a komunikaci mezi oběma řešiči.

Díky několika možným rozhraním u~obou řešičů
je návrh poměrně volný
a důraz je kladen hlavně na~zvolený řídící algoritmus,
který musí korektně ověřit všechny možnosti
ohodnocení vstupních konstant a funkcí
a přiměřeně efektivně zacházet
s~inkrementálním \acr{smt} řešičem, zejména s~návraty.
Návrh algoritmu je uveden v~samostatné sekci.
\end{subsubsection} %%Centrální komponenta

%%%%%%%

\end{subsection} %%Model komponent

%%%%%%%%%%%%%

% Tue 10 Apr 2018 10:38:59 AM CEST
\begin{subsection}{Návrh \acr{ode} řešiče}\label{ss:design:arch:ode}
Problém s~dynamickými textovými specifikacemi diferenciálních rovnic
a sestavení odpovídajících funkcí
jsem se rozhodl řešit formou stromových struktur výrazů
a jejich transformací na~funkce s~argumenty.
Tyto struktury pak lze použít jako vstupní specifikace při~inicializaci
a vytvořené funkce volat ve~fázích integrace.

Nejprve popíši návrh avizované struktury
a poté návrh abstraktního řešiče.

%%%%%%%

% Tue 10 Apr 2018 10:40:12 AM CEST
\begin{subsubsection}{Výrazy a jejich vyhodnocení}
\label{sss:design:arch:ode:exprs}
Tato datová struktura sestává
z~\name{výrazů} a z~jejich i~několika \hl{vyhodnocení}.

%%%

% Fri 27 Apr 2018 10:40:29 PM CEST
\begin{paragraph}{Výraz}\label{p:design:arch:ode:exprs:expr}
je obecná stromová struktura
sestavená z~prefixových textových výrazů.
Každý výraz obsahuje spojový \hl{seznam} potomků,
z~nichž každý je buď další podvýraz,
nebo token s~textovou hodnotou.
Seznam je použit proto,
že se předpokládá sekvenční průchod jeho strukturou,
a aby bylo možné efektivně odkudkoli odebírat či přidávat prvky.

Výraz ve~výchozí formě nemá určen žádný datový typ
a používá pouze znaky.
Může být tedy použit pro~libovolné účely
vyžadující vytvoření hierarchické struktury
z~(ne zcela nutně) prefixového vstupu,
např. i~pro~účely syntaktického rozboru
textového vstupu, který ani není výrazem,
ale používá prefixovou notaci.

Po~této struktuře je vyžadováno,
aby co nejvíce zpřístupnila sekvenční čtení i~zápis,
což budou velmi časté operace.
\end{paragraph} %%Výraz

%%%

% Tue 24 Apr 2018 02:09:07 PM CEST
\begin{paragraph}{Vyhodnocení}\label{p:design:arch:ode:exprs:eval}
se vždy vztahuje k~jedinému výrazu,
ale výraz může mít přidružených i~několik vyhodnocení.
Úloha vyhodnocení je vytvořit z~obecné textové struktury
výrazu strom konkrétních funkcí s~přímými či nepřímými argumenty
konkrétního aritmetického typu,
který lze v~inicializaci volit různě.
Tato struktura musí umožňovat volání jako funkce,
případně i~s~parametry,
pokud výraz obsahuje nepřímé argumenty.

Když je výraz transformován na~vyhodnocení,
musí být jeho první prvek token s~názvem nějaké funkce,
typicky aritmetickým operátorem.
Následující prvky nemají žádná omezení
(kromě toho zmíněného pro~podvýrazy)
a platí pro~ně následující:
\begin{itemize}
\item je-li prvek další podvýraz, vytváří se další vyhodnocení,
\item je-li prvek token, provede se konverze na~datový typ;
   pokud konverze selže (token nereprezentuje hodnotu daného typu),
   je token považován za~nepřímý argument.
\end{itemize}
Nepřímé argumenty se později dosadí
jako parametry při~volání vyhodnocení
a textové hodnoty tokenů jsou uloženy jako klíče argumentů.
Nepřímých argumentů se~stejným klíčem
může být ve~výrazu obsaženo více.
\end{paragraph} %%Vyhodnocení

%%%

\end{subsubsection} %%Výrazy a jejich vyhodnocení

%%%%%%%

% Fri 04 May 2018 11:39:03 AM CEST
\begin{subsubsection}{Abstraktní řešič}\label{sss:design:arch:ode:solver}
Řešič bude implementován abstraktní třídou tak,
aby umožňoval snadné odvození na~konkrétní \acr{ode} řešič
s~implementací různých metod integrace funkcí.
Odvozené třídy by měly řešit pouze implementaci konkrétních metod,
ale veřejné i neveřejné rozhraní by měla řešit abstraktní třída,
včetně stanovení použitých datových struktur.
Odvozenou třídu by mělo být možné
implementovat pro~jakýkoli \acr{ode} řešič,
který řeší \acr{ivp} s~koncovými podmínkami závisejících na~čase.

Řešič bude umožňovat inicializaci
specifikací diferenciálních rovnic
primárně pomocí datových struktur výrazů uvedených
v~sekci \rf{p:design:arch:ode:exprs:expr}.
K~těmto výrazům si řešič interně sestaví odpovídající
vyhodnocení tak, jak jsou uvedeny
v~sekci \rf{p:design:arch:ode:exprs:eval}.
Uživatel bude pracovat pouze s~výrazy,
od~vyhodnocení bude odstíněn.
Naopak implementace odvozených řešičů
budou pracovat pouze se~sestavenými vyhodnoceními.
Vyhodnocení budou vždy obsahovat i~nepřímé argumenty,
implicitně alespoň argument integrované funkce
a volitelně také argument nezávislé proměnné \id{t}
(viz.~vztah \rfeq{ode}).

Specifikované diferenciální rovnice bude možné počítat opakovaně
s~různými vstupními argumenty podle konstant
aktuálních příkazů \id{int\--ode}.
Při výpočtech budou v~implementaci
interně volána sestavená vyhodnocení
v~každém kroku integrace,
což vyžaduje, aby bylo volání vyhodnocení
přiměřeně efektivní,
jelikož kroků integrace
bude řádově stovky až statisíce
(podle délky fází výpočtu).

Třída by se však měla pokud možno chovat
jako obecný \acr{ode} řešič
bez~užších vazeb na~problém \acr{smt}.
Tuto zodpovědnost by měla řešit centrální komponenta.

Řešič bude také podporovat ukládání průběhu
integrací všech \acr{ode} a jejich výpis.

Takový řešič bude možné používat jako filtr
(s~výjimkou inicializace)~---~na~každý vstup
odpoví výstupními hodnotami.
\end{subsubsection} %%Abstraktní řešič

%%%%%%%

\end{subsection} %%Návrh \acr{ode} řešiče

%%%%%%%%%%%%%

% Thu 03 May 2018 01:52:27 PM CEST
\begin{subsection}{Návrh zpracování vstupu}\label{ss:design:arch:parse}
Úkolem komponenty pro~zpracování vstupu
je nalézt příkazy \acr{ode} vstupního jazyka
(viz.~\rf{sss:design:spec:ilang:ode})
a částečně také \acr{smt} konstrukty
(viz.~\rf{sss:design:spec:ilang:smt}),
zpracovat je a nahradit je za~konstrukce
výhradně \acr{smt}-LIB standardu,
nebo je zcela vyřadit.
Postup je následující:
\begin{enumerate}
\item Nastavení \acr{smt} vstupu: zvolení logiky,
   definice druhu \id{Dt}, ad.
\item Zpracování definic diferenciálních rovnic:
   načtení definic diferenciálních rovnic do~výrazů
   a načtení seznamů klíčů nepřímých argumentů pro~\acr{ode} řešič
   z~příkazů \id{define\--dt};
   definice konstant variant derivací druhu \id{Dt}
   s~názvy podle identifikátorů z~\id{define\--dt}.
\item Substituce příkazů integrací \id{int\--ode}
   za~pomocné konstanty nebo funkce druhu \id{Real};
   sekvenční uložení identifikátorů argumentů příkazů \id{int\--ode}
   a roztřídění podle jednotlivých \acr{ode}
   a podle unikátních párů identifikátorů nezávislých proměnných \id{t}.
   (Nastavení fází je zodpovědnost centrální komponenty.)
\item (Volitelné) nastavení počáteční délky kroku integrací
   z~příkazu \id{define\--ode\--step} a jeho smazání.
\item Transformace zbylých konstruktů nekompatibilních
   s~\acr{smt}-LIB standardem, které jsou povoleny ve~vstupním jazyce
   (např. záporné numerické literály).
\end{enumerate}

Ke~zpracování vstupu lze s~výhodou
použít struktury výrazů
ze~sekce \rf{p:design:arch:ode:exprs:expr},
jelikož vstupní jazyk používá prefixovou notaci.
\end{subsection} %%Návrh zpracování vstupu

%%%%%%%%%%%%%

% Tue 24 Apr 2018 03:13:08 PM CEST
\begin{subsection}{Návrh předzpracování vstupu}
\label{ss:design:arch:preprocess}
Tato komponenta má fungovat samostatně pro~libovolný prefixový vstup,
tak jak je definována v~sekci \rf{ss:design:spec:ilang},
ale bez ohledu na~sémantiku tokenů a výrazů,
s~výjimkou komentářů a maker.
Návrh maker je uveden v~podsekci \rf{sss:design:spec:ilang:macros}.

V~první řadě se provedou nejjednodušší substituce textu
na~úrovni řádků, bez~ohledu na strukturu výrazů i~maker.
V~této fázi dojde ke~smazání komentářů
a k~nahrazení řádkových maker \id{\#define}
za~jejich uzavřený ekvivalent ve~tvaru makra \id{\#def}.
Poté je vstup nezávislý na~řádcích
a je závislý výhradně na~struktuře výrazů a maker.

Následné zpracování textu bude (opět) založeno na~třídách výrazů
ze~sekce \rf{p:design:arch:ode:exprs:expr}.
Výrazy a makra budou procházeny rekurzivně
a každý token obsahující makro bude náležitě zpracován,
což bude vyžadovat operace vkládání a odstraňování potomků výrazů.
\end{subsection} %%Návrh předzpracování vstupu

%%%%%%%%%%%%%

% Sat 28 Apr 2018 01:56:13 PM CEST
\begin{subsection}{Řídící algoritmus}\label{ss:design:arch:alg}
Úlohou algoritmu je dospět v~\acr{smt} řešiči
k~ohodnocení všech konstant
na~základě výsledků rovnic z~\acr{ode} řešiče.
Hlavní výzvou je problém s~návraty,
kdy v~průběhu výpočtu dochází k~tomu,
že vstup v~aktuální podobě není splnitelný.
Návraty má efektivně implementován \acr{smt} řešič,
ale je otázkou, jakým způsobem je na~něj delegovat.

Složitost roste s~počtem fází výpočtu
a s~počtem všech možných voleb derivací.
V~nejhorším případě se musí projít všechny možnosti,
tomu se nelze vyhnout, kromě použití nějakých heuristik,
které ale nebudou uvažovány.
Rovněž nebudou uvažovány možnosti paralelizace.

%%%

% Sat 28 Apr 2018 01:56:20 PM CEST
\begin{paragraph}{Diskuze redukce ověření splnitelností.}
\label{ss:design:arch:alg:discuss}
Důležitým aspektem je poměr výpočetních náročností
operací ověření splnitelnosti \acr{smt} řešičem
a výpočtu diferenciálních rovnic \acr{ode} řešičem.
Vzhledem k~tomu, že celý výpočet je rozdělen
do~mnoha relativně málo vzdálených fází,
je délka integrací poměrně malá
oproti běžným případům užití.
Navíc integrace počítá jen s~malým množstvím
vstupních hodnot,
oproti \acr{smt} řešiči,
který musí v~každé fázi ověřit splnitelnost kompletně celého vstupu,
ač v~inkrementálním módu.
Dá se tedy očekávat,
že \acr{ode} řešič bude rychlejší než \acr{smt} řešič,
a efektivní algoritmus by měl redukovat
počet operací ověření splnitelnosti
a částečně do~nich delegovat návraty.

Návraty na~\acr{smt} řešič bohužel není v~rozumné míře
možné delegovat zcela,
protože takový postup by vyžadoval
spočítat úplně všechny možnosti průchodů.
Důvod je ten, že každá dílčí integrace závisí
na~konkrétních vstupních hodnotách,
a tyto zase tranzitivně závisí
na~všech předešlých.
Tudíž není možné mít v~každé fázi
pokryty všechny možnosti,
např. pomocí podmíněných klauzulí,
aniž by složitost rostla exponenciálně.

Částečná redukce ověření splnitelnosti
je možná pomocí způsobu,
kdy se v~každé fázi vyřeší
kromě \acr{smt} řešičem zvolené varianty derivací
navíc také všechny ostatní kombinace voleb variant
v~rámci aktuální fáze
a přidají se jako podmíněné klauzule.
Tím by se pokrylo lokální okolí aktuální fáze
a počet nutných ověření splnitelnosti
by se redukovalo o~jednu úroveň stromu prohledávaného prostoru,
a pomocí podmíněných klauzulí by se částí návratů zabýval \acr{smt} řešič.

Počet všech kombinací variant derivací
závisí na~produktu počtu variant derivací každé \acr{ode},
kterých je omezený počet a nezávisí na~velikosti vstupu (počtu fází),
ale výhradně na~obecné specifikaci modelu.
Tento počet by tedy neměl být velký
a pokud by byl \acr{ode} řešič výrazně rychlejší
než \acr{smt} řešič,
měla by redukce počtu ověření splnitelnosti
převážit nad~nadbytečným výpočtem diferenciálních rovnic.
Takový algoritmus by si však v~případě návratů
musel nějakým způsobem pamatovat,
které vypočtené varianty už procházel a které ještě ne.

Postup řešením více variant derivací
lze dále modifikovat~---~řešit jich více či méně,
o~více fází napřed, apod.
Efektivita zvoleného řešení by závisela
na~empirickém měření složitosti,
analyticky ji lze těžko předpovědět.
\end{paragraph} %Diskuze redukce ověření splnitelností.

%%%

\pic{alg_tree.pdf}{alg:tree}{0.99}
   {Ilustrace postupu základního algoritmu prohledávaným prostorem}
   {Je uvedena jen zjednodušená varianta o~jediné \acr{ode}
    se~dvěma variantami derivací.
    Hodnoty \id{\_x0}, \id{\_x1}, \dots představují výčet možných
    počátečních hodnot.}

% Mon 07 May 2018 11:29:29 PM CEST
\begin{paragraph}{Základní algoritmus.}
\label{ss:design:arch:alg:basic}
Pro~účely prototypu navrhnu zatím alespoň základní algoritmus,
který postupuje jen po~jednotlivých
cestách ve~stromu prohledávaného prostoru,
výhradně na~základě aktuálního ohodnocení konstant,
bez~předběžných výpočtů jiných variant.
Takový postup je jednodušší implementovat,
ale v~každé fázi vyžaduje ověření splnitelnosti,
a tedy významně závisí na~její výkonnosti.
Nástin postupu je znázorněn na~obrázku
\rfPic{alg:tree}.

Z~obrázku vidíme, že v~některých případech
se v~uzlech ověřuje splnitelnost zbytečně mnohokrát
a pokud by se naráz předpočítávaly všechny varianty,
mohla by se např. celkově ve~fázi~1
ověřovat splnitelnost jen dva krát, ne pět krát.

V~této variantě ztrácí smysl přidávat
nové hodnoty jako podmíněné klauzule,
namísto toho stačí aserce jen vkládat do~zásobníku asercí.
Důvod, proč samotné podmíněné klauzule nefungují,
je ten, že nově vypočtené hodnoty
jsou podmíněny jejich vstupními podmínkami,
ale \acr{smt} řešič nic nenutí tyto vstupní podmínky zvolit
a smí si zvolit i~jiné varianty derivací,
které ale ještě nejsou spočtené,
a tudíž si za~výsledek integrace smí dosadit libovolnou hodnotu.
Tudíž by bylo nutné kromě podmíněné klauzule
navíc explicitně přidat klauzule,
které vyžadují vstupní hodnoty v~předpokladech.
Tím ale podmíněné klauzule ztrácí smysl
a stačí jen rovnou přidat předpoklady
i~výsledky do~asercí bez~podmínek.

Bez~použití podmíněných klauzulí
je však nutné při~návratu
přidané aserce odebrat,
což umožňují operace se zásobníkem asercí.
Je nutné přidávat konfliktní klauzule,
tím se definitivně uzavírají větve
ve~stromu prohledávaného prostoru
a algoritmus tak konverguje k~výsledku.
Se~vzrůstajícím množstvím konfliktních klauzulí
však roste složitost dílčích operací ověření splnitelnosti.

Postup je následující:
\begin{enumerate}
\item Překlad vstupní formule:
   \begin{enumerate}
   \item Uložení definic diferenciálních rovnic
      ze~zpracovaného vstupu, určení rozložení fází výpočtu%
      \footnote{Tato operace není diskutována,
      nicméně ve~zcela obecném případě se může jednat
      o~poměrně náročnou úlohu.}.
   \item Sloučení všech \acr{ode}, které obsahují
      společné klíče nepřímých argumentů,
      do~soustav \acr{ode}.
   \item Inicializace \acr{smt} řešiče,
      tj.~zaslání modifikovaného vstupu
      bez~specifikací diferenciálních rovnic.
   \item Inicializace \acr{ode} řešiče,
      tj.~zaslání specifikací (soustav) diferenciálních rovnic.
   \end{enumerate}
\item Nastav počáteční číslo fáze na~$0$: \id{s~:= 0}.
\item \label{i:design:alg:check-sat}
   Ověření splnitelnosti \acr{smt} formule:
   \begin{itemize}
   \item Je-li splnitelná, získej model,
      tj.~ohodnocení všech konstant.
   \item Není-li splnitelná, proveď návrat:
      \begin{enumerate}
      \item Pokud \id{s~= 0}, vstup není splnitelný. Konec.
      \item Odeber vrchní úroveň zásobníku asercí: \id{(pop~1)}.
      \item Přidej konfliktní klauzuli (aserci)
         znemožňující vstupní (nikoli výstupní%
         \footnote{Přidání výstupních hodnot do~konfliktní
         klauzule by umožnilo řešiči za~ně dosadit jiné hodnoty
         a tím zneplatnit celou klauzuli.})
         ohodnocení předchozí fáze.
      \item Vrať se do~předchozí fáze:
         \id{s-{}-}, jdi na~bod \rf{i:design:alg:check-sat}.
      \end{enumerate}
   \end{itemize}
\item Pokud je dosaženo celkového počtu fází,
   jdi na~bod \rf{i:design:alg:end}.
\item Vyber ohodnocené konstanty,
   které do~fáze vstupují jako vstupní argumenty.
\item Proveď výpočet všech diferenciálních rovnic
   v~rámci aktuální fáze a ulož výstupy.
\item Přidej výstupní i~vstupní hodnoty této fáze
   jako aserce do~nové úrovně zásobníku asercí: \id{(push~1)}.
\item Přejdi do~další fáze: \id{s+{}+},
   jdi na~bod \rf{i:design:alg:check-sat}.
\item \label{i:design:alg:end}
   Vypiš získaný model. Konec.
\end{enumerate}

Tento postup se díky konfliktním klauzulím
podobá algoritmu \acr{dpll}.
\end{paragraph} %%Základní algoritmus.

%%%

\end{subsection} %%Řídící algoritmus

%%%%%%%%%%%%%

\end{section} %%Softwarová architektura

%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Wed 02 May 2018 09:31:27 PM CEST
\chapter{Realizace}\label{ch:impl}
V~implementaci řešiče jsem postupoval
po~jednotlivých softwarových komponentách
podle jejich návrhu.
V~některých případech,
zejména u~centrální komponenty,
je realizace oproti návrhu zjednodušena,
což je v~odpovídající sekci explicitně zmíněno.
Výsledný prototyp lze použít
pro~účely experimentování s~různými modely hybridních systémů
a pro~účely srovnání s~řešičem
pracujícím s~intervalovou metrikou,
konkrétně dReal (viz.~sekce \rf{p:search:hybrid:dreal}).

Nejprve popíši projekt jako celek,
poté rozeberu implementaci jednotlivých komponent,
centrální komponentou konče.
Na~závěr uvedu výčet některých nedostatků
a dosud chybějících funkcionalit
jako seznam úkolů do~budoucna.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Tue 08 May 2018 02:15:21 PM CEST
\begin{section}{Struktura a vlastnosti projektu}\label{s:impl:proj}
Projekt jsem nazval \name{\acrf{sos}}.
Řešič je koncipován
jako soubor knihoven, appletů a hlavní aplikace,
implementovaných převážně v~jazyce C++ (není-li řečeno jinak).
Přestože se jedná o~prototyp, je projekt strukturně koncipován tak,
aby byla jeho případná rozšíření a další vývoj
možná provést snadno přímo v~něm.
Projekt je zamýšlen jako soubor knihoven
umožňující použití různých \acr{smt} a \acr{ode}
řešičů jak jako samostatných aplikací, tak jako C++ knihoven.
Projekt používá verzovací systém \name{git},
má otevřené zdrojové kódy
a je veřejně dostupný včetně tohoto textu práce na~adrese
\url{https://github.com/Tomaqa/sos}.

Zdrojové kódy napsané v~C++ používají standard C++14
(nejsou zpětně kompatibilní se staršími standardy)
a jsou umístěny ve~jmenném prostoru \id{SOS}.
Moduly, které zprostředkovávají některý z~řešičů,
jsou izolovány od dalších zodpovědností.
Tyto moduly jsou pochopitelně závislé na~knihovnách třetích stran.
Kromě těchto (vyměnitelných) modulů je však celý projekt
se~základními funkcemi
nezávislý od~externích knihoven a využívá výhradně
vlastní a standardní knihovny \acr{stl}
a \acr{posix}.
C++ zdrojové kódy jsou zapsány ve~stylu Stroustrup%
\footnote{Podle tvůrce jazyka C++: Bjarne Stroustrup.}.

\pic{comp_impl.pdf}{comp:impl}{0.85}
   {Blokové schema modelu komponent implementovaného prototypu}
   {Směry šipek určují směr výstupů z~komponent.
    Řídící komponentu reprezentuje třída \id{Solver},
    \acr{smt} a \acr{ode} řešiče třídy *\id{::Solver},
    zpracování vstupu třída \id{Parser}
    a knihovnu výrazů a jejich vyhodnocení
    třída \id{Expr}. Předzpracování vstupu
    je vnořeno do~\id{Expr} do~třídy \id{Preprocess}.
    Některé vnořené třídy jsou vynechány (např. \id{Expr::\-Eval}).}

Na~obrázku \rfPic{comp:impl} je zachyceno
blokové schema modelu komponent implementovaného prototypu aplikace.

Hlavní aplikace je umístěna v~souboru \binFn{sos\_\-odeint}.
Je implementována v~jazyce C++
a podrobněji rozebrána ve~vlastní sekci.
Původně byla vyvíjena ve~skriptovacím jazyce Bash
v~souboru \binFn{prototype.sh},
který již v~aktuální verzi není přítomen,
ale je zpětně dohledatelný.

Před použitím nástroje je nutné jej sestavit.
Návod k~sestavení a spuštění programu
je umístěn v~příloze \rf{appendix:usage}.
Všechny následně uvedené soubory aplikací či appletů
jsou přístupné až po~tomto sestavení.

Nástroj byl vyvíjen a testován pouze v~\acr{os} Linux.
\end{section} %%Struktura a vlastnosti projektu

%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Tue 24 Apr 2018 03:57:40 PM CEST
\begin{section}{Realizace výrazů a jejich vyhodnocení}
\label{s:impl:exprs}
Vzhledem k~tomu, že tyto struktury využívá většina komponent projektu,
jsou implementovány jako samostatná knihovna
a uvedeny ve~vlastní sekci.

Výrazy reprezentuje třída \id{Expr}
a jejich vyhodnocení šablonová třída \id{Expr::\-Eval<Arg>}.

%%%

% Thu 03 May 2018 12:58:59 PM CEST
\begin{paragraph}{\id{Expr}}\label{p:impl:exprs:expr}
je odvozená třída od~abstraktní třídy \id{Expr\_\-place}.
\id{Expr} využívá polymorfismu~---~obsahuje
stromovou strukturu jako seznam ukazatelů na~\id{Expr\_\-place},
které představují argumenty výrazu.
Argumenty jsou objekty tříd odvozených od~\id{Expr\_\-place}:
buď uzly jako další podvýrazy (\id{Expr}),
nebo koncové listy, které reprezentují nějakou hodnotu.
Ty jsou implementovány šablonovou třídou \id{Expr\_\-value<Arg>},
která může jako šablonový parametr obsahovat i~netextový typ
(což je vlastně v~rozporu s~návrhem).
Jako její speciální odvozená třída je zavedena
třída \id{Expr\_\-token}, která obsahuje textovou hodnotu.
Pokud uživatel nepoužívá objekty
\id{Expr\_\-value<Arg>},
pak je struktura nezávislá od~interpretace.

\id{Expr\_\-token} umožňuje šablonovou
interpretaci svého textového obsahu
jako aritmetického typu pomocí \id{get\_\-value},
a také nastavení podle aritmetické hodnoty pomocí \id{set\_\-value}.
Tyto konverze však mohou být nepřesné,
např. v~případě čísel s~plovoucí řádovou čárkou.
V~takovém případě může být vhodnější použít \id{Expr\_\-value<Arg>}.

Zjištění typu ukazatele je doporučeno provádět pomocí funkcí
\id{is\_\-evalue}, \id{is\_\-etoken} a \id{is\_\-expr}.
Přetypování ukazatelů na~některý odvozený typ
je rovněž doporučeno provádět pomocí explicitních funkcí
(\id{ptr\_\-to\_\-expr}, apod.).

\id{Expr} se typicky sestavuje z~textového vstupu:
\id{std::\-string} nebo \id{std::\-istream}.
Jedinými speciálními znaky textového vstupu
jsou znaky kulatých závorek \id{(} a \id{)},
které interpretují argument jako (pod)výraz.
Všechny ostatní znaky jsou interpretovány jako tokeny
oddělené bílými znaky, jež nikdy nejsou součástí tokenů.
Pro~listy jsou použity pouze objekty
textového typu~---~\id{Expr\_\-token}.

Každý objekt třídy obsahuje interní iterátor
indikující pozici v~seznamu potomků
a s~ním související funkce
umožňující sekvenční čtení i~zápis,
případně spojené i~s~přetypováním,
např. \id{peek}, \id{get}, \id{extract},
\id{get\_\-token}, \id{extract\_\-expr},
\id{add\_\-new\_\-expr\_\-at\_\-pos},
\id{erase\_\-at\_\-pos}, \dots

Dále jsou vřazeny šablonové funkce,
které provedou konverzi potomka libovolného typu
na~aritmetický typ (\id{ptr\_\-to\_\-value}, \id{get\_\-value} apod.).

Nad~sestavenými výrazy lze provést některé základní operace:
\begin{itemize}
\item \id{simplify}~---~všechny (pod)výrazy (včetně kořenového),
   které obsahují jen jediný argument typu token,
   jsou převedeny na~token.
\item \id{to\_\-binary}~---~výraz je transformován tak,
   aby každý (pod)výraz (včetně kořenového)
   obsahoval nejvýše tři argumenty,
   z~nichž první musí být token s~libovolným názvem funkce
   bez~ohledu na~její interpretaci.
\item \id{flatten}~---~všechny vnořené tokeny jsou přesunuty
   do~kořenového výrazu a podvýrazy jsou smazány.
\item \id{transform\_\-to\_\-args<Arg>}~---~výraz,
   který obsahuje výhradně tokeny,
   je transformován na~pole prvků typu \id{Arg}.
\item \id{get\_\-eval<Arg>}~---~provede se \id{to\_\-binary}
   a vrátí se objekt typu \id{Expr::\-Eval<Arg>}
   sestavený z~položek výrazu.
\end{itemize}

Vyhodnocení výrazu je vždy externím objektem,
není obsaženo jako členská proměnná.
Dokud není použita operace \id{get\_\-eval},
je objekt zcela nezávislý na~svém vyhodnocení
a implementace třídy \id{Expr::\-Eval<Arg>} ani nemusí být přítomna.
Třídu \id{Expr} je tedy možné použít
i~pro~libovolné účely vytvoření hierarchické struktury
z~prefixového textového vstupu
bez~jakékoli spojitosti s~aritmetickým vyhodnocením.
\end{paragraph} %%\id{Expr}

%%%

% Tue 17 Apr 2018 01:00:32 PM CEST
\begin{paragraph}{\id{Expr::\-Eval<Arg>}.}\label{p:impl:exprs:eval}
Nové objekty vyhodnocení se konstruují z~objektů třídy \id{Expr},
které musí být v~binárním či unárním tvaru, či v~jejich kombinaci.
Vytvoření objektu vyhodnocení s~přímými a nepřímými argumenty
se děje podle návrhu uvedeném
v~sekci \rf{p:design:arch:ode:exprs:eval}.

Klíče nepřímých argumentů jsou ukládány dynamicky bez~duplikací
v~pořadí prefixového průchodu výrazem.
Objekty třídy \id{Expr::\-Eval<Arg>} mají přetížen operátor
volání funkce, tj.~ \id{()}, s~pozičními parametry
s~hodnotami pro~nepřímé argumenty v~pořadí,
v~jakém byly uloženy jejich klíče.

Aby bylo pořadí parametrů vyhodnocení jednoznačné,
je možné mu je explicitně přiřadit při~konstrukci.
Pokud výraz obsahuje další klíče,
které dosud nejsou obsaženy,
jsou umístěny na~konec seznamu klíčů.
Mohou být obsaženy i~redundantní klíče,
které ve~výrazu obsaženy nejsou,
ale hodnota jim při~volání přiřazena být musí (ač libovolná).

V~unárních a binárních funkcích jsou přítomny všechny
rezervované funkce specifikované ve~vstupním jazyce
v~sekcích \rf{sss:design:spec:ilang:smt} a \rf{sss:design:spec:ilang:ode}.

\id{Expr::\-Eval<Arg>} obsahuje stromovou strukturu
objektů třídy \id{Eval::\-Oper}
reprezentující hierarchii vyhodnocení výrazů \id{Expr},
dále pole klíčů nepřímých argumentů a pole jejich hodnot.
Pole hodnot je nastaveno při~volání celého vyhodnocení jako funkce.

\id{Eval::\-Oper} představuje binární nebo unární funkci
s~argumenty tří možných typů:
\begin{itemize}
\item přímý argument~---~hodnota,
\item nepřímý argument~---~ukazatel do~pole hodnot klíčů,
\item podvýraz~---~ukazatel na~další objekt typu \id{Eval::\-Oper}.
\end{itemize}
Argumenty je nutné vyhodnotit až v~momentě volání funkce,
proto je použit princip \name{líného vyhodnocení}
(angl. \name{lazy evaluation})~---~argumenty jsou uloženy
jako nulární funkce, které jsou volány společně
s~voláním vyhodnocení objektu \id{Eval::\-Oper}.
Celý výraz \id{Expr::\-Eval<Arg>} je pak vyhodnocen
voláním kořenového objektu \id{Eval::\-Oper}.
\end{paragraph} %%\id{Expr::\-Eval<Arg>}.

%%%

\bigskip

Obě třídy jsou dostupné jako knihovny.
Také je možné je využít pomocí aplikace \appletFn{eval},
která vyhodnocuje vstupní výrazy,
které mohou obsahovat i~nepřímé argumenty.
\end{section} %%Realizace vyhodnocení výrazů

%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Thu 03 May 2018 04:01:22 PM CEST
\begin{section}{Implementace adaptéru \acr{smt} řešiče}\label{s:impl:smt}
\acr{smt} řešič je vhodné mít implementován flexibilně tak,
aby byla snadná jeho výměna, jak bylo diskutováno
v~sekci \rf{sss:design:arch:comp:smt}.
V~našem prototypu je řešič použit jako samostatná aplikace
s~textovým rozhraním podle \acr{smt}-LIB standardu verze~2.
Náš nástroj byl testován s~řešiči \acr{cvc}4 a z3
(viz.~sekce \rf{p:search:smt:solver:cvc4} a \rf{p:search:smt:solver:z3}).

\acr{smt} řešič reprezentuje třída \id{SMT::\-Solver},
která momentálně zahrnuje jak potřebné rozhraní, tak implementaci
související s~propojením textového rozhraní
se~synovským procesem \acr{smt} řešiče.
Výhledově by bylo vhodné rozhraní a implementaci oddělit,
tj.~třídu realizovat jako abstraktní,
která poskytuje operace obecně potřebné
k~řešení hybridních modelů
bez~ohledu na~konkrétní implementaci.
K~této třídě by byla poskytnuta
jako základní implementace odvozená třída
s~názvem např. \id{SMT::\-Smtlib},
která by operace delegovala přes textové rozhraní.
Bylo by však možné zvolit libovolnou jinou třídu,
která by např. operovala přímo s~programovým
rozhraním konkrétního \acr{smt} řešiče jako knihovny%
\footnote{Oba zmíněné \acr{smt} řešiče jsou implementovány v~jazyce C++.
Pokud by byly vyšší požadavky na~výkon nástroje,
bylo by možné je použít jako externí knihovnu s~C++ rozhraním.}.

Komponenta zahrnuje i~část zodpovědností,
které nesouvisí výhradně jen s~\acr{smt} řešičem,
ale jsou částečně spjaty s~kombinováním
řešiče s~diferenciálními rovnicemi.
Úlohou komponenty je zprostředkování \acr{smt} řešiče
pro~účely tohoto nástroje,
ne implementace nezávislého řešiče.

%%%

% Thu 03 May 2018 12:13:22 AM CEST
\begin{paragraph}{Identifikátory a hodnoty}\label{p:impl:smt:consts}
vstupních konstant jsou uloženy podle příkazů \id{int\--ode}
po~řádcích reprezentovaných strukturou \id{Const\_\-ids\_\-rows},
resp. \id{Const\_\-values\_\-rows}
(pole struktur \id{Const\_\-ids\_\-row},
resp. \id{Const\_\-values\_\-row})
pro každou \acr{ode} zvlášť.
Klíčem každého řádku identifikátorů je unikátní dvojice konstant
počáteční a koncové hodnoty nezávislého parametru \id{t}
(\id{Time\_\-const\_\-ids})
a hodnotou je \id{Const\_\-ids\_\-entries}
(pole struktur \id{Const\_\-ids\_\-entry}),
tj.~pole identifikátorů voleb derivací, počátečních hodnot
a vstupních parametrů každého jednotlivého systému,
který používá danou \acr{ode} v~daném okamžiku.
Použití pole umožňuje,
aby definovanou \acr{ode}
mohlo současně používat více systémů nezávisle,
např. v~případě kaskádní kompozice.
Struktury hodnot konstant jsou analogické.
\end{paragraph} %%Identifikátory a hodnoty konstant

%%%

% Wed 02 May 2018 10:52:48 PM CEST
\begin{paragraph}{\id{SMT::\-Solver}}\label{p:impl:smt:solver}
komunikuje s~\acr{smt} řešičem
pomocí operací definovaných \acr{smt}-LIB standardem
(viz.~sekce \rf{ss:search:smt:smtlib}),
nicméně jedná se o~obecný koncept operací
použitelný pro~různé implementace.
Každá uvedená operace je později rozvedena
včetně konkrétních použitých funkcí.
Realizace komunikace s~\acr{smt} řešičem
je uvedena až v~další části.

Kromě inicializace se jedná o~tyto operace:
\begin{itemize}
\item \id{(check\_\-sat)}~---~ověření splnitelnosti
   aktuálních asercí; výstupem je \id{sat} nebo \id{unsat}
   (nebo \id{unknown}, což je považováno za~chybu),
\item \id{(get\_\-value)}~---~získání hodnot
   konkrétních konstant, čemuž musí předcházet \id{check\_\-sat};
   výstupem jsou exaktní racionální čísla
   zpravidla ve~tvaru zlomků,
\item \id{(assert)}~---~přidání hodnot
   konstant spjatých s~aktuální fází výpočtu,
   jako podmínky nebo jako konfliktu,
   do~vrcholové úrovně zásobníku asercí,
\item \id{(push)} a \id{(pop)}~---~přidání či odebrání úrovně
   zásobníku asercí.
\end{itemize}

Získávání hodnot se vždy vztahuje pouze ke~vstupním konstantám
dané fáze. Pokud je výstup reprezentován výrazem,
je vyhodnocen pomocí objektu třídy \id{Expr::\-Eval}.
Tyto výrazy mohou mít teoreticky neomezenou přesnost,
což by vyžadovalo použití dynamických struktur
s~možností rozšiřující přesnosti.
Implementovány jsou ale jen statické typy
čísel s~plovoucí řádovou čárkou.
Problém nastává v~momentě,
kdy je potřeba takové číslo vypsat zpět ve~tvaru textu,
aby hodnota zůstala stejná.
Výpis řeším zjednodušeně pomocí fixního počtu desetinných míst
a ořezáním výsledných hodnot integrací na~ještě menší počet,
abych ponechal určitý prostor pro~případné navýšení desetinných míst
z~navazujících výpočtů hodnot konstant v~\acr{smt} řešiči.
Jedná se o~poměrně náchylné řešení,
lepším způsobem by bylo pamatování si načítaných textových reprezentací
hodnot konstant a jejich opětovné použití při~výpise.

Hodnoty dané fáze lze získat s~různou granularitou
od~nejvyšší po~nejnižší se~strukturami (či jejími částmi)
\id{Const\_\-}*\id{\_\-row}
pomocí funkcí \id{get\_\-step\_\-time\_\-values} počínaje
a \id{get\_\-step\_\-row\_\-values} konče.
Vždy však jen v~rámci jediné fáze i~\acr{ode}.

Aserce lze přidávat obecně pomocí funkce \id{assert},
ale praktičtější je použití funkce \id{assert\_\-step\_\-row},
která vytvoří formule s~veškerým obsahem struktur
\id{Const\_\-ids\_\-row}, \id{Const\_\-values\_\-row}
a výsledků integrace \acr{ode}.
Současně se provede operace \id{push}.
Vložené aserce jsou interně ukládány do~zásobníku,
aby bylo možné v~případě konfliktu
provést i~více návratů v~řadě.
Návrat provede prostřednictvím funkce
\id{assert\_\-last\_\-step\_\-row\_\-conflict}
operaci \id{pop} a přidá negaci
všech formulí se~vstupními konstantami fáze
ze~zásobníku (tj.~nevyžaduje žádné argumenty).

Rozhraní všech dosud zmíněných funkcí by mělo být nezávislé
na~konkrétní implementaci adaptéru \acr{smt} řešiče.
\end{paragraph} %%\id{SMT::\-Solver}

%%%

% Thu 03 May 2018 01:45:33 AM CEST
\begin{paragraph}{Komunikace s~\acr{smt} řešičem}\label{s:impl:smt:pipe}
je zprostředkována pomocí dvojice nepojmenovaných
\name{rour} (angl. \name{unnamed} či \name{anonymous pipes})
standardu \acr{posix}. Každá roura je jednosměrná
a je realizována v~paměti, tj.~mimo souborový systém.
Cílovou platformou tohoto řešení jsou systémy z~rodiny Unix,
v~rámci nichž by mělo fungovat standardně.

Nastavení komunikace provádí funkce \id{fork\_\-solver}
technikou fork-exec:
\begin{enumerate}
\item Vytvoření dvou rour: funkce \id{pipe}.
\item Vytvoření synovského procesu \acr{smt} řešiče: funkce \id{fork}.
\item Synovský proces přesměruje standardní vstup a výstup do~rour:
   funkce \id{dup2}.
\item Synovský proces se nahradí procesem \acr{smt} řešiče:
   funkce \id{execlp}.
\end{enumerate}

Poté rodičovský proces komunikuje prostřednictvím rour
přes~jejich získané deskriptory.
K~tomu slouží standardní funkce \id{write} a \id{read},
které pracují na~úrovni (binárních) bytů.
V~takové komunikaci je nutné mít dohodnutý nějaký protokol.
V~našem případě stačí jako zprávy přijímat
buď celistvé výrazy, pokud zpráva začíná závorkou,
nebo řádky.

Přijímání zpráv je implementováno sekvenčně po~jednom znaku,
aby bylo možné detekovat konec zprávy a nečíst žádné znaky navíc.
To je potenciálně neefektivní~---~lepším řešením by bylo
vyhradit samostatné vlákno pro~přijímaní bloků dat
poskytovaných jako jednotlivé zprávy.
Takové řešení by bylo náročnější na implementaci
a vyžadovalo by synchronizaci vláken.
\end{paragraph} %%Komunikace s~\acr{smt} řešičem

%%%

\end{section} %%Implementace adaptéru \acr{smt} řešiče

%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Wed 18 Apr 2018 03:30:27 PM CEST
\begin{section}{Implementace adaptéru \acr{ode} řešiče}\label{s:impl:ode}
V~sekci \rf{sss:design:arch:comp:ode} jsem rozebral
a odůvodnil návrh adaptéru pro~\acr{ode} řešiče
pomocí abstraktní třídy a odvozených tříd.
Podrobnější návrh komponenty \acr{ode} řešiče
jsem uvedl v~sekci \rf{ss:design:arch:ode}.
Jako primární řešiče jsem zvolil odeint a \acr{sundials},
které je možné použít jako externí knihovny
uvnitř odvozených tříd bez nutnosti dalších rozhraní,
jelikož jsou napsány v~jazyce C++, resp. v~C.
\acr{sundials} jsem ale nakonec neimplementoval,
jelikož nepodporuje některé funkcionality jazyka C++,
např. objektové zapouzdření,
přetěžování operátorů, šablonové programování.
Jeho nasazení by vyžadovalo ve~srovnání s~řešičem odeint
zavádění dodatečných tříd,
které by poskytovaly nějakou abstrakci nad~strukturami a funkcemi.
Proto jsem zvolil pouze řešič odeint.

Realizaci dynamických specifikací diferenciálních rovnic
z~textových řetězců a jejich vyhodnocení
jsem provedl prostřednictvím
vlastních tříd pro~výrazy a jejich vyhodnocení
podle avizovaného návrhu v~sekci \rf{sss:design:arch:ode:exprs}.
Realizace těchto tříd byla popsána v~sekci \rf{s:impl:exprs}.

Nejprve popíši abstraktní třídu \acr{ode} řešiče,
a poté odvozené třídy s~konkrétními implementacemi řešení \acr{ode}.

%%%%%%%%%%%%%

% Wed 18 Apr 2018 12:22:26 PM CEST
\begin{subsection}{Abstraktní třída řešiče}
\label{ss:impl:ode:solver}
Abstraktní třída \id{\acr{ode}::\-Solver}
poskytuje většinu potřebných funkcionalit
pro~obecný \acr{ode} řešič,
který přijímá vstupní specifikace diferenciálních
rovnic prostřednictvím objektů třídy \id{Expr}
a jejich vyhodnocení provádí interně
pomocí objektů třídy \id{Expr::\-Eval}.
Externí \acr{ode} řešič má na starosti
pouze samotné řešení rovnic na~základě
konkrétně definovaných výrazů,
ostatní operace deleguje na~abstraktní třídu.

Třída není závislá na~navrženém vstupním jazyce
a celkově na~kombinování s~\acr{smt} řešičem.
Měla by být použitelná jako obecný \acr{ode} řešič,
jen s~tím rozdílem, že je možné pro~každou \acr{ode}
nastavit více variant derivací.

%%%%%%%

% Wed 18 Apr 2018 10:30:07 AM CEST
\begin{subsubsection}{Specifikace rovnic}\label{sss:impl:ode:solver:spec}
Základní forma inicializace řešiče se provádí
z~páru objektů typu \id{\acr{ode}::\-Odes\_\-spec}
a \id{\acr{ode}::\-Param\_\-keyss}.

\id{Odes\_\-spec} reprezentuje množinu
struktur typu \id{Ode\_\-spec},
které reprezentují všechny varianty derivací
pro~danou funkci~---~objekty typu \id{Dt\_\-spec}
(alias pro~\id{Expr}).
Pro~každý objekt \id{Dt\_\-spec}
je sestaveno vyhodnocení typu \id{Dt\_\-eval}
(alias pro~\id{Expr::\-Eval}).

\id{Param\_\-keyss} obsahuje množinu
struktur \id{Param\_\-keys},
které reprezentují pole klíčů
pro~korespondující vyhodnocení \id{Dt\_\-eval}.
Pole klíčů je vždy shodné pro~všechny \id{Dt\_\-spec}
(resp. \id{Dt\_\-eval})
v~rámci \id{Ode\_\-spec}, tj.~\acr{ode}.

Standardně tedy každá dvojice z~množin
\id{Odes\_\-spec} a \id{Param\_\-keyss}
představuje jednu \acr{ode}.
Každá rovnice je pak řešena nezávisle na~ostatních
a také klíče má nezávislé.
Tento stav nazývám jako \name{nezávislý}.

Nezávislost rovnic může být výhodná, ale také ne.
Pokud kterákoliv rovnice obsahuje jako argument
funkci některé \acr{ode}
(a má za ni být považována),
výsledek výpočtu bude chybný,
neboť tato funkce bude předložena jako konstanta
a nebude se měnit současně s~právě řešenou funkcí \acr{ode},
protože každá \acr{ode} je řešena nezávisle.

%%%

% Thu 03 May 2018 01:54:49 AM CEST
\begin{paragraph}{Sjednocení klíčů.}\label{p:impl:ode:solver:spec:unif}
Pokud je potřeba všechny \acr{ode} řešit synchronně
(myšleno synchronizovaně po~krocích integrace),
rovnice se na sobě stávají závislými.
Stačí jediná taková závislost,
aby byl jako závislý automaticky chápán celý vstup.
Takový stav nazývám jako \name{sjednocený}.
Důvodem je, že zejména z~implementačních důvodů
je vhodné mít pro~všechny \acr{ode}
sjednocené pole klíčů
a každá \acr{ode} při~svém vyhodnocení
dosazuje aktuální hodnoty závisle
na~integracích ostatních rovnic.

Podle tvaru vstupu je možné implicitně rozpoznat,
zda se jedná o~sjednocený stav,
konkrétně podle \id{Param\_\-keyss}~---~pokud obsahuje
jen jedinou položku \id{Param\_\-keys},
nebo pokud jsou všechny položky identické.
Pak je první položka interpretována jako sjednocené klíče
pro~všechny \acr{ode}.

Sjednocení klíčů lze také explicitně vynutit,
ale to je možné pouze při konstrukci řešiče.
V~tomto případě se vytvoří mapování nesjednocených klíčů
na~vytvořené sjednocené pomocí číselných indexů,
které je přístupné z~funkce \id{cunif\_\-param\_\-keyss\_\-ids}.
Druhá strana si tak může pomocí tohoto přeorganizovat
své specifikace rovnic a nadále používat
pouze sjednocených klíčů.
To je sice efektivní varianta, ale relativně nepohodlná.
Proto je umožněno i~nadále při řešení
rovnic poskytovat vstupní hodnoty v~nesjednoceném tvaru,
které řešič interně sjednotí sám aplikací mapování.
\end{paragraph} %%Sjednocení klíčů.

%%%

\bigskip

Každé pole klíčů musí splňovat následující pravidla:
\begin{itemize}
\item Pokud je přítomen klíč nezávislé proměnné \id{t},
   musí být umístěn na~poslední pozici.
\item Musí být obsažen alespoň jeden klíč různý od~\id{t},
   který je interpretován jako klíč integrované funkce.
   Jeho pozice musí být následující:
   \begin{itemize}
   \item nezávislý stav $\rightarrow$ první pozice,
   \item sjednocený stav  $\rightarrow$ pozice na~diagonále,
      tj.~pozice klíče odpovídá pozici \id{Ode\_\-spec}
      v~rámci \id{Odes\_\-spec}.
   \end{itemize}
\end{itemize}

Jinou formou inicializace řešiče
je pomocí textového vstupu
(\id{std::\-string} nebo \id{std::\-istream}),
které jsou delegovány na konstrukci pomocí \id{Expr}.
Vstupní řetězec je formátován jako dvojice výrazů,
které mají strukturně shodný tvar
s~dvojicí \id{\acr{ode}::\-Odes\_\-spec}
a \id{\acr{ode}::\-Param\_\-keyss},
s~jedinou výjimkou: pokud je explicitní požadavek
na~sjednocení klíčů, je navíc mezi dvojici výrazů
nutné vložit token \id{*}.
\end{subsubsection} %%Specifikace rovnic

%%%%%%%

% Thu 03 May 2018 02:04:50 AM CEST
\begin{subsubsection}{Řešení rovnic}\label{sss:impl:ode:solver:solve}
Podobně jako u~specifikací rovnic
je možné provést výpočet rovnic
buď přímo s~parametry požadovaných typů,
nebo z~textového vstupu.
Základní vstup tvoří dvojice objektů
typu \id{ODE::\-Dt\_\-ids} a \id{Solver::\-Contexts}.

\id{Dt\_\-ids} reprezentuje pole indexů
zvolených variant derivací \id{Dt\_\-spec}
pro toto řešení.
Tento parametr není závislý na~stavu řešiče,
zda je či není sjednocený.

\id{Contexts} je pole objektů typu \id{Context}.
Pokud je voláno řešení rovnic jako sjednocených,
je nutné předat jen jediný \id{Context},
jelikož mají všechny \acr{ode} sjednocené klíče
a tedy i~hodnoty jim přiřazené.
Lze však použít i~obecnou funkci řešení rovnic
(přijímající \id{\id{Contexts}}),
která, v~případě, že se řešič nachází ve~sjednoceném stavu,
se pokusí aplikovat interní mapování
nesjednocených pozic na~sjednocené
(jak bylo popsáno v~části o~sjednocených klíčích).
(Nebo lze předat \id{Contexts} se shodnými položkami.)

%%%

% Wed 18 Apr 2018 10:54:33 AM CEST
\begin{paragraph}{\id{Context}}\label{p:impl:ode:solver:solve:ctx}
je třída obalující počáteční a koncové podmínky
řešení \acr{ode}.
Počátečními podmínkami
jsou počáteční hodnoty všech parametrů \acr{ode}
a nezávislé proměnné \id{t}
(viz.~vztah \rfeq{ode}).
Jako koncové podmínky se (zatím)
fixně považuje jen koncová hodnota
nezávislé proměnné \id{t}.

Počáteční hodnota \id{t} se vždy uvádí
odděleně od~všech ostatních parametrů
a nesmí být v~nich duplicitně obsažena.
V~případě, že je daná \acr{ode}
závislá na~\id{t},
je její hodnota přidávána automaticky
uvnitř řešiče \id{Solver}.
\end{paragraph} %%\id{Context}

%%%

\bigskip

Řešení rovnic se provádí různými členskými funkcemi
\id{Solver::\-solve}*
závisle na~předávaných parametrech
a na~požadavek sjednocení klíčů.
Pro~řešení jen jediné \acr{ode}
slouží \id{solve\_\-ode}.
Pro~řešení všech rovnic
slouží \id{solve\_\-odes},
která samostatně detekuje,
zda zvolit sjednocený výpočet.
Pro~explicitní požadavek na~sjednocený výpočet
slouží \id{solve\_\-unif\_\-odes},
která selže pokud klíče rovnic nejsou sjednoceny.
Poslední možností je funkce \id{solve},
která přijímá textový vstup
ve~tvaru dvojice výrazů
se~stejnou strukturou jako mají typy
\id{Dt\_\-ids} a \id{Context}(\id{s}).
Pokud je v~druhém výrazu specifikován jen jeden \id{Context},
jsou rovnice řešeny sjednoceně.
\end{subsubsection} %%Řešení rovnic

%%%%%%%

% Tue 24 Apr 2018 05:03:23 PM CEST
\begin{subsubsection}{Další operace}\label{sss:impl:ode:solver:op}
Dalšími operacemi obsaženými ve~veřejném rozhraní třídy jsou:
\begin{itemize}
\item \id{set\_\-step\_\-size}~---~nastaví (počáteční)
   velikost kroku integrací,
\item \id{add\_\-ode\_\-spec}~---~přidá specifikaci další \acr{ode}
   s~klíči parametrů,
\item \id{is\_\-unified}~---~vrátí příznak, zda je řešič ve~sjednoceném stavu;
   pokud není a dosud to nebylo ověřeno,
   je ověřeno, zda skutečně sjednocený není,
\item \id{cparam\_\-keyss}~---~zkonstruuje objekt typu
   \id{\acr{ode}::\-Param\_\-keyss} s~klíči parametrů všech \acr{ode} zvlášť,
\item \id{cunif\_\-param\_\-keys}~---~vrátí referenci na~sjednocené klíče
   všech \acr{ode} typu \id{\acr{ode}::\-Param\_\-keys};
   selže, pokud \id{is\_\-unified} není pravdivé,
\item \id{ctrajects}, \id{cunif\_\-traject}~---~vrátí referenci
   na~objekt typu \id{Solver::\-Traject}(\id{s}) (viz. dále),
\item lidsky čitelný výpis všech obsažených rovnic řešiče.
\end{itemize}
\end{subsubsection} %%Rozhraní řešiče

%%%

% Tue 24 Apr 2018 05:03:15 PM CEST
\begin{paragraph}{\id{Traject}}\label{p:impl:ode:solver:op:traj}
je třída, která shromažďuje průběh (\name{trajektorii})
integrace jedné \acr{ode},
tj.~obsahuje pole hodnot nezávislé proměnné \id{t}
a hodnot všech parametrů \acr{ode}.
Tyto jsou platné jen v~rámci jednoho
řešení rovnic~---~hodnoty jsou při~každém volání funkce \id{solve}*
z~kapacitních důvodů resetovány.

\id{Trajects} je pole objektů \id{Traject} o~velikosti
počtu \acr{ode} řešiče.
\end{paragraph} %%\id{Traject}

%%%

%%%%%%%

\bigskip

Třída \id{Solver} (a její odvozené třídy) je dostupná jako knihovna.
Také je možné ji využít jako aplikaci,
k~čemuž poskytuje šablonovou třídu \id{Solver::\-Run<S>},
kde \id{S} je konkrétní odvozená třída s~implementací integrace.
Aplikace používá inicializaci a řešení rovnic
s~textovými vstupy a chová se jako filtr:
na~inicializaci odpoví výpisem
\id{cparam\_\-keyss} nebo \id{cunif\_\-param\_\-keys}
a na každé řešení (\id{solve}) výpisem výsledku.
Je-li specifikován výstupní soubor,
jsou do~něj průběžně ukládány
výpisy objektů \id{Traject}(\id{s}).
\end{subsection} %%Abstraktní třída řešiče

%%%%%%%%%%%%%

% Wed 18 Apr 2018 02:08:18 PM CEST
\begin{subsection}{Odvozené třídy}
\label{ss:impl:ode:derived}
Třídy odvozené od~\id{\acr{ode}::\-Solver}
musí dodat implementace integrace rovnic.
\id{Solver} obsahuje tři virtuální neveřejné metody:
\id{eval\_\-ode}, \id{eval\_\-odes}
a \id{eval\_\-unif\_\-odes}.
\id{eval\_\-odes} ve~výchozím tvaru
jen vyplní pole výsledků pomocí
jednotlivých volání \id{eval\_\-ode};
zbylé dvě funkce nejsou implementovány.
Odvozená třída tedy musí definovat
jak nezávislé integrování jednotlivých rovnic,
tak synchronní integraci všech rovnic,
mají-li sjednocené klíče.

%%%

% Wed 18 Apr 2018 02:17:57 PM CEST
\begin{paragraph}{\id{Euler}}
\label{p:impl:ode:derived:euler}
poskytuje triviální implementaci integrace
pomocí explicitní Eulerovy metody
(viz.~vztah \rfeq{ode:explicit}).
Tato třída slouží zejména k~demonstračním a testovacím účelům,
jelikož je Eulerova metoda nepřesná.
Třída není závislá na~externích knihovnách.

Spustitelná aplikace třídy je umístěna v~souboru \appletFn{euler}.
\end{paragraph} %%Eulerova metoda

%%%

% Wed 18 Apr 2018 02:28:29 PM CEST
\begin{paragraph}{\id{Odeint}}
\label{p:impl:ode:derived:odeint}
využívá některých funkcí \acr{ode} řešiče odeint
(viz.~sekce \rf{p:search:ode:classic:solver:odeint}).
Odeint je realizován výhradně uvnitř hlavičkových souborů
v~rámci C++ knihoven Boost,
které třída \id{Odeint} částečně zahrnuje.
Zatím je použita pouze výchozí funkce
\id{odeint::\-integrate},
které jsou z~třídy \id{Solver}
v~každém kroku integrace poskytovány vypočtené
hodnoty z~objektů typu \id{Dt\_\-eval}.
Funkce používá metodu Dormand--Prince 5,
což je explicitní adaptivní Runge--Kutta metoda
(viz.~sekce \rf{sss:search:ode:classic:rk}).

Implementace třídy \id{Odeint} je triviální,
neboť řešič odeint nevyžaduje žádnou
inicializaci a pouze se volá funkce \id{integrate}
s~počátečními a koncovými hodnotami
a s~funkčními objekty.

Spustitelná aplikace třídy je umístěna v~souboru \appletFn{odeint}.
\end{paragraph} %%odeint

%%%

\end{subsection} %%Odvozené třídy

%%%%%%%%%%%%%

\end{section} %%Implementace adaptéru \acr{ode} řešiče

%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Thu 03 May 2018 01:45:29 PM CEST
\begin{section}{Implementace zpracování vstupu}\label{s:impl:parse}
Návrh zpracování vstupu je uveden v~sekci \rf{ss:design:arch:parse}.
Pro~tyto účely byla vytvořena třída \id{Parser}.
V~první řadě je vstup předzpracován (viz. další sekce).
Poté je ke~zpracování vstupu použit objekt třídy \id{Expr},
který by měl jako přímé potomky obsahovat pouze další výrazy \id{Expr},
jelikož v~kořenové úrovni nejsou tokeny povoleny
(po~předzpracování).
Výrazy v~první úrovni představují příkazy,
které jsou procházeny rekurzivně,
pokud se nějak dotýkají \acr{ode} řešiče.
Ostatní výrazy, zejména ty týkající se výhradně \acr{smt} řešiče,
jsou ponechány částečně nebo zcela nezpracovány.

Hlavním úkolem je zpracování příkazů \id{define\--dt} a \id{int\--ode},
z~nichž je nutné shromáždit specifikace všech \acr{ode}
a názvy konstant vstupující do \id{int\--ode} jako vstupní argumenty.
K~tomu slouží struktura \id{Odes},
což je pole struktur \id{Ode}.
\id{Ode} je pětice těchto struktur:
\begin{enumerate}
\item \id{Ode\_\-key}~---~klíč (identifikátor) \acr{ode},
\item \id{Dt\_\-keys}~---~pole klíčů (identifikátorů) variant derivací,
\item \id{Ode\_\-spec}~---~pole specifikací rovnic derivací
   (viz.~sekce \rf{sss:impl:ode:solver:spec})
   ve~stejném pořadí, jako \id{Dt\_\-keys},
\item \id{Param\_\-keys}~---~společné klíče nepřímých argumentů
   pro~všechny rovnice v~\id{Ode\_\-spec};
   není kontrolováno, zda jsou klíče napříč všemi rovnicemi
   dané \acr{ode} shodné,
\item \id{Const\_\-ids\_\-rows}~---~pole identifikátorů
   vstupních konstant jednoho příkazu \id{int\--ode},
   jak bylo diskutováno v~sekci \rf{p:impl:smt:consts}.
\end{enumerate}
S~výjimkou \id{Const\_\-ids\_\-rows}
pochází všechny ostatní hodnoty
z~příkazů \id{define\--dt}.
Položky \id{Const\_\-ids\_\-row} jsou v~rámci
příslušného klíče \id{Ode\_\-key} ukládány v~pořadí,
v~jakém jsou ve~vstupu čteny příkazy \id{int\--ode}.
(Určení fází podle konstant nezávislých proměnných \id{t}
není zodpovědností zpracování vstupu.)

Hodnoty klíčů, včetně těch z~\id{Const\_\-ids\_\-rows},
jsou také duplicitně ukládány
do~vyhledávacích stromových struktur,
aby byly rychle dohledatelné.

Příkazy, které jsou zpracovány, jsou:
\begin{itemize}
\item \id{set\--logic}~---~povoleny jsou všechny logiky
   zmíněné v~sekci \rf{p:design:spec:ilang:smt:logic},
   a to \hl{včetně} logik bez~volných funkčních symbolů,
\item \id{define\--dt}~---~uloží se specifikace varianty
   derivace dané \acr{ode}; při~prvním výskytu
   klíče \id{Ode\_\-key} dojde k~deklaraci \acr{ode},
   tj.~uložení klíče \id{Ode\_\-key}
   a klíčů nepřímých argumentů \id{Param\_\-keys}
   společných pro~všechny varianty derivací,
\item \id{define\--ode\--step},
\item \id{int\--ode}~---~ze~vstupních argumentů příkazu
   se vytvoří jedna položka \id{Const\_\-ids\_\-row}
   pro~odpovídající klíč \id{Ode\_\-key},
   která je vložena na~konec pole \id{Const\_\-ids\_\-rows};
   příkaz je do~\acr{smt} vstupu transformován jako \hl{konstanta}
   (čemuž předchází její deklarace);
   vstupní argumenty příkazu \hl{musí být globální identifikátory}.
\end{itemize}

Dále je zpracován každý token.
Dosud se provádí jen transformace
záporných numerických literálů na~výrazy.

Komponentu je možné použít jako knihovnu,
nebo pomocí textové aplikace \appletFn{parser},
která na~standardní výstup vypíše
vstup pro~\acr{smt} řešič
a na~chybový výstup
vstup pro~\acr{ode} řešič.
Pomocí přepínače \id{-E}
lze také provést pouze předzpracování vstupu
a výsledek vypsat na~standardní výstup.
\end{section} %%Implementace zpracování vstupu

%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Sat 28 Apr 2018 06:46:55 PM CEST
\begin{section}{Implementace předzpracování vstupu}\label{s:impl:preprocess}
Realizace předzpracování vstupu navazuje na~návrh
uvedený v~sekci \rf{ss:design:arch:preprocess}.
Výsledkem je třída \id{Preprocess},
která je implementována uvnitř třídy \id{Expr}
(viz.~sekce \rf{p:impl:exprs:expr}),
jelikož lze předzpracování použít pro~libovolný textový prefixový vstup
obsahující komentáře a makra stejné se~vstupním jazykem
(viz.~sekce \rf{ss:design:spec:ilang}),
a protože je celé zpracování silně vázáno na~interní objekt třídy \id{Expr}.
Samotná třída \id{Expr} je však nezávislá
na~implementaci třídy \id{Preprocess}.

Globální a lokální makra jsou uložena zvlášť
ve~vyhledávacích stromech
\id{Macros\_\-map} a \id{Lets\_\-map}.
\id{Macros\_\-map} obsahuje jako hodnoty
dvojice \id{Macro\_\-param\_\-keys}
(názvy parametrů makra)
a \id{Macro\_\-body}
(alias pro~\id{Expr}).
\id{Lets\_\-map} obsahuje jako hodnoty
zásobníky objektů \id{Let\_\-body}
(alias pro~\id{Macro\_\-body}).

Příkazové makro \id{\#for} je zatím implementováno
jen ve~formě celočíselného vzestupného rozsahu
řídící proměnné s~jednotkovým krokem
(varianta \rf{i:macro:for:int}).
Pro~ostatní případy lze využít rekurzivních volání uživatelských maker.

%%%

% Wed 25 Apr 2018 12:17:59 AM CEST
\begin{paragraph}{Aritmetické expanze}
\label{s:impl:preprocess:arith}
výrazů jsou implementovány pomocí třídy \id{Expr::\-Eval}
(viz.~sekce \rf{p:impl:exprs:eval}).
Ve~skutečnosti se jedná o~expanzi tokenu,
jelikož výrazy jsou předcházeny tokenem \id{\$}.
Makra \id{\#if} a \id{\#for} používají
ke~svému vyhodnocení
aritmetickou interpretaci tokenů,
k~čemuž je použita buď aritmetická expanze výrazu,
nebo, v~případě, že se jedná o~literál,
získání aritmetické hodnoty z~objektu třídy
\id{Expr\_\-token} pomocí \id{get\_\-value}
(viz.~sekce \rf{p:impl:exprs:expr}).

Vzhledem k~tomu, že C++ není dynamicky typovaný jazyk,
a požadovaný typ argumentů je zjišťován dynamicky z~textového vstupu,
bylo nutné programově odlišit případy použití
reálných a celých čísel.
K~reprezentaci hodnoty jsem použil
konstrukt \id{union},
který umožňuje paměťovou oblast
interpretovat jako různé typy (ačkoli pouze staticky).
\end{paragraph} %%Aritmetické expanze

%%%

% Wed 25 Apr 2018 12:18:02 AM CEST
\begin{paragraph}{Zpracování maker v~rámci tokenu}
\label{s:impl:preprocess:in_token}
je provedeno tak, že se token rozdělí na~části
podle znaků \id{\#}%
\footnote{Každá část může obsahovat nejvýše jeden znak \id{\#}
právě na~první pozici.}.
Pokud jsou obsaženy alespoň dvě takové části,
přidá se každá do~výrazu
jako nový token a zpracuje se zvlášť,
a poté je výsledek všech expanzí spojen do~právě jednoho tokenu,
který může být i~prázdný.
Rezervovaná makra volaná jako \id{\#} a \id{\#\#}
jsou implementována takto:
\begin{itemize}
\item je přidáno globální makro s~prázdným názvem,
\item při~rozdělení tokenu na~části
   je pro~každou nalezenou část (kromě té poslední),
   která je rovna jedinému znaku \id{\#},
   odmazán první znak z~následující části,
   který nutně musí být roven \id{\#}.
   Tím je simulováno volání makra \id{\#\#}.
\end{itemize}
\end{paragraph} %%Zpracování maker v~rámci tokenu

%%%

% Sat 28 Apr 2018 09:16:38 PM CEST
\begin{paragraph}{Escape sekvence}\label{s:impl:preprocess:escape}
\id{\textbackslash\#}
je implementována tak,
že se do~části tokenu, která začíná znakem \id{\#},
a která následuje za~částí,
která končí znakem \id{\textbackslash},
přidá další znak \id{\#} na~začátek.
Pokud je následně při~zpracování expanze makra
toto detekováno, odmaže se první znak
a expanze není provedena.
\end{paragraph} %%Escape sekvence

%%%

\bigskip

Komponentu lze použít jako knihovnu
nebo pomocí aplikace \appletFn{parser}
(viz.~sekce \rf{s:impl:parse}).
\end{section} %%Implementace předzpracování vstupu


%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Thu 03 May 2018 04:15:08 PM CEST
\begin{section}{Realizace řídící komponenty}\label{s:impl:center}
Úlohou centrální komponenty je řídit \acr{smt} a \acr{ode} řešič
(sekce \rf{s:impl:smt} a \rf{s:impl:ode})
a průběh kombinovaného výpočtu.
Postupoval jsem dle návrhu komponenty
uvedeném v~sekci \rf{sss:design:arch:comp:center}
a návrhu řídícího algoritmu ze~sekce \rf{ss:design:arch:alg}.
Komponenta je však realizována jako \hl{prototyp},
některé funkcionality chybí
nebo jsou zjednodušeny.

Řídící komponenta je umístěna v~šablonové třídě \id{Solver<OSolver>},
která komunikuje s~oběma řešiči
výhradně pomocí programového rozhraní
vlastních tříd \id{SMT::\-Solver} a \id{ODE::\-Solver};
teprve na~nich leží zodpovědnost
konkrétní realizace propojení s~řešiči třetích stran.
\id{ODE::\-Solver} slouží jako rozhraní,
konkrétní implementaci obsahuje
zvolená odvozená třída \id{OSolver}.
Výhledově by bylo lépe použít také třídu \acr{smt}
řešiče jako rozhraní s~volitelnou implementací
(jak bylo uvedeno v~sekci \rf{s:impl:smt})
jako šablonového parametru.

Oproti navrženému základnímu řídícímu algoritmu
byla aplikována následující zjednodušení:
\begin{itemize}
\item Fáze výpočtu jsou brány v~pořadí,
   ve~kterém se nachází příkazy \id{int\--ode};
   je zodpovědnost uživatele,
   aby hodnoty vstupních konstant nezávislé proměnné \id{t}
   tvořily neklesající posloupnost.
   Počet příkazů \id{int\--ode} na~jednu fázi,
   včetně shodných \acr{ode},
   však není omezen.
\item Rozložení všech fází musí navíc být pro~všechny \acr{ode} \hl{stejné}.
   To prakticky znamená to, že všechny příkazy \id{int\--ode}
   musí používat pouze jednu společnou sadu konstant
   nezávislé proměnné \id{t}.
\item Podle pořadí výskytu se také sestavují soustavy \acr{ode}:
   pro~každý příkaz \id{int\--ode}
   se v~rámci dané \acr{ode} a fáze
   vloží soubor vstupních identifikátorů na~poslední pozici řádku%
   \footnote{Ve~struktuře \id{Const\_\-ids\_\-rows}
   v~řádku s~klíčem \id{Time\_\-const\_\-ids}
   na~konec pole \id{Const\_\-ids\_\-entries},
   viz.~\rf{p:impl:smt:consts}.};
   soustavy \acr{ode} se pak berou podle shodných pozic
   v~těchto řádcích. Soustavy \acr{ode}
   jsou integrovány sjednoceně,
   ale navzájem odděleně
   (více je uvedeno v~samostatné části).
\end{itemize}

Výpočet se provádí funkcí \id{solve},
která zavolá funkci \id{do\_\-step}
pro~počáteční fázi
a počítá se dokud není dosaženo poslední fáze
(pak bylo nalezeno splňující ohodnocení vstupu),
nebo dokud není proveden návrat z~počáteční fáze
(pak vstup není splnitelný).

Interakce s~oběma řešiči
spočívá pouze v~sestavení či přeuspořádání
požadovaných vstupních struktur.

%%%

% Thu 03 May 2018 05:48:25 PM CEST
\begin{paragraph}{Inicializace \acr{ode} řešiče}
\label{p:impl:center:ode_init}
spočívá v~zaslání specifikací rovnic a klíčů nepřímých argumentů
v~nezávislém tvaru. S~výhodou je využito toho,
že \id{ODE::\-Solver} umí explicitně
vynutit sjednocení klíčů
a také později sám provádět mapování
pozic hodnot nezávislých kontextů
do~sjednoceného.
Řídící komponenta tedy kromě příznaku
v~konstruktoru řešiče,
který vyžaduje sjednocení,
je zcela oproštěna od~této skutečnosti
a pracuje s~rovnicemi jako s~nezávislými.
\end{paragraph} %%Realizace řídící komponenty

%%%

% Fri 04 May 2018 10:09:41 PM CEST
\begin{paragraph}{Řešení dílčích \acr{ode}.}
Řešič \id{ODE::\-Solver} je vždy
používán ve~sjednoceném stavu
v~rámci každé soustavy \acr{ode}.
Soustavy nemohou být navzájem závislé
jinak, než jako konstantní vstupy%
\footnote{Pokud je nutné synchronně integrovat více soustav současně,
je nutné provést duplikaci definic \acr{ode}
(příkazy \id{define\--dt})
s~odlišnými názvy jejich klíčů
(název identifikátoru \acr{ode},
případně i~parametrů).}.

Soustavy často reprezentují nějakou kompozici více systémů,
které mají shodné specifikace rovnic,
ale různé vstupní a výstupní konstanty.
Vznikají pouze v~případech,
kdy je příkaz \id{int\--ode} použit
vícekrát pro~stejný identifikátor \acr{ode}
a současně stejnou fázi,
tj.~dvojici identifikátorů nezávislé proměnné \id{t}.

Soustavy \acr{ode} nejsou uloženy souvisle,
neboť prvním kritériem rozdělení
těchto dat ve~zpracování vstupu
je identifikátor \acr{ode}, poté fáze a až následně soustava,
tj.~pořadí v~řádku.
Ve~vnější smyčce se iteruje přes soustavy
a ve~vnitřní přes dílčí \acr{ode}.
Tím se pro~každou soustavu vypočte výsledný vektor integrace
(výstupní hodnoty všech \acr{ode} dané soustavy).

\acr{smt} řešič ale přijímá hodnoty
organizované nejprve podle \acr{ode} a poté podle soustav.
Je tedy ještě nutné provést transpozici matice výsledků.
\end{paragraph} %%Řešení dílčích \acr{ode}.

%%%

\bigskip

Celý nástroj lze použít jako knihovnu,
nebo jako aplikaci.
Aktuální podoba aplikace je umístěna v~souboru
\binFn{sos\_\-odeint}, která pro~řešení \acr{ode}
používá odeint (třída \id{ODE::\-Odeint}).
\end{section} %%Realizace řídící komponenty

%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Fri 04 May 2018 10:42:23 PM CEST
\begin{section}{Seznam dalších úkolů}\label{s:impl:todo}
\begin{itemize}
\item Doplnit dokumentaci zdrojových kódů.
\item Implementace řídícího makra \id{\#for} ve~všech variantách.
\item Kontrola příkazů \id{define\--dt}, zda mají všechny
   v~rámci dané \acr{ode} shodné klíče nepřímých argumentů.
\item Lepší zacházení s~výstupními textovými hodnotami z~\acr{smt}
   řešiče, pokud se do~něj následně posílají zpět jako podmínky.
\item Oddělení rozhraní od~implementace ve~třídě \id{SMT::\-Solver};
   odvozenou třídu zavést jako druhý šablonový parametr třídy \id{Solver}.
\item Vyhrazení samostatného vlákna pro~příjem
   odchozích zpráv \acr{smt} řešiče po~blocích.
\item Realizace odvozené třídy pro~implementaci
   \acr{ode} řešiče \acr{sundials}.
\item Umožnit obecnější nastavení fází výpočtu v~řídící komponentě.
\item Umožnit obecnější koncové podmínky diferenciálních rovnic,
   např. podle koncové hodnoty funkce,
   nebo přímo umožnit průběžnou kontrolu obecných invariant.
\item Implementace efektivnějšího algoritmu
   redukujícího počet operací ověření splnitelnosti vstupu.
\item Implementace výstupu \id{unknown} pro~případy,
   kdy výpočet pravděpodobně nikdy neskončí
   (např. pro~intervalové počáteční podmínky).
\item V~případě poptávky umožnit i~synchronní
   vzájemnou závislost soustav \acr{ode}
   bez~nutnosti redundantních
   specifikací diferenciálních rovnic,
   které se liší jen v~identifikátoru \acr{ode}%
   \footnote{Možným návrhem budiž zavedení příkazu
   \id{declare\--ode} se zavedením identifikátoru \acr{ode}
   a přiřazením identifikátorů variant derivací,
   které by se mohly objevovat vícekrát napříč těmito příkazy.}.
\end{itemize}
\end{section} %%Seznam dalších úkolů

%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Sat 05 May 2018 12:41:59 PM CEST
\chapter{Experimentální část}\label{ch:exp}
V~této kapitole aplikuji realizovaný koncept
na~vybraných praktických úlohách
a srovnám výsledný výkon s~řešičem dReal.
Nejprve uvedu metodiku,
dle které jsem při~měření postupoval,
a poté jednotlivé příklady.
Na~závěr uvedu některé případy užití,
na~které by bylo možné řešič použít.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Sat 05 May 2018 01:11:05 PM CEST
\begin{section}{Metodika}\label{s:exp:method}
U~každého příkladu jsem měřil jednak celkový čas
našeho postupu a řešiče dReal pro~srovnání,
a dále jsem zvlášť u~našeho kódu prováděl
profilaci částí výpočtu spadajících
jen do~\acr{smt} a do~\acr{ode} řešiče
(resp. jejich adaptérů).

Je záhodno zdůraznit, že srovnání
s~řešičem dReal není přesné,
protože dReal je robustnější a poskytuje
relevantnější výsledky, které až na~zvolenou odchylku
přesně dodržují všechny invarianty po celou dobu integrace.
(Je však otázkou, nakolik je to v~daném příkladě užitečné.)
Náš koncept pracuje pouze na~principu diskretizace času,
a ke~kontrole invariant dochází jen v~těchto bodech.
Počáteční podmínky jsem ale nastavoval stejně (není-li řečeno jinak),
tj.~i~v~řešiči dReal jsem intervalové podmínky jen aproximoval,
aby bylo srovnání v~tomto ohledu relevantní.

Dále je potřeba, aby oba řešiče počítaly
podobný rozsah nezávislé proměnné \id{t}.
To jsem řešil tak, že jsem dReal spustil
po~určitý počet kroků (tj.~kroky \acr{bmc}, změny diskrétního stavu),
a podle koncové hodnoty proměnné \id{t}
nastavil vstup do~našeho řešiče.

dReal jsem spouštěl jen se základními parametry,
nestudoval jsem možnosti použití různých tamních heuristik
(např. \acr{bmc} heuristika).
Dále v~případech, kdy jsem převáděl příklady modelů
do~formátu dReal, nemohu zaručit,
že jsem učinil natolik efektivně,
jak by mohla učinit osoba
podrobněji znalá tohoto programu.

%%%%%%%%%%%%%

% Tue 08 May 2018 10:47:48 AM CEST
\begin{subsection}{Měřicí prostředky}\label{ss:exp:method:resources}
Všechna měření byla provedena
na~\acr{cpu}
Intel\reg Core\textsuperscript{TM}
i7-4702MQ o~taktovací frekvenci $2{,}2$ GHz
na~\acr{os} Arch Linux.
Paralelismu nebylo využito.

Vlastní projekt jsem přeložil
programem \id{g++}
s~optimalizací \id{-O1}.

K~měření celkového času pro~srovnání s~řešičem dReal
byl použit příkaz \id{time}
(který zahrnuje i~systémové režie spojené s~procesem).

K~profilaci vlastního kódu byly použity
funkce \id{omp\_\-get\_\-wtime}
standardu \acr{omp}.

Z~\acr{smt} řešičů jsem používal řešič z3,
který si počínal efektivněji než \acr{cvc}4.
\end{subsection} %%Měřicí prostředky

%%%%%%%%%%%%%

\end{section} %%Metodika

%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Sat 05 May 2018 08:57:44 PM CEST
\begin{section}{Praktické úlohy}\label{s:exp:examples}
V~této sekci rozeberu jednotlivé úlohy,
které jsem spouštěl jak v~našem řešiči,
tak v~řešiči dReal,
a výsledky porovnal.
První uvedenou úlohu rozeberu podrobněji,
neboť prozradí některá první zjištění,
která se budou v~dalších úlohách opakovat.

%%%%%%%%%%%%%

% Sat 05 May 2018 04:38:44 PM CEST
\begin{subsection}{Skákající míč}\label{ss:exp:examples:ball}
Jedná se o~jednoduchý demonstrační příklad,
který vyžaduje dodržení invariantu hodnoty integrované funkce.
Příklad je převzat z~dReal,
s~jedinou úpravou~---~aproximace intervalových počátečních podmínek.

Diskrétní stav modelu je triviální:
obsahuje jedinou Booleovskou proměnnou,
která indikuje, zda míč padá k~zemi, nebo se odráží vzhůru.

Spojitý stav je reprezentován proměnnými
\id{x} (výška, resp. vertikální pozice) a \id{v} (rychlost).
Výška musí splňovat invariant,
že není záporná: \id{x~>=~0}.
Znaménko rychlosti musí odpovídat diskrétnímu stavu.

Počáteční podmínky jsou následující:
\id{v~=~0} a interval \id{5~<=~x~<=~15}
vyjádřen jako výčet hodnot s~krokem \id{0.25}
(\id{(or (x~=~5) (x~=~5.25) \dots)}).

V~našem případě nám invariant výšky působí potíže,
jelikož jej nejsme schopni zaručit.
Budeme jej nuceni nějakým způsobem relaxovat:
invariant jsem modifikoval na~tvar \id{x~>=~-1}.
Je nutno nastavit velký počet fází
(tj.~malou vzdálenost mezi ověřením invariantů),
aby se minimalizovalo porušení původního invariantu
(kdy je míč pod~úrovní podložky).

Použita byla základní varianta
fixní délky fáze,
která v~tomto případě není příliš efektivní,
neboť v~drtivé většině fází ke~změně diskrétního stavu nedochází.
Lepší variantou by bylo dynamické nastavování délky fáze
podle nějakého odhadu doby,
po kterou by se zaručeně vědělo, že ještě ke~změně nemůže dojít.
Tyto odhady by bylo možné přidat do~vstupu
jako formule popisující následné časové okamžiky.
V~každém případě je použití našeho nástroje pro~tento příklad,
bez~kontrolování
invariant v~rámci integrací,
neperspektivní.

\pic{ball_dreal.pdf}{ball:dreal}{0.95}
   {Skákající míč v~dReal (s~aproximovanými intervalovými podmínkami)}
   {Oranžová čára přestavuje funkci \id{x} (výška),
    modrá čára funkci \id{v} (rychlost).}
\pic{ball_0_05.pdf}{ball:0.05}{0.85}
   {Skákající míč s~délkou fáze $0{,}05$ s.}
   {Funkce \id{x} značí výšku, \id{v} rychlost.}
\pic{ball_0_2.pdf}{ball:0.2}{0.85}
   {Skákající míč s~délkou fáze $0{,}2$ s.}
   {Funkce \id{x} značí výšku, \id{v} rychlost.}

Na~obrázku \rfPic{ball:dreal}
je uveden grafický výstup příkladu v~dReal,
na~obrázcích \rfPic{ball:0.05} a \rfPic{ball:0.2}
pak výstupy našeho nástroje, s~odlišnými délkami fází.
S~kratší délkou fáze dojde k~méně výraznému porušení
invariantu, kdy výška míče klesne pod~nulu.

\tab{ball_cmp}{0.6}
   {Skákající míč: srovnání délky výpočtu}
   {Řádky s~\id{T} se týkají našeho nástroje s~fixní délkou fáze \id{T} [s].}
   {r||c|l}
   {Varianta & Délka výpočtu [s] & Výstup \\ \hline
    dReal & $\hll{0{,}10}$ & \id{sat} \\ \hline
    \id{T = 0.025} & $8{,}3$ \  & \id{sat} \\ \hline
    \id{T = \ 0.05} & $1{,}96$ & \id{sat} \\ \hline
    \id{T = \ \  0.1} & $0{,}54$ & \id{sat} \\ \hline
    \id{T = \ \  0.2} & $1{,}04$ & \id{sat} \\ \hline
    }

\tab{ball_prof}{0.5}
   {Skákající míč: profilace částí výpočtu}
   {Poměry značí relativní dobu výpočtu dotčené části
    vzhledem k~celkovému času.
    \id{T} značí fixní délku fáze.}
   {r||c|c}
   {\id{T} [s] & Poměr \acr{smt} [\%] & Poměr \acr{ode} [\%] \\ \hline
    $0{,}025$ & $99{,}9$ & $0{,}1$ \\ \hline
     $0{,}05$ & $99{,}9$ & $0{,}1$ \\ \hline
      $0{,}1$ & $99{,}8$ & $0{,}2$ \\ \hline
      $0{,}2$ & $99{,}7$ & $0{,}3$ \\ \hline
    }

Tabulka \rfTab{ball_cmp} zachycuje naměřené délky výpočtu
našeho nástroje s~rozdílnými délkami fází
a výsledek řešiče dReal.
Tabulka \rfTab{ball_prof} uvádí rozložení
celkové doby výpočtu mezi řešiče \acr{smt} a \acr{ode}.

%%%

% Sat 05 May 2018 08:18:14 PM CEST
\begin{paragraph}{Diskuze výsledků.}\label{p:exp:examples:ball:results}
Z~tabulky \rfTab{ball_cmp} vyplývá, že zvolená délka fází
dramaticky ovlivňuje celkovou délku výpočtu.
Současně se vyskytl parazitní jev,
kdy je případ s~\id{T~=~0.2} pomalejší
než \id{T~=~0.1}.
To je způsobeno tím, že v~prvním jmenovaném
případě dochází k~návratům
z~důvodu porušení i~relaxovaného invariantu \id{x~>=~-1},
k~čemuž u~kratších délek fází nedochází.

Smutnou zprávou je, že je dReal
výrazně rychlejší.
Naše řešení je v~tomto případě nevhodné,
neboť vyžaduje mnoho fází
a při~zvolení malého množství
dochází k~přílišnému porušování invariantů,
a tedy návratům.

Nejedná se však o~nepřekonatelný problém,
jelikož nedostatek plynoucí z~ignorování
invariantů v~průběhu integrací
je pouze záležitostí nedostatečné implementace,
z~hlediska navrženého konceptu řešení \acr{ivp}
se nejedná o~překážku.

Tabulka \rfTab{ball_prof} ukazuje,
že předpoklady uvedené v~návrhu
řídícího algoritmu v~sekci \rf{ss:design:arch:alg}
byly správné: doba strávená operacemi
ověření splnitelnosti vstupu
zásadně převyšuje dobu integrací.
To je dobrá zpráva,
neboť je zde prostor pro~optimalizaci
pomocí maximální redukce těchto operací
a případného většího vytížení \acr{ode} řešiče.
\end{paragraph} %%Diskuze výsledků.

%%%

\bigskip

dReal si s~tímto příkladem poradil velmi dobře.
Připomeňme, že jsme vyřadili všechny intervalové podmínky
a nahradily je výčty hodnot.
Jak se dReal chová v~případě, že pracuje
s~intervalovými podmínkami,
pro~které byl navržen?

%%%

% Sat 05 May 2018 10:53:08 PM CEST
\begin{paragraph}{dReal s~intervalovými podmínkami.}
\label{p:exp:examples:ball:dreal_int}
Řešiči dReal jsem úlohu předložil
také v~původní formě s~intervalovými počátečními podmínkami
\id{5~<=~x~<=~15},
tj.~nekonečnou množinou počátečních stavů.

\pic{ball_dreal_d0_01_x.pdf}{ball:dreal:d0.01:x}{0.65}
   {Skákající míč v~dReal s~intervalovými podmínkami s~$\delta = 0{,}01$}
   {$\delta$ značí vstupní velikost nejistoty.
    Znázorněna je jen funkce \id{x} (výška).}
\pic{ball_dreal_d1_x.pdf}{ball:dreal:d1:x}{0.65}
   {Skákající míč v~dReal s~intervalovými podmínkami s~$\delta = 1$}
   {$\delta$ značí vstupní velikost nejistoty.
    Znázorněna je jen funkce \id{x} (výška).}

dReal samozřejmě nepracuje s~nekonečnou množinou,
ale umožňuje nastavit velikost nejistoty $\delta$,
o~kterou jsou vstupní formule zjednodušeny.
Obrázky \rfPic{ball:dreal:d0.01:x} a \rfPic{ball:dreal:d1:x}
ukazují výslednou trajektorii funkce \id{x}
s~různými volbami $\delta$.
(V~předchozím případě s~aproximovanými intervaly
jsem $\delta$ nastavil na~nějakou vysokou hodnotu
(např. $1000$), protože nízké hodnoty pouze negativně
ovlivňovaly dobu výpočtu, aniž by měly pozitivní vliv
na~přesnost výsledku.)

\tab{ball_dreal_int_cmp}{0.5}
   {Skákající míč: srovnání délky výpočtu řešiče dReal
    s~intervalovými podmínkami}
   {$\delta$ značí vstupní velikost nejistoty.
    Řádek s~${\delta = 0}$ reprezentuje variantu
    s~aproximovanými intervalovými podmínkami.}
   {r||c|l}
   {$\delta$  & Délka výpočtu [s] & Výstup \\ \hline
    $0$       & $\hll{0{,}10}$ & \id{sat} \\ \hline
    $0{,}001$ &      $0{,}58$  & \id{sat} \\ \hline
    $0{,}01$  &      $0{,}46$  & \id{sat} \\ \hline
    $0{,}1$   &      $0{,}36$  & \id{sat} \\ \hline
    $1$       &      $0{,}25$  & \id{sat} \\ \hline
    $10$      &      $0{,}12$  & \id{sat} \\ \hline
    }

Tabulka \rfTab{ball_dreal_int_cmp} navzájem
srovnává délku výpočtu pro~různé volby $\delta$
společně s~variantou aproximovaných intervalových podmínek.

Z~výsledného měření to vypadá,
že nejlepší variantou z~hlediska délky výpočtu
je výčet vstupních hodnot,
tj.~vyhnutí se použití intervalu.
To je zároveň hlavní rozdíl
mezi použitím našeho řešiče a dReal
(použití klasických numerických metod
implikuje exaktní počáteční podmínky),
nicméně v~dReal je zřejmě
náš způsob také dobře použitelný.

Jako neformální závěr z~tohoto experimentu
bych uvedl, že je obecně efektivnější
úlohu koncipovat jako \acr{ivp},
než jako I\acr{ivp} (intervalová varianta),
což nakonec není nic překvapivého.
\end{paragraph} %%dReal s~intervalovými podmínkami.

%%%

\end{subsection} %%Skákající míč

%%%%%%%%%%%%%

% Sun 06 May 2018 02:47:52 PM CEST
\begin{subsection}{Elektrický oscilátor}\label{ss:exp:examples:el_osc}
Jedná se opět o~příklad převzatý z~dReal,
který modeluje elektrický oscilátor.
Příklad je jen demonstrační,
nemá žádný vyšší smysl
a neslouží k~modelování reálného systému.

Model se skládá z~několika nelineárních \acr{ode}:
\id{x}, \id{y} a \id{z}, které představují oscilující funkce,
\id{om1} ($\omega_1$) a \id{om2} ($\omega_2$),
což jsou měnící se fáze%
\footnote{Myšleno jako fáze vlny;
termín je v~konfliktu s~fází výpočtu našeho řešiče.},
a \id{tau} ($\tau$), který slouží jako časovač
pro~přepínání diskrétních stavů.

Jednotlivá \acr{ode} jsou přibližně popsána takto
(liší se v~konstantách a v~různých diskrétních stavech):
\begin{flalign*}
\qquad \der{x} &= -ax \cdot \sin \left( \omega \cdot \tau \right) && \\
\qquad \der{y} &= -ay \cdot \sin \left( \omega_1 \cdot \tau \right)
                      \cdot \sin \left( \omega_2 \right) \cdot 2 && \\
\qquad \der{z} &= -az \cdot \sin \left( \omega_2 \cdot \tau \right)
                      \cdot \cos \left( \omega_1 \right) \cdot 2 && \\
\qquad \der{\omega_1} &= - \omega_1 && \\
\qquad \der{\omega_2} &= - \omega_2 && \\
\qquad \der{\tau} &= 1
\end{flalign*}
kde $\omega$ je konstanta.

Diskrétní stav je tvořen třemi stavy,
mezi kterými se cyklicky přepíná podle časovače \id{tau}
a nezávisí na~žádných jiných invariantech.
Jedná se tedy čistě o~systém řízený časem,
což hraje v~náš prospěch.
Podmínky přechodů ale nezávisí na~přesné hodnotě \id{tau},
ale na~intervalech (jsou tedy nedeterministické).
Ty jsou aproximovány s~krokem \id{0.1}.

Počáteční podmínky: \id{y~=~0}, \id{z~=~0},
\id{om1~=~2}, \id{om2~=~2.5}, \id{tau~=~0}
a interval \id{-0.2~<=~x~<=~0.1},
který je aproximován s~krokem \id{0.25}.

Je nutné dodržet následující invarianty:
\id{-5~<=~x~<=~5}, \id{-5~<=~y~<=~5}, \id{-5~<=~z~<=~5},
a přechody provést vždy jen v~rámci
vymezených intervalů pro~\id{tau}:
stav~1: \id{4~<=~tau~<=~5},
stav~2: \id{8~<=~tau~<=~10},
stav~3: \id{5~<=~tau~<=~6}.

\pic{el_osc_dreal.pdf}{el_osc:dreal}{0.95}
   {Elektrický oscilátor v~dReal (s~aproximovanými intervalovými podmínkami)}
   {Funkce \id{x} má červenou barvu, \id{y} fialovou, \id{z} hnědou,
    \id{om1} modrou, \id{om2} oranžovou a \id{tau} zelenou.}
\pic{el_osc_0_5.pdf}{el_osc:0.5}{0.85}
   {Elektrický oscilátor s~délkou fáze $0{,}5$ s.}
   {Funkce \id{tau} je časovač sloužící
    k~cyklickému přepínání diskrétních stavů.}
\pic{el_osc_5.pdf}{el_osc:5}{0.85}
   {Elektrický oscilátor s~délkou fáze $5$ s.}
   {Funkce \id{tau} je časovač sloužící
    k~cyklickému přepínání diskrétních stavů.
    Trajektorie funkcí jsou v~tomto případě méně hladké.}

Na~obrázku \rfPic{el_osc:dreal}
je uveden grafický výstup příkladu v~dReal,
na~obrázcích \rfPic{el_osc:0.5} a \rfPic{el_osc:5}
pak výstupy našeho nástroje, s~odlišnými délkami fází.
Z~grafů je patrné, že trajektorie funkcí jsou nejvíce hladké
(tj.~více přesné) v~případě řešiče dReal.

\tab{el_osc_cmp}{0.6}
   {Elektrický oscilátor: srovnání délky výpočtu}
   {Řádky s~\id{T} se týkají našeho nástroje s~fixní délkou fáze \id{T} [s].}
   {r||c|l}
   {Varianta & Délka výpočtu [s] & Výstup \\ \hline
    dReal             & $\hll{0{,}47}$ & \id{sat} \\ \hline
    \id{T = 0.25}     & $14{,}5$ \ \ \ & \id{sat} \\ \hline
    \id{T = \ 0.5}    & $4{,}5$  \ \   & \id{sat} \\ \hline
    \id{T = \ \ \  1} & $0{,}83$       & \id{sat} \\ \hline
    \id{T = \ \ \  2} & $10{,}1$ \ \ \ & \id{unsat} \\ \hline
    \id{T = \ \ \  4} & $1{,}26$       & \id{unsat} \\ \hline
    \id{T = \  1.5}   & $\hll{0{,}47}$ & \id{sat} \\ \hline
    \id{T = \  2.5}   & $\hll{0{,}21}$ & \id{sat} \\ \hline
    \id{T = \  5.0}   & $\hll{0{,}10}$ & \id{sat} \\ \hline
    }

\tab{el_osc_prof}{0.5}
   {Elektrický oscilátor: profilace částí výpočtu}
   {Poměry značí relativní dobu výpočtu dotčené části
    vzhledem k~celkovému času.
    \id{T} značí fixní délku fáze.}
   {r||c|c}
   {\id{T} [s] & Poměr \acr{smt} [\%] & Poměr \acr{ode} [\%] \\ \hline
     $0{,}25$ & $99{,}9$ & $0{,}1$ \\ \hline
     $0{,}5$  & $99{,}9$ & $0{,}1$ \\ \hline
     $1$      & $99{,}7$ & $0{,}3$ \\ \hline
     $1{,}5$  & $99{,}5$ & $0{,}4$ \\ \hline
     $2$      & $99{,}5$ & $0{,}5$ \\ \hline
     $2{,}5$  & $99{,}1$ & $0{,}8$ \\ \hline
     $4$      & $98{,}9$ & $1{,}1$ \\ \hline
     $5{,}0$  & $98{,}1$ & $1{,}7$ \\ \hline
    }

Tabulka \rfTab{el_osc_cmp} zachycuje výstupy
a naměřené délky výpočtu řešiče dReal
a našeho nástroje s~rozdílnými délkami fází.
Tabulka \rfTab{el_osc_prof} uvádí rozložení
celkové doby výpočtu mezi řešiče \acr{smt} a \acr{ode}.

%%%

% Sun 06 May 2018 03:08:36 PM CEST
\begin{paragraph}{Diskuze výsledků.}\label{p:exp:examples:el_osc:results}
Tento příklad přináší potěšující zprávy,
konkrétně tabulka \rfTab{el_osc_cmp}.
Opět významně závisí na~volbě (fixní) délky fáze \id{T},
to je zřejmé a bude to platit pro~všechny (splnitelné) vstupy.
Tentokrát byly možné i~volby vyšších hodnot \id{T},
neboť bezprostředně nehrozilo porušení invariant během integrace
a přechody mezi diskrétními stavy závisely pouze na~čase.
V~případě \id{T~=~5} jsme téměř dosáhli minimálního počtu
potřebných ověření splnitelnosti,
tj.~jen v~okamžicích přechodů.
(Tak se přibližně chová také dReal.)

Tím jsme se více přiblížili přímému srovnání
integračních metod~---~klasických numerických metod
a metod s~intervalovou aritmetikou.
V~tomto případě \hl{je naše řešení rychlejší}.
Nutno však podotknout, že výsledné trajektorie jsou méně přesné.

Pro~některé volby hodnot \id{T} není možné splnit invarianty.

Tabulka \rfTab{el_osc_prof} opět potvrzuje,
že délka výpočtu strávená \acr{smt} řešičem
stále vysoce převyšuje \acr{ode} řešič,
a to i~v~případě \id{T~=~5}.
\end{paragraph} %%Diskuze výsledků.

%%%

\bigskip

\tab{el_osc_dreal_int_cmp}{0.5}
   {Elektrický oscilátor: srovnání délky výpočtu řešiče dReal
    s~intervalovými podmínkami}
   {$\delta$ značí vstupní velikost nejistoty.
    Řádek s~${\delta = 0}$ reprezentuje variantu
    s~aproximovanými intervalovými podmínkami.}
   {r||c|l}
   {$\delta$  & Délka výpočtu [s] & Výstup \\ \hline
    $0$       & $\hll{0{,}47}$       & \id{sat} \\ \hline
    $0{,}001$ &      $22{,}3$ \ \ \  & \id{sat} \\ \hline
    $0{,}01$  &      $19{,}4$ \ \ \  & \id{sat} \\ \hline
    $0{,}1$   &      $11{,}0$ \ \ \  & \id{sat} \\ \hline
    $1$       &      $6{,}6$  \ \    & \id{sat} \\ \hline
    $10$      &      $0{,}5$  \ \    & \id{sat} \\ \hline
    }

\pic{el_osc_dreal_d10.pdf}{el_osc:dreal:d10}{0.8}
   {Elektrický oscilátor v~dReal
    s~intervalovými podmínkami s~$\delta = 10$}
   {$\delta$ značí vstupní velikost nejistoty.}

Pro~úplnost ještě uvádím výstupy řešiče dReal
za~použití intervalových podmínek pro \id{x} a \id{tau}
v~tabulce \rfTab{el_osc_dreal_int_cmp}.
V~tomto případě jsou rozdíly
oproti aproximovaným intervalovým podmínkám
mnohem vyšší, kromě případu ${\delta = 10}$,
který je však vůči vstupu hodně tolerantní
(viz.~obrázek \rfPic{el_osc:dreal:d10}).
\end{subsection} %%Elektrický oscilátor

%%%%%%%%%%%%%

% Sun 06 May 2018 06:47:06 PM CEST
\begin{subsection}{Závěr experimentů}\label{ss:exp:examples:conclusion}
Některé úlohy potvrdily, že náš zvolený koncept
je nadějný pro~uplatnění v~praxi.
Použití klasických numerických metod v~\acr{ode} řešiči
je rychlejší než použití intervalové aritmetiky,
kterou používá řešič dReal.
I~tento řešič si však dokáže počínat relativně efektivně,
pokud pracuje s~úlohou \acr{ivp},
a ne s~intervaly (I\acr{ivp}).
Intervaly lze efektivně aproximovat výčtem hodnot
jako logického součtu.
To je nejdůležitější pozorování této práce.

Náš nástroj drtivou většinu doby výpočtu stráví
na~straně \acr{smt} řešiče.
Proto bude následnou snahou
tyto operace maximálně redukovat,
zejména umožněním kontrolování invariant v~rámci integrací
(což se nevylučuje s~konceptem řešení \acr{ivp})
a aplikováním sofistikovanějšího
řídícího algoritmu, který by efektivněji zacházel s~návraty.

S~náročností \acr{smt} operací souvisí to,
že výkon našeho postupu výrazně závisí
na~zvoleném počtu fází,
tj.~počtem přerušení integrací \acr{ode} řešiče
a kontrolování splnitelnosti celého vstupu \acr{smt} řešičem.
Pokud se zvolený počet fází blíží
minimu~---~počtu změn diskrétního
stavu~---~pak je naše řešení násobně rychlejší než dReal,
a to i~v~tomto raném stádiu vývoje.
\end{subsection} %%Závěr experimentů

%%%%%%%%%%%%%

\end{section} %%Praktické úlohy

%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Sun 06 May 2018 06:44:17 PM CEST
\begin{section}{Případy užití}\label{s:exp:use_case}
Všechny zmiňované hybridní řešiče
(náš, dReal, atd.)
mohou být použity pro~účely modelování hybridních systémů
a ověření jejich specifikací.

Uvedu pár praktických příkladů,
k~čemu by mělo být možné tyto nástroje využít:
\begin{itemize}
\item Obecně modely regulátorů:
   je požadavek udržovat některou veličinu
   v~rámci stanovených mezí,
   což periodicky kontroluje řídící systém
   a zapíná nebo vypíná regulaci
   (např. termostat, vodní nádrž, \dots).
\item Model autonomního řízení dopravního prostředku:
   zkušený inženýr navrhne diferenciální rovnice tak,
   že dobře popisují dynamiku prostředku,
   a všechny diskrétní stavy;
   testují se modelové situace,
   zda se prostředek chová dle očekávání:
   objetí překážky, udržování vzdálenosti,
   zaparkování, \dots
\item Modelování řídícího systému serveru:
   na~server přichází požadavky podle
   definované statistické distribuční funkce
   obecně do~více vyrovnávacích pamětí;
   ověření, s~jakými prostředky je systém schopen
   příchozí požadavky obsloužit.
\item Spolehlivostní modely (blokové, Markovské):
   možnost experimentování se~vstupními parametry tak,
   aby model splňoval nějaké požadavky
   (např. střední doba do~poruchy).
\end{itemize}
a dále uvádím jen některé úvahy a nápady:
\begin{itemize}
\item Motorika robota:
   motorickým pohybům robotů,
   zejména těm neupevněným k~podložce,
   může působit potíže udržet rovnováhu
   kvůli setrvačnosti vlastních pohybů
   (např. prudké pohyby paží humanoidního robota).
   To je možné řešit např. protipohyby.
   Nešlo by pro~obecný pohyb (v~rámci daného systému)
   vypočítat odpovídající protipohyb, aby zůstal robot stabilní?
\item Jeden ze~způsobů testování logických obvodů
   využívá řešiče \acr{sat}. Testování společně s~analogovými obvody
   je však problematické. Nebylo by k~tomu možné využít hybridního řešiče?
\end{itemize}
\end{section} %%Případy užití

%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Sun 06 May 2018 07:12:29 PM CEST
\begin{conclusion}\label{ch:outro}
% Úvod
Cílem práce bylo aplikovat odlišný přístup
v~analýze systémů modelovaných
v~\acr{smt} a \acr{ode},
který klade při~integracích větší
důraz na~rychlost, než na přesnost,
a tím byl lépe použitelný v~praxi.

% Rešerše
Stávající řešiče používají při~řešení \acr{ode}
intervalovou aritmetiku, která poskytuje
garanci maximální chyby,
ale je pomalá.
Separátně jsem zkoumal \acr{smt} řešiče
a \acr{ode} řešiče, které používají
klasické numerické metody,
a vybíral vhodnou kombinaci
pro~nový nástroj.

% Splnění cílů
Výsledky práce splňují předsevzaté cíle:
zvolený koncept se~ukázal jako nadějná
alternativa ke~stávajícím řešičům.
Experimenty na~praktických úlohách ukázaly,
že použití našeho řešení
může být rychlejší,
než v~případě stávajícího řešiče dReal.
Konkrétně se jednalo např. o~modelový příklad
elektrického oscilátoru,
v~němž naše nejlepší konfigurace dosáhla
téměř pětinásobně kratšího výpočetního času.
A~to i~přesto, že implementovaný nástroj
je pouhým prototypem.
Výkonnost našeho postupu výrazně závisí
na~zvoleném počtu fází výpočtu,
tj.~četnosti střídání výpočtu \acr{smt} a \acr{ode} řešiče.

% Pozorování
Nejdůležitějším pozorováním této práce
je efektivita úloh \acr{ivp}
vůči úlohám s~intervaly (I\acr{ivp}).
Intervaly lze efektivně aproximovat
pomocí výčtu hodnot v~logickém součtu.
S~takovým vstupem si i~řešič dReal
počíná relativně rychle.

% Další zásluhy
Přidanou hodnotou je použitý prototyp nástroje,
který zahrnuje společný vstupní jazyk,
ve~kterém lze vstup parametrizovat pomocí maker.
Navíc je možné flexibilně
nasazovat různé \acr{smt} a \acr{ode} řešiče.
Požadavky na~rozhraní \acr{smt} řešiče
jsou minimální: stačí, aby byl inkrementální
a byl konformní se~standardem \acr{smt}-LIB,
pak lze použít jako samostatný proces.
U~\acr{ode} řešiče stačí, aby řešil \acr{ivp}
a koncové podmínky závisely (zatím) jen na~čase,
ale vyžaduje implementaci
odvozené třídy a dodržení programového rozhraní.
Aktuálně je používán řešič odeint.
Z~\acr{smt} řešičů byly testovány
\acr{cvc}4 a z3,
ale z3 si počíná efektivněji.

% Výhled
Nový koncept byl prověřen a nyní čeká
na~řádnou implementaci,
jelikož náš prototyp zatím obsahuje řadu nedostatků a zjednodušení.
Může posloužit jako inspirace pro~budoucí vývojáře
průmyslových nástrojů.
Druhou, ještě více uspokojivou možností
by bylo pokračování ve~vývoji stávajícího projektu
s~otevřenými zdrojovými kódy,
ať už samostatně či v~týmu,
směrem ke~konečnému produktu použitelném v~praxi.
\end{conclusion}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\appendix

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bibliographystyle{csn690}
\bibliography{dp_kolarto5}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\printglossary[type=\acronymtype, title=Seznam použitých symbolů a zkratek]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Tue 08 May 2018 02:55:02 PM CEST
\chapter{Návod k~použití programu}\label{appendix:usage}
Program, včetně zdrojových kódů a textu práce, je veřejně přístupný
v~git repositáři na~adrese \url{https://github.com/Tomaqa/sos}
pod~tolerantní licencí \acr{mit}.

Nejprve uvedu obsah projektu, ať už pořízeného z~přiloženého CD
nebo přímo z~git repositáře,
poté návod k~sestavení projektu ze~zdrojových kódů
a následně návod k~použití spustitelné aplikace.
Prototyp aplikace necílí na~uživatelskou přívětivost,
proto neočekávejte vždy intuitivní chování programu.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Tue 08 May 2018 02:54:58 PM CEST
\begin{section}{Obsah projektu}\label{s:usage:tree}
\dirtree{%
   .1 LICENSE.md\DTcomment{obsah použité licence \acr{mit}}.
   .1 README.md\DTcomment{stručný popis projektu}.
   .1 bin\DTcomment{adresář se~spustitelnými soubory implementace}.
      .2 applet\DTcomment{spustitelné dílčí applety}.
   .1 data\DTcomment{adresář s~uživatelskými datovými soubory}.
      .2 smto\DTcomment{soubory ve~formátu vstupního jazyka}.
   .1 doc\DTcomment{adresář dokumentace projektu}.
      .2 articles\DTcomment{adresář pro~tematické vědecké články}.
         .3 thesis\DTcomment{adresář s~textem diplomové práce}.
   .1 include\DTcomment{adresář s~hlavičkovými a šablonovými soubory}.
      .2 sos\DTcomment{soubory týkající se knihovny implementace}.
      .2 test\DTcomment{soubory pro~testy}.
   .1 local\DTcomment{lokální uživatelské soubory nezávislé na~repositáři}.
   .1 src\DTcomment{adresář se~zdrojovými kódy}.
      .2 main\DTcomment{soubory týkající se aplikací a appletů}.
      .2 sos\DTcomment{soubory týkající se knihovny implementace}.
      .2 test\DTcomment{soubory pro~testy}.
   .1 test\DTcomment{spustitelné soubory testů}.
   .1 tools\DTcomment{adresář s~pomocnými skripty}.
}
\end{section} %%Obsah projektu

%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Tue 08 May 2018 11:41:12 AM CEST
\begin{section}{Návod k~sestavení}\label{s:usage:build}
Standardní sestavení programu se provede jediným příkazem:
\begin{verbatim}
   $ make
\end{verbatim}
Standardní verze programu závisí na~knihovnách Boost (odeint)
a na~\acr{smt} řešiči z3 nainstalovaném v~systému.
Volitelně je program závislý na~nástroji gnuplot,
pokud má uživatel zájem o~generování výstupních grafů.

Pro~použití jiného \acr{smt} řešiče
je nutné před~sestavením ručně upravit zdrojový soubor
\srcFn{sos/\-smt/\-solver.cpp} na~řádku s~funkcí \id{execlp}.
Buď lze odkomentovat řádek s~řešičem \acr{cvc}4,
nebo přidat nový řádek s~jiným řešičem.

Pokud uživatel nemá dostupné knihovny Boost,
může před~sestavením smazat všechny zdrojové soubory *\id{odeint}*
a používat jen implementaci Eulerovy metody.
\end{section} %%Návod k~sestavení

%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Tue 08 May 2018 11:41:12 AM CEST
\begin{section}{Spuštění programu}\label{s:usage:run}
Hlavní aplikace je umístěna v~souborech \binFn{sos\_\-odeint}
a \binFn{sos\_\-euler}, které používají jako \acr{ode} řešič
odeint, resp. vlastní implementaci Eulerovy metody.
\binFn{sos\_\-euler} je vhodná z~hlediska nezávislosti
na~externích knihovnách, jinak je téměř vždy lepší použít
\binFn{sos\_\-odeint}.

Zobrazení zprávy s~povolenými vstupními parametry aplikace
se provede pomocí
\begin{verbatim}
   $ bin/sos_odeint -h
\end{verbatim}

Příklad použití se~vstupním i~výstupním souborem:
\begin{verbatim}
   $ bin/sos_odeint data/smto/ball.smto -o local/out
\end{verbatim}
po~čemž se do~souboru \id{local/\-out}
zapíší textová data pro~generování grafu
a do~souboru \id{local/\-out\_\-plot.svg}
bude vygenerován graf nástrojem gnuplot.
\end{section} %%Spuštění programu

%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Kompletní příklad užití}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Další příklady modelů}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Tue 08 May 2018 03:32:12 PM CEST
\chapter{Další příklady použití maker}\label{appendix:macros}
Tato příloha uvádí další příklady použití maker.
První sekce uvádí použití přímo v~textovém kódu vstupu,
druhá sekce komentuje případy užití maker jako celku
v~kontextu tématu práce.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Tue 08 May 2018 03:33:46 PM CEST
\begin{section}{Ukázky použití a chování maker}\label{s:macros:examples}
\begin{Verbatim}[samepage=true]
#def SEQ(n)
#if $( > #n 0 )
  #SEQ( $d(- #n 1) ) #n
#endif
#enddef
#define FACT(n) * #SEQ(#n)
(assert (= $(#FACT(5)) 120) ) ;; $(* 1 2 3 4 5) == 120  => true

#define NUMS() 1 2 3
( #NUMS )  ;; (1 2 3)
( #NUMS# ) ;; (123)
( #FACT#(3) )  ;; error: missing parameters for 'FACT' !
( #FACT(3)# )  ;; (* 1 2 3)
( ##FACT(3) )  ;; (FACT(3))
( ###FACT(3) ) ;; (*123)
\end{Verbatim}
\begin{Verbatim}[samepage=true]
( $f (- 3.5 1.9) )        ;; ( 1.60000... )
( $d (- 3.5 1.9) )        ;; ( 2 )
( $d (+ $f(- 3.5 1.9) ))  ;; ( 1 )
\end{Verbatim}
\begin{Verbatim}[samepage=true]
#define N 5
#define N5 1
#def PRINT(x)
#let i 1
#let j 2
  #x
#endlet i
#endlet j
#enddef
( #PRINT(N) )      ;; ( N )
( #PRINT(#N) )     ;; ( 5 )
( #PRINT(\#N) )    ;; ( 5 )
( #PRINT(\#N5) )   ;; ( 1 )
( #PRINT(\#N#N) )  ;; ( 1 )
( #PRINT(\#N\#N) ) ;; ( 55 )
( #PRINT(N#i) )    ;; error: user macro 'i' was not defined !
( #PRINT(N\#i) )   ;; ( N1 )
( #PRINT(#N\#i) )  ;; ( 51 )
( #PRINT(\#N\#i) ) ;; ( 51 )
( #PRINT(\#i\##_\#j) ) ;; ( 1_2 )
\end{Verbatim}
\end{section} %%Ukázky použití a chování maker

%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Tue 08 May 2018 03:37:07 PM CEST
\begin{section}{Případy užití maker ve~vstupním jazyce}
\label{s:macros:use_cases}
\begin{itemize}
\item Definice numerických literálů,
   které lze použít i~v~příkazech \id{define\--dt}:
   \begin{Verbatim}[samepage=true]
   #define K() 5
   (define-dt x dx () (* #K t))
   \end{Verbatim}
\item Nastavení fází výpočtu:
   \begin{Verbatim}[samepage=true]
   #define T()     0.5
   #define T_MIN()   0
   #define T_MAX()  10
   #define STEPS() $d(+ $f(/ (- #T_MAX #T_MIN) #T) )
   ;; ...
   #def T_STEPS()
   #for (j 1 #STEPS)
   #let i $d(- #j 1)
       (= t_#j  (+ t_#i  #T))
   #endlet j
   #endfor
   #enddef
   \end{Verbatim}
\item Deklarace všech konstant fází:
   \begin{Verbatim}[samepage=true]
   #def DECL_CONSTS(const type)
   #for (i 0 #STEPS)
       (declare-fun #const##_#i () #type)
   #endfor
   #enddef
   #DECL_CONSTS(t  Real)
   ;; ...
   \end{Verbatim}
   Stejný způsob lze použít pro~invarianty,
   volby variant derivací, skoky a integrace.
\item Aproximace intervalových počátečních podmínek:
   \begin{Verbatim}[samepage=true]
   #def INIT_INTERVAL(var min max step) (or
   #for (i #min (<= #i #max) (+ #i #step))
      (= #var #i)
   #endfor
   ) #enddef
   \end{Verbatim}
\item Kaskádní kompozice systémů:
   každý systém reprezentovat vlastní sadou konstant
   s~nějakou číselnou příponou
   a vstup generovat pomocí maker \id{\#for}
   nebo rekurzivních maker.
   Krajní systémy generovat zvlášť,
   nebo pomocí makra \id{\#if},
   a ostatní propojit pomocí parametrických uživatelských maker,
   např. s~parametrem \id{\#i} a \id{\#let j \$d(+ \#i 1)}.
\end{itemize}
\end{section} %%Případy užití maker ve~vstupním jazyce

%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
