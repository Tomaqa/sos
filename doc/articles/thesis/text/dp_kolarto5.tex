% options:
% thesis=B bachelor's thesis
% thesis=M master's thesis
% czech thesis in Czech language
% slovak thesis in Slovak language
% english thesis in English language
% hidelinks remove colour boxes around hyperlinks
\documentclass[thesis=M,czech]{FITthesis}[2012/06/26]

\usepackage[utf8]{inputenc} % LaTeX source encoded as UTF-8

\usepackage{graphicx} %graphics files inclusion
\usepackage{dirtree} %directory tree visualisation

\usepackage{amsmath} %advanced maths
\usepackage{mathtools}

\usepackage{microtype}

\usepackage{fancyvrb}

\usepackage{pdfpages}
%% includepdf is used in 'FITthesis.cls'

%%%%%%%%%%%%%%%%%

\renewcommand{\arraystretch}{1.15}

\usepackage{enumitem}
\setitemize{noitemsep,topsep=2pt,parsep=4pt}
\setenumerate{noitemsep,topsep=2pt,parsep=4pt}
\setenumerate[2]{label=\roman*.}
\setdisplayed{topsep=4pt}

% \clubpenalty=500

%%%%%%%%%%%%%%%%%

\setcounter{tocdepth}{1}

%%%% List of acronyms
\usepackage[acronym,toc,numberedsection=autolabel]{glossaries}

\newcommand{\acrlabel}[1]{acr:#1}
\newcommand{\acr}[1]{\acrshort{\acrlabel{#1}}}
\newcommand{\acrl}[1]{\acrlong{\acrlabel{#1}}}
\newcommand{\acrf}[1]{\acrfull{\acrlabel{#1}}}
\newcommand{\acrfc}[1]{\acrl{#1}, \acr{#1}}

\newcommand{\newacr}[3]{\newacronym{\acrlabel{#1}}{#2}{#3}}

\makeglossaries


\newacr{cvut}{{\v C}VUT}{{\v C}esk{\' e} vysok{\' e}
   u{\v c}en{\' i} technick{\' e} v Praze}
\newacr{fit}{FIT}{Fakulta informa{\v c}n{\' i}ch technologi{\' i}}

\newacr{api}{API}{Application programming interface}
\newacr{ansi}{ANSI}{American National Standards Institute}
\newacr{ascii}{ASCII}{American Standard Code for~Information Interchange}
\newacr{pdf}{PDF}{Portable Document Format}

\newacr{gpl}{GPL}{General Public License}
\newacr{gnu}{GNU}{GNU's Not Unix!}
\newacr{os}{OS}{Operační systém}
\newacr{posix}{POSIX}{Portable Operating System Interface}

\newacr{simd}{SIMD}{Single instruction multiple data}
\newacr{omp}{OpenMP}{Open Multi-Processing}
\newacr{mpi}{MPI}{Message Passing Interface}

\newacr{stl}{STL}{Standard Template Library}
\newacr{tmp}{TMP}{Template Metaprogramming}

\newacr{bmc}{BMC}{Bounded Model Checking}
\newacr{cnf}{CNF}{Conjunctive normal form}
\newacr{dpll}{DPLL}{Davis--Putnam--Logemann--Loveland}
\newacr{sat}{SAT}{Boolean satisfiability problem}
\newacr{smt}{SMT}{Satisfiability Modulo Theories}
\newacr{np}{NP}{Nondeterministic polynomial time}
\newacr{qbf}{QBF}{Quantified Boolean formulas}
\newacr{fol}{FOL}{First-order logic}
\newacr{ltl}{LTL}{Linear time logic}
\newacr{ctl}{CTL}{Computation tree logic}
\newacr{dimacs}{DIMACS}{Center for Discrete
   Mathematics and Theoretical Computer Science}
\newacr{cvc}{CVC}{Cooperating Validity Checker}

\newacr{ode}{ODE}{Ordinary differential equation}
\newacr{dae}{DAE}{Differential-algebraic equation}
\newacr{ivp}{IVP}{Initial value problem}
\newacr{sundials}{SUNDIALS}{SUite of Nonlinear and
   DIfferential/ALgebraic Equation Solvers}
\newacr{bdf}{BDF}{Backward differentiation formula}

\newacr{sos}{SOS}{\acr{smt}+\acr{ode} solver}

%%%%%%%%%%%%%%%%%
%%%% Debug commands

\newcommand{\cmt}[1]{\textit{/* #1 */}}

%%%%%%%%%%%%%%%%%
%%%% Text mode commands

\newcommand{\id}[1]{\texttt{#1}}

\newcommand{\hl}[1]{\textit{#1}}
\newcommand{\hll}[1]{\textbf{#1}}

\newcommand{\name}[1]{\hl{#1}}

\newcommand{\cit}[1]{\cite{#1}}
\newcommand{\rf}[1]{\ref{#1}}
\newcommand{\rfeq}[1]{(\rf{eq:#1})}

\newcommand{\reg}{\textsuperscript{\textregistered}}

\newcommand{\itab}[1]{\hspace{0em}\rlap{#1}}
\newcommand{\tab}[1]{\hspace{.2\textwidth}\rlap{#1}}

%%%%%%%%%%%%%%%%%
%%%% Math mode commands

\newcommand{\tg}{\mathop{\mathrm{tg}}} %cesky tangens
\newcommand{\cotg}{\mathop{\mathrm{cotg}}} %cesky cotangens

%% Vectors and matrices
\renewcommand{\vec}[1]{\ensuremath{\boldsymbol{#1}}}
\newcommand{\mat}[1]{\ensuremath{\mathbb{#1}}}
\newcommand{\set}[1]{\ensuremath{\mathcal{#1}}}

\newcommand{\trans}[1]{\ensuremath{#1^\top}}
\newcommand{\conj}[1]{\ensuremath{\overline{#1}}}
\newcommand{\ctrans}[1]{\ensuremath{#1^*}}
\newcommand{\inv}[1]{\ensuremath{#1^{-1}}}
\newcommand{\norm}[1]{\ensuremath{\left\lVert#1\right\rVert}}

\newcommand{\der}[1]{\ensuremath{\dot{#1}}}
\newcommand{\dvec}[1]{\der{\vec{#1}}}

\newcommand{\pred}[1]{\ensuremath{\tilde{#1}}}
\newcommand{\pvec}[1]{\pred{\vec{#1}}}
\newcommand{\pmat}[1]{\pred{\mat{#1}}}

\newcommand{\gues}[1]{\ensuremath{\hat{#1}}}
\newcommand{\gvec}[1]{\gues{\vec{#1}}}
\newcommand{\gmat}[1]{\gues{\mat{#1}}}
%%

%%%%%%%%%%%%%%%%%

\newcommand{\binDir}{\id{bin}}
\newcommand{\binFn}[1]{\id{\binDir{}/\-#1}}
\newcommand{\appletDir}{\id{\binDir{}/\-applet}}
\newcommand{\appletFn}[1]{\id{\appletDir{}/\-#1}}

%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%

\department{Katedra číslicového návrhu}
\title{SMT řešič s~diferenciálními rovnicemi}
\authorGN{Tomáš} %(křestní) jméno autora
\authorFN{Kolárik} %příjmení autora
\authorWithDegrees{Bc. Tomáš Kolárik} %jméno autora
                                      %včetně současných akademických titulů
\author{Tomáš Kolárik} %jméno autora bez akademických titulů
\supervisor{doc. Dipl.-Ing. Dr. techn. Stefan Ratschan}
\acknowledgements{Děkuji celé své rodině
za~veškerou podporu a motivaci během celého studia.
Dále panu vedoucímu doc. Dipl.-Ing. Dr. techn. Stefanu Ratschanovi
za~profesionální a velmi ochotnou asistenci s~touto prací.}
\abstractCS{
% Cíl
Práce se zabývá realizací řešiče
pro~účely formální verifikace modelů hybridních systémů.
Řešič ovládá podmnožiny predikátové logiky
(\acr{smt}) a diferenciální rovnice (\acr{ode})
a definuje jejich společný vstupní jazyk.

% Postupy, metody
Podobné řešiče již existují
(např. dReal),
ale jsou v~praxi těžko použitelné,
jelikož používají pro~řešení \acr{ode}
intervalovou aritmetiku,
která garantuje maximální výši chyby,
ale je pomalá.
Cílem bylo na~straně \acr{ode} řešiče
použít klasických numerických metod,
které neposkytují garanci chyby
a mohou být méně přesné,
ale jsou rychlejší.

% Výsledky, užitek
Výsledkem práce je prototyp nástroje
nazvaný \acr{sos} (\acrl{sos}),
použitelný jako knihovna nebo aplikace,
který umožňuje flexibilní
propojení \acr{smt} a \acr{ode}
řešiče, obou nezávislých od~ostatních komponent.
\acr{smt} řešič může být libovolný,
jenž je inkrementální
a přijímá textový vstup
ve~formátu \acr{smt}-LIB standardu.
\acr{ode} řešič smí být jakýkoli
řešící \acr{ivp},
ale vyžaduje implementaci odvozené třídy.
Pro~některé podmnožiny modelů hybridních systémů,
zejména těch orientovaných na~čas,
je ověření splnitelnosti vstupu několikanásobně
rychlejší než v~případě řešiče dReal.

% Závěr
Tím bylo dosaženo cíle
realizace efektivnějšího
a v~praxi použitelnějšího
přístupu k~formální verifikaci
hybridních systémů s~diferenciálními rovnicemi,
a to přes to, že se jedná pouze o~prototyp,
který dosud obsahuje řadu nedostatků.
Práce by měla sloužit jako zdroj inspirace
pro~vývojáře průmyslových nástrojů,
anebo by také mohla být nadále vyvíjena
a zefektivňována
v~rámci stávajícího projektu
s~otevřenými zdrojovými kódy.
}
\abstractEN{

}
\placeForDeclarationOfAuthenticity{V~Praze}
\declarationOfAuthenticityOption{2} %volba Prohlášení (číslo 1--6)
\keywordsCS{\acr{sat}, \acr{smt}, \acr{smt}-LIB,
numerické metody pro~\acr{ode},
analýza hybridních systémů, formální verifikace}
\keywordsEN{\acr{sat}, \acr{smt}, \acr{smt}-LIB,
numerical methods for~\acr{ode}s,
hybrid systems analysis, formal verification}
\website{https://github.com/Tomaqa/sos} %volitelná URL práce,
%% objeví se v tiráži~---~úplně odstraňte, nemáte-li URL práce

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Thu 03 May 2018 11:16:40 PM CEST
\begin{introduction}\label{ch:intro}
% Úvod
Většina veřejnosti, a nejen té laické,
si z~informačních technologií
jako první vybaví stolní počítače,
notebooky či mobily.
Dnešní mobilní telefony jsou specifické tím,
že jejich funkce souvisí s~vnějšími podněty z~reálného světa:
komunikují přes různá bezdrátová připojení,
pořizují zvukové i~obrazové záznamy,
ovládají se dotykovou obrazovkou, atd.
To všechno znamená interakci s~fyzikálním světem
pomocí různých snímačů a akčních členů.
Existuje však odvětví zařízení,
které se např. od~mobilů liší v~jedné
naprosto zásadní specifikaci.
Jsou to bezpečnostně kritické systémy reálného času,
jejichž hlavní rozdíl tkví v~tom,
že dané akce, které závisí na~vnějších podnětech,
\hl{musí} být bezpodmínečně vykonány
v~rámci daného \hl{časového intervalu}.
Jakmile se to nestane (ať už opožděně nebo vůbec),
dojde k~nějaké katastrofě,
jejíž následky budou drahé
(finanční prostředky, ale i~lidské životy).
Pokud se jedinci opozdí příjem mobilního hovoru,
bude ho to jistě mrzet méně
(alespoň to předpokládejme),
než když se opozdí reakce na~sešlápnutí brzdového pedálu.
Je tedy nutné zavést určité \hl{garance}.
Typickým příkladem takových systémů
jsou např. dopravní prostředky (letadla, tramvaje)
a průmyslová zařízení (robotické stroje).
S~rostoucími požadavky na~tyto systémy
závratně roste počet různých stavů,
ve~kterých se mohou nacházet,
a které také chceme rozlišovat
na~přípustné a nepřípustné.
Jak lze ale uchopit takto komplexní problémy,
které ještě musí splňovat časové požadavky?
Jak specifikace garantovat?

% Význam tématu pro společnost
Takové systémy už lidstvo používá mnoho desítek let,
přesto je téma této práce aktuální.
Je to způsobeno tím,
že do~určité doby stačilo tyto systémy jen simulovat,
tj. vygenerovat reprezentativní sadu vstupních dat
a kontrolovat výstupy, zda odpovídají zadání.
Tento postup se nazývá \name{funkční verifikace}.
To naráží na~potíž,
že u~bezpečnostně kritických aplikací je záhodno
testovat téměř všechny možné přípustné vstupy.
Vzhledem k~tomu,
že množství kombinací různých vstupních dat
roste exponenciálně s~počtem sledovaných specifikací,
došli někteří vývojáři do~bodu,
kdy byl tento postup testování již příliš
dlouhý, drahý a nespolehlivý.
Tehdy se začal používat i~jiný způsob
ověření spolehlivosti systémů,
pomocí jejich \name{modelu}~---~matematického popisu,
který zanedbává nedůležitá hlediska
a soustředí se na~funkce systému.
Pro~takový zjednodušený model systému
potom lze formálně (tj.~exaktně, zcela přesně) dokázat,
zda mohou či nemohou nastat zakázané stavy.
Tento postup se nazývá \name{formální verifikace}.

% Zaměření
Ve~své práci se zabývám možnými nástroji
sloužícími k~ověření takových modelů systémů.
Jedním z~nejznámějších přístupů
je aplikace problému splnitelnosti Booleovské formule:
\name{\acr{sat}} (angl. \name{\acrl{sat}}),
v~němž lze např. modelovat přechodové systémy.
Tento problém je podrobně prozkoumán
a v~praxi často používán.
Přesto, že se jedná o~\acr{np}-úplný problém,
jsou jeho dnešní řešiče velmi efektivní.
Tyto řešiče jsou ale relativně limitující
v~tom smyslu, že povolují pouze proměnné Booleovského typu.
V~minulém desetiletí započal fenomén
zobecněného problému,
který operuje na~nějakých podmnožinách
predikátové logiky: \name{\acr{smt}}
(angl. \name{\acrl{smt}}).
Vstupní formule tohoto problému mají
větší vyjadřovací schopnost
a jsou lépe uchopitelné pro~návrháře,
jelikož zpravidla umožňují použití
aritmetických rovnic a nerovnic.
Takovými formulemi lze popsat velké množství modelů systémů,
přesto jsou však v~některých případech stále nedostatečné.
A těchto případů rozhodně není málo:
jedná se právě o~případy, kdy je nutné
do~modelu zahrnout fyzikální, chemické aj.
jevy z~reálného světa,
pro~které je zcela přirozené,
že jsou popsány \name{obyčejnými diferenciálními rovnicemi}
(\name{\acr{ode}}, angl. \name{\acrl{ode}}),
které v~obecném případě problém \acr{smt} neovládá.
Systémy, které jeví jak diskrétní rysy
(např. Booleovské proměnné),
tak spojité rysy (např. \acr{ode}),
se nazývají \name{hybridní}.
Jedním z~cílů této práce je odpovědět na otázku,
jak tyto problémy efektivně skloubit dohromady,
a jak popsat a ověřit modely hybridních systémů.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Thu 03 May 2018 10:43:19 PM CEST
\begin{section}{Cíl práce}\label{s:intro:goal}
\acr{smt} řešiče a řešiče diferenciálních rovnic
již existují, ale většinou jen separátně.
Existují i~řešiče, které již obě domény kombinují,
nicméně zatím se jeví jako těžko uplatnitelné v~praxi,
protože jsou příliš pomalé.
Příčinou je to, že kladou důraz na~přesnost
a umožňují garanci maximální chyby.
Tento přístup se týká strany
\acr{ode} řešiče.

Mým úkolem bylo realizovat
odlišný přístup v~řešení \acr{ode}
pomocí \name{klasických numerických metod},
které neposkytují exaktní garance chyb
a mohou být méně přesné.
Od~tohoto postupu se však očekává,
že bude mnohem rychlejší,
a tedy i~použitelný v~praxi.
Vzhledem ke~komplexnosti problému
se nemá jednat o~koncový produkt,
nýbrž jen o~prototyp.
I~ten by však měl
pro~některé praktické úlohy
vykazovat vyšší výkon,
než stávající řešiče.

Předpokládaným postupem práce
bylo vhodně zvolit
oba jednotlivé existující řešiče,
definovat společný vstupní jazyk,
implementovat řešiče či jejich adaptéry
a propojit je.
Na~závěr pak ve~výsledném nástroji
experimentovat s~různými modely hybridních systémů
a výsledky porovnat s~některým stávajícím řešičem.

% Motivace
Mou osobní motivací bylo zejména mé zalíbení
v~\acr{sat} řešičích, se kterými jsem v~minulosti reálně pracoval,
a obecně ve~formální verifikaci.

% Struktura a návaznost
Text této práce postupuje od~teoretických podkladů
přes rozbor možných řešení formulovaných problémů,
návrh a následně realizaci zvoleného řešení,
a končí experimentální částí,
která se zabývá konkrétními příklady modelů,
měřením výkonnosti a srovnáním nástroje se~stávajícími řešiči.
Zvídavému čtenáři by nemělo uniknout
množství příloh obsahujících
přídavné informace a příklady.
\end{section} %%Cíl práce

%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Thu 03 May 2018 11:16:31 PM CEST
\begin{section}{Požadavky zadání}\label{s:intro:req}
Zadání požaduje propojení existujících \acr{smt} a \acr{ode} řešičů
a s~tím související úkoly:
\begin{itemize}
\item provést potřebnou rešerši (viz.~dále),
\item navrhnout společné rozhraní
   a vstupní jazyk pro~\acr{smt} i~\acr{ode}
   na~základě \name{\acr{smt}-LIB} standardu~\cit{smtlib},
\item připojit \acr{ode} řešič používající klasické numerické metody,
\item navrhnout řídící algoritmus,
\item implementovat návrh,
\item srovnat výsledný nástroj s~existujícími hybridními
   řešiči a dosáhnout pokud možno větší výkonnosti.
\end{itemize}
\end{section} %%Požadavky zadání

%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{section}{Rešerše}\label{s:intro:search}
Zadání vyžadovalo seznámení se
s~uvedenými problémy a existujícími nástroji:
\begin{itemize}
\item teoretické podklady problémů \acr{sat}, \acr{smt} a \acr{ode},
\item obecné možnosti řešení problémů,
\item rešerše samostatných \acr{smt} řešičů
   a analýza jejich použití,
\item studování \acr{smt}-LIB standardu,
\item rešerše \acr{ode} řešičů, které používají klasické numerické metody,
   a analýza jejich použití,
\item seznámení se se~stávajícími hybridními řešiči,
   které ale používají pomalou intervalovou aritmetiku,
\item inspirovat se zejména těmito řešiči
   při~návrhu řídícího algoritmu.
\end{itemize}
\end{section} %%Rešerše

%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{introduction}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Sat 24 Mar 2018 10:19:00 AM CET
\chapter{Teoretická část}\label{ch:theory}
V~této kapitole se zabývám
teoretickými podklady problémů spjatými s~touto prací.
Pojmy neuvádím zcela přesně,
spíše dávám přednost srozumitelnosti.
Tato práce klade větší důraz na~praktickou část.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Fri 09 Mar 2018 12:23:51 AM CET
\begin{section}{Formulace problémů}\label{s:theory:formulation}
Tato sekce popisuje konkrétní problémy a jejich varianty,
kterými se v~této práci zabývám.
Možnosti jejich řešení jsou uvedeny až v~následující sekci rešerše řešičů.

%%%%%%%%%%%%%

% Tue 20 Mar 2018 09:36:48 PM CET
\begin{subsection}{Problém splnitelnosti: \acr{sat}}
label{ss:theory:formulation:sat}
Problém splnitelnosti Booleovské formule
je základním problémem
ze~třídy \acr{np}-úplných problémů%
\footnote{U~tohoto \acr{np} problému
bylo jako u~prvního prokázáno,
že na~něj lze v~polynomiálním čase převést
jakoukoli úlohu ze třídy \acr{np}~\cit{cook-art}.}
v~oboru teorie složitosti.
Jedná se o~široce studovaný problém
implementovaný v~řadě velmi efektivních specializovaných řešičů,
které jsou využívány v~různých aplikacích,
díky možnosti převoditelnosti.
Přestože se jedná o~těžký problém,
i~rozsáhlé praktické instance
(např. se stovkami tisíc proměnných)
je možné řešit rychle,
neboť výskyt instancí s~těmi nejobtížnějšími kombinacemi
je v~praxi nepravděpodobný.

\acr{sat} je definován jako úloha nalezení ohodnocení
Booleovských proměnných \vec{y}
ve~formuli $F$ v~Booleově algebře,
tj.
\begin{equation}\label{eq:sat}
   \exists \vec{y} : \: F(\vec{y}) = 1
\end{equation}
Výstupem je buď nalezené ohodnocení \vec{y},
nebo (typicky) \id{unsat} v~případě, že formule není splnitelná.

Základní verze obsahuje existenční kvantifikátor $\exists$.
Pokud je použit obecný kvantifikátor $\forall$,
jedná se o~problém tautologie, který je co-\acr{np}-úplný
(doplněk k~\acr{np}-úplnému).
Pokud je povolena kombinace obou kvantifikátorů,
hovoříme o~problému \name{kvantifikované Booleovské proměnné}
(angl. \name{\acr{qbf}})
a dostáváme se o~třídu složitosti výše.

Existují i~optimalizační varianty tohoto problému,
často ve~formě vážené splnitelnosti,
kde proměnné nebo klauzule mají přiřazeny váhy
a úkolem je nalézt řešení s~maximální vahou
proměnných či klauzulí, které jsou či nejsou splněny, apod.

%%%

% Wed 07 Mar 2018 04:44:23 PM CET
\begin{paragraph}{\acrf{bmc}}\label{p:theory:formulation:sat:bmc}
(omezené ověření modelu)
je jedna z~hlavních aplikací \acr{sat} problému,
které slouží k~automatizované formální verifikaci
systému reprezentovaného přechodovým systémem~\cit{bmc-art}.
Hlavním cílem je dokázání správnosti modelu,
tj. zda není možné dospět do~zakázaných stavů.
K~účelům specifikace takových přechodových systémů
se používá temporální logika,
většinou \acr{ltl} nebo \acr{ctl}.

Základní myšlenka techniky \acr{bmc} spočívá
v~symbolickém nalezení protipříkladu,
který má omezenou délku, vůči zkoumané formuli ze specifikací.
Využívá \acr{sat} řešiče~---~nalezení
ohodnocení proměnných znamená nalezení protipříkladu,
neboli porušení specifikací.
Opačný případ je obtížnější,
neboť teprve projití cest pokrývajících všechny dosažitelné stavy
dokazuje, že zakázané stavy nemohou nastat,
což může vyžadovat prohledání obrovského stavového prostoru.
Algoritmus se tedy opakuje se zvyšující délkou zkoumaných cest
dokud není nalezen protipříklad,
nebo dokud není dosaženo maximální meze.

Alternativní použití \acr{bmc} spočívá ve~zkoumání
negované formule~---~potom nalezení protipříkladu
omezené délky naopak znamená,
že formule je vždy splněna.
\end{paragraph} %% \acrf{bmc}

%%%

\end{subsection} %%Problém splnitelnosti: \acr{sat}

%%%%%%%%%%%%%

% Sat 24 Mar 2018 07:06:03 PM CET
\begin{subsection}{\acrf{smt}}\label{ss:theory:formulation:smt}
Jedná se o~rozšíření problému \acr{sat}
o~další domény než je Booleova algebra,
tzn. dokáže operovat i~s~proměnnými,
jejichž definiční obor je rozsáhlejší než jen
${\{0,1\}}$, nemusí být dokonce ani \hl{konečný}%
\footnote{Zatím se bavíme o~matematickém modelu,
v~konečném důsledku jsou však domény v~implementacích
vždy konečné, protože počítače mají omezenou velikost.
Univerzum však není v~\acr{smt} podstatné.}
(např. v~našem případě kombinování s~\acr{ode}
jsou typickou doménou reálná čísla).
Stále je hlavním zájmem ověřování
splnitelnosti vstupních formulí.

Klíčovým pojmem v~\acr{smt} je \name{teorie},
která je zodpovědná za~definování
funkcí a pravidel nad~jejími prvky.
Speciálním případem teorie je
též teorie Booleovy algebry,
která bývá v~\acr{smt} řešičích
implementována jako teorie základní.

Hlavní motivací \acr{smt} oproti \acr{sat}
je využití aritmetických funkcí a pravidel,
které zlepšují vyjadřovací schopnosti daného jazyka.
Řešení \acr{smt} může být také efektivnější,
než kdyby byla formule celá zakódována do~\acr{sat}.
Složitost rozhodování \acr{smt} se ale dramaticky liší
s~ohledem na~zvolenou teorii: může být i~polynomiální,
ale i~horší než exponenciální~\cit{theories-book}.

%%%%%%%

% Sat 24 Mar 2018 10:28:42 AM CET
\begin{subsubsection}{Teorie}\label{p:theory:formulation:smt:theory}
Teorie prvního řádu (angl. \name{First-order theory})
je vyjádřena v~predikátové logice prvního řádu%
\footnote{Vyšší řády povolují predikáty uvnitř predikátů či funkcí apod.}.
Teorie definuje konečně mnoho pravidel
nad~\hl{abstraktními} prvky,
tj.~aniž by definovala jejich univerzum;
postup je opačný~---~přípustné prvky
jsou určeny výhradně jako důsledek pravidel teorie.

%%%

% Sat 24 Mar 2018 11:23:29 AM CET
\begin{paragraph}{(Predikátová) logika prvního řádu}
\label{p:theory:formulation:smt:theory:fol}
(angl. \name{\acrfc{fol}}).
Hlavní rozdíl oproti Booleově algebře
(resp. výrokové logice)
je ten, že termy formulí mohou být hodnoty
libovolné domény~\cit{theories-book}.

Formule \acr{fol} se skládají
z~proměnných a konstant, predikátů, funkcí,
logických operací a kvantifikátorů.
Termy jsou konstanty, proměnné a funkce.
Predikáty jsou funkce,
které nabývají jen logických hodnot.
Literál je logická proměnná či konstanta,
predikát, nebo jejich negace.

Interpretace formule přiřazuje
elementy, funkce a predikáty nad~nějakou konkrétní doménou
symbolům konstant či proměnných, funkcí a predikátů formule.
Formule je nazývána jako splnitelná,
pokud existuje interpretace,
v~níž je formule vyhodnocena jako pravdivá.
Splnitelnost je primárním rozhodovacím problémem ve~\acr{fol}.

Formální jazyk \acr{fol} je definován jako množina
správně formovaných formulí,
které jsou splnitelné.
Jazyk je \name{rozhodnutelný},
pokud existuje konečný algoritmus,
který korektně rozhoduje,
zda libovolné slovo patří či nepatří do jazyka.
\end{paragraph} %%(Predikátová) logika prvního řádu

%%%

\bigskip

\acr{fol} obecně není rozhodnutelná,
některé teorie však ano.
Důležité u~teorií
(či alespoň některých jejich podmnožin)
je zejména to,
aby byly rozhodnutelné efektivně,
a ne nutně obecně,
ale v~praktických případech.
Díky rozhodnutelnosti lze pak formule
automatizovaně analyzovat.

%%%

% Sat 24 Mar 2018 01:06:59 PM CET
\begin{paragraph}{Definice.}\label{p:theory:formulation:smt:theory:def}
Teorie je definována
\name{značením} a množinou \name{axiomů}.
Značení je množina symbolů konstant, funkcí a predikátů
bez konkrétního významu.
Axiom je uzavřená \acr{fol} formule
obsahující pouze prvky ze~značení teorie.
Formule teorie mohou proti axiomům
navíc obsahovat proměnné, logické operace
a kvantifikátory.
\end{paragraph} %%Definice.

%%%

\bigskip

\name{Fragment} teorie je její podmnožina přípustných formulí.
Častým fragmentem teorií
je fragment bez~kvantifikátorů%
\footnote{Tyto formule však stále implicitně obsahují
univerzální kvantifikátory pro~všechny proměnné.}.
Fragmenty jsou užitečné zejména v~případech,
kdy jsou lépe rozhodnutelné.
Obecně lze říci,
že čím limitovanější teorie je,
tím má blíže k~rozhodnutelnosti%
\footnote{\acr{fol} je též teorie,
ale nijak limitovaná~---~bez axiomů.}.

Součástí každé formule teorie
jsou implicitně také všechny její axiomy.
Proto je nutné vždy uvést, jaká teorie má být použita.
Příklady teorií jsou teorie celých či reálných čísel
a teorie různých datových struktur
(pole, seznam, bitový vektor, fronta, hash tabulka, \dots)
apod. Základní příklady jsou rozvedeny dále podle~\cit{theories-book}.

%%%

% Sat 24 Mar 2018 01:59:38 PM CET
\begin{paragraph}{Teorie rovnosti.}
\label{p:theory:formulation:smt:theory:equal}
Kromě symbolů konstant, funkcí a predikátů
obsahuje jen jediný interpretovaný binární predikát $=$,
jehož chování je definováno axiomy:
\begin{enumerate}
\item \name{Reflexivita}:
   $\forall x : \: x = x$
\item \name{Symetrie}:
   $\forall x,y : \: x = y \Rightarrow y = x$
\item \name{Tranzitivita}:
   $\forall x,y,z : \: x = y \: \land \: y = z \Rightarrow x = z$
\item \name{Funkční kongruence}:
   $\forall \vec{x},\vec{y} : \:
      \left( \forall i = 1, \dots, n : \: x_i = y_i \right)
      \Rightarrow f(\vec{x}) = f(\vec{y})$ \\
   pro~všechna kladná přirozená čísla $n$ a $n$-ární funkce $f$.
\item \name{Predikátová kongruence}:
   $\forall \vec{x},\vec{y} : \:
      \left( \forall i = 1, \dots, n : \: x_i = y_i \right)
      \Rightarrow p(\vec{x}) \Leftrightarrow p(\vec{y})$ \\
   pro~všechna kladná přirozená čísla $n$ a $n$-ární predikáty $p$.
\end{enumerate}

Teorie rovnosti je nerozhodnutelná stejně jako \acr{fol},
protože povoluje všechna značení (obsahující $=$).
Nicméně, fragment bez~kvantifikátorů
už je efektivně rozhodnutelný.
\end{paragraph} %%Teorie rovnosti.

%%%

% Sat 24 Mar 2018 04:29:35 PM CET
\begin{paragraph}{Teorie celých čísel.}
\label{p:theory:formulation:smt:theory:int}
Existují tři základní teorie celých čísel:

\hll{Peanova aritmetika} má značení
$\{ {0, 1}, {+, \cdot}, = \}$
(${0,1}$ jsou konstanty;
${+,\cdot}$ binární funkce;
a $=$ binární predikát)
a následující axiomy:
\begin{enumerate}
\item $\forall x : \: \neg ( x + 1 = 0 )$
\item $\forall x,y : \: x+1 = y+1 \Rightarrow x = y$
\item \label{i:theory:int:ind}
   $F(0) \: \land \: \left( \forall x : \: F(x) \Rightarrow F(x+1) \right)
      \Rightarrow \forall x : \: F(x)$
\item $\forall x : \: x+0 = x$
\item $\forall x,y : \: x + (y+1) = (x+y) + 1$
\item \label{i:theory:int:times0}
   $\forall x : \: x \cdot 0 = 0$
\item \label{i:theory:int:timessuc}
   $\forall x,y : \: x \cdot (y+1) = x \cdot y + x$
\end{enumerate}
Tyto axiomy definují sčítání, násobení a rovnost
přirozených čísel a také \name{indukci}
(axiom \rf{i:theory:int:ind}).
Tato teorie bohužel není rozhodnutelná
(ani bez~kvantifikatorů;
na vině je operace násobení)
a dokonce není ani úplná%
\footnote{Tj.~existují v~ní formule, které nelze dokázat.}.

\hll{Presburgerova aritmetika} vychází z~Peanovy,
ale vynechává operaci násobení,
a tedy i~axiomy \rf{i:theory:int:times0} a \rf{i:theory:int:timessuc}.
Tato teorie je již rozhodnutelná,
a to dokonce i~s~kvantifikátory.
Operace odčítání a nerovností je možné modelovat%
\footnote{Odčítání převedením na~druhou stranu rovnosti,
a nerovnosti přičtením nové konstanty do~rovnosti.},
a je tedy možné vyjádřit celou teorii celých čísel
bez~násobení.

\hll{Teorie celých čísel} má stejné vyjadřovací schopnosti
jako Presburgerova aritmetika,
ale má přirozenější a přívětivější značení:
obsahuje všechna celá čísla jako konstanty,
operaci odčítání a predikáty nerovností.
Také obsahuje unární funkce
umožňující používat celočíselné násobky proměnných.

Nadále budou používány dva pojmy:
\hl{lineární}, resp. \hl{nelineární}
teorie celých čísel
jako teorie celých čísel bez~násobení,
resp. s~násobením.
\end{paragraph} %%Teorie celých čísel.

%%%

% Sat 24 Mar 2018 05:39:05 PM CET
\begin{paragraph}{Teorie reálných čísel.}
\label{p:theory:formulation:smt:theory:real}
I~zde se teorie dělí na \hl{lineární} a \hl{nelineární}
s~ohledem na~použití operace násobení.

\hll{Nelineární teorie reálných čísel}
bývá také označována jednoduše jako teorie reálných čísel.
Má značení $\{ {0, 1}, {+, -, \cdot}, =, \geq \}$
a obsahuje komplexní axiomatizaci
zahrnující všechny axiomy:
\begin{enumerate}
\item \hl{tělesa} nad~${(+, \cdot)}$
   (tj.~axiomy Abelovské grupy nad~${(+)}$ a okruhu nad ${(\cdot)}$),
\item úplného uspořádání $\geq$,
\item uspořádaného tělesa
   (navíc uspořádanost sčítání a násobení),
\item existence kvadratického kořene pro~všechny elementy,
\item existence alespoň jednoho kořene všech polynomů lichého stupně.
\end{enumerate}
Tato teorie je rozhodnutelná i~s~násobením,
nicméně asymptotická složitost rozhodovací procedury
je dvojnásobně exponenciální.

\hll{Lineární teorie reálných čísel},
také označována jako teorie racionálních čísel%
\footnote{Důvod je ten, že každá interpretace teorie,
vzhledem k~jejím axiomům,
je ekvivalentní s~použitím
jak domény reálných, tak racionálních čísel.},
omezuje nelineární teorii reálných čísel
vyjmutím operace násobení
a s~tím i~axiomů pro~násobení a existenci kořenů;
k~tomu přidává axiom, že neutrální prvek ($0$)
je jediným prvkem s~konečným řádem v~Abelovské grupě nad~($+$);
a axiom o~dělitelnosti prvků
(každý prvek je sumou jiného prvku).
Horní asymptotická složitost se u~této teorie sice nezměnila,
ale v~průměru je tato teorie efektivně rozhodnutelná,
zejména její fragment bez~kvantifikátorů.
\end{paragraph} %%Teorie reálných čísel.

%%%

\bigskip

Teorie mohou být navzájem \hl{kombinovány}
(např. teorie polí společně s~teorií celých čísel)
při~splněných určitých podmínek,
např. jejich značení by měla být,
až na výjimku predikátu $=$, disjunktní
(jinak je nutné společné symboly
zavést nově).
Tato možnost je poměrně důležitá,
jinak by bylo zavádění kombinace teorií
jako explicitní nové teorie komplikované.
\end{subsubsection} %%Teorie

%%%%%%%

\end{subsection} %%\acrf{smt}

%%%%%%%%%%%%%

% Wed 21 Mar 2018 01:56:56 AM CET
\begin{subsection}{\acrf{ode}}\label{ss:theory:formulation:ode}
Diferenciální rovnice je rovnice pro~nějakou \hl{neznámou} funkci
a obsahující její derivace,
což je běžné pro~fyzikální vztahy reálného světa.
\hl{Obyčejná} diferenciální rovnice (\name{\acr{ode}})
obsahuje derivace vztažené pouze
k~\hl{jediné nezávislé proměnné},
což je zpravidla čas~\cit{ode}.
Řešení tohoto speciálního případu je obecně mnohem jednodušší,
přesto však stále není obecně možné nalézt analytické řešení,
a proto se používají numerické metody~\cit{odeint-art}.

Kromě omezení na~\acr{ode} dále vymezuji
následující vlastnosti:
diferenciální rovnice je \name{prvního řádu}%
\footnote{Rovnice obsahuje pouze první derivace,
což však není omezující,
neboť každá rovnice vyšších řádů
lze přepsat na~soustavu rovnic prvního řádu%
~\cit{ode-valid-runge_kutta-art}\cit{ode-lec}.},
má pevné počáteční podmínky~---~\name{\acrf{ivp}},
a je \name{explicitní}%
\footnote{Derivace funkce je řešena explicitně,
tj.~nevyskytuje se jako argument jiné funkce.}.

Existuje několik možných formulací tohoto problému,
zde je definován jako hledání řešení soustavy rovnic
$n$ neznámých funkcí
(s~výše uvedenými vlastnostmi):
\begin{equation}\label{eq:ode}
\begin{split}
   \vec{\der{y}}(t) &= \vec{f} \! \left( t, \vec{y}(t) \right) \\
   \vec{y}(t_0)     &= \vec{y_0}
\end{split}
\end{equation}
kde ${t \in \set{R}}$ je nezávislá proměnná a \set{R}
je množina reálných čísel;
${\forall i = 1,} \dots, n : \:
{y^i \in \vec{y}} : \: {\set{R} \rightarrow \set{R}}$
je neznámá diferencovatelná funkce $t$,
${\der{y}^i \in \vec{\der{y}}}$ je derivace $y^i$ podle $t$,
a ${f^i \in \vec{f}} : \: {\set{R}^{n+1} \rightarrow \set{R}}$
je funkce Lipschitz-spojitá v~\vec{y}\,%
\footnote{Tento předpoklad podle Picard--Lindelöfova teorému zaručuje,
že řešení takové \acr{ode} existuje právě jedno; viz.~\cit{ode-lec}.};
${t_0 \in \set{R}}$ je počáteční hodnota nezávislé proměnné $t$,
která společně s~${\vec{y_0} \in \set{R}^{n}}$ určuje počáteční podmínky.
Pro~jednoduchost nejsou uvažovány případy,
kdy některá funkce není definována na~celé \set{R}.

Vztahy \rfeq{ode}
lze přepsat do~ekvivalentního tvaru s~integrálem~\cit{ode-lec}:
\begin{equation}
   \vec{y}(t) = \vec{y_0} + \int_{t_0}^{t} \vec{f} \!
      \left( \tau, \vec{y}(\tau) \right) \, \text{d}\tau
\end{equation}
proto bývají někdy numerická řešení \acr{ode}
nazývány jako \name{numerická integrace}.
\end{subsection} %%\acrf{ode}

%%%%%%%%%%%%%

\end{section} %%Formulace problémů}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Sat 24 Mar 2018 10:42:01 AM CET
\begin{section}{Hybridní systémy}\label{s:theory:hybrid}
(Dynamický) systém se nazývá \name{hybridním},
pokud vykazuje jak diskrétní, tak spojité změny.
Diskrétní změny je charakterizováno \name{skoky} (angl. \name{jumps}),
spojité \name{toky} (angl. \name{flows}).
Skoky jsou obvykle popsány \name{konečným automatem},
toky pomocí soustav \acr{ode}.

Diskrétní systémy se používají pro~jejich snadný návrh a analýzu;
spojité zejména proto, že popisují procesy z~reálného světa
(fyzikální, chemické, biologické, \dots),
jelikož čas je spojitý.
Všechny digitální počítače jsou diskrétními systémy
s~omezenou přesností,
je na~nich však možné spojité jevy aproximovat.

Hybridní systémy musejí interagovat s~vnějším světem,
často v~reálném čase.
Jedná se tedy o~\name{reaktivní} systémy.
Obvyklými požadavky na~tyto systémy
jsou (kromě jiných) spolehlivost a bezpečnost%
\footnote{V~tomto případě je míněna
bezpečnost z~hlediska spolehlivého selhání
neohrožující majetek či lidi (angl. safety).
Bezpečnost ve~významu zabezpečení
vůči neautorizovanému přístupu (angl. security)
je často také důležitá.}.
Aby mohly být tyto vlastnosti do~vysoké míry zaručeny,
je nutné využít matematický aparát.

%%%

% Sat 17 Mar 2018 11:03:23 AM CET
\begin{paragraph}{Hybridní automat.}\label{s:theory:hybrid:auto}
Hybridní systém lze jako celek
matematicky modelovat jako \name{hybridní automat}.
\name{Stav} hybridního automatu
je definován diskrétním řídícím \name{módem}
a spojitými \name{proměnnými}.
Diskrétní změna stavu odpovídá skoku
(v~konečném automatu),
spojitá změna pak toku
(průběhu \acr{ode}).
Módy mohou mít také definovány \name{invarianty}.

Analýza hybridního systému pak spočívá
v~rozhodování o~množině stavů,
zda je dosažitelná či naopak
a za jakých podmínek.

Existuje několik nástrojů
analyzujících hybridní systémy
modelované jako hybridní automaty,
ale většinou nejsou založeny
na~problému \acr{smt}.
\cmt{Proč? Proč je to lepší/horší?}
\end{paragraph} %%Hybridní automat.

%%%

\bigskip

Obě domény samostatně se dnes
používají standardně pro~modelování systémů
a jejich analýzu;
k~tomu jsou hojně využívány
\acr{sat} či \acr{smt} řešiče pro~diskrétní
a \acr{ode} řešiče pro~spojité systémy.
Výzvou této práce je obě domény efektivně kombinovat
a zároveň využít nástrojů
vycházejících z~fenoménu problému \acr{sat}.
\end{section} %%Hybridní systémy

%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Sat 24 Mar 2018 07:35:28 PM CET
\chapter{Možnosti řešení problematiky}\label{ch:search}
V~této kapitole rozebírám možnosti řešení problémů
uvedených v~kapitole \rf{ch:theory}
a provádím rešerši existujících řešičů.
Uvedené řešiče jsou jak izolované (jen \acr{smt} či \acr{ode}),
tak hybridní (kombinují oba problémy),
ale s~odlišným typem \acr{ode} řešiče, než na jaký jsme cílili.
Pro~úplnost také uvádím sekci ohledně řešení problému \acr{sat}.

U~řešičů zmiňuji více či méně podrobně
jejich vlastnosti a zdůvodňuji proč jsem je použil či nepoužil.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Tue 06 Mar 2018 11:22:22 PM CET
\begin{section}{\acr{sat} řešiče}\label{s:search:sat}
Ač zde uvádím tuto kategorii řešičů,
používal jsem je jen nepřímo,
neboť jsou součástí \acr{smt} řešičů.

Z~důvodů implementačních a konvence
je většinou vstup do~řešičů uváděn
v~konjuktivní normální formě (angl. \acr{cnf}),
neboli jako konjunkce klauzulí,
kde klauzule je disjunkce literálů.
Standardně se používá \acr{dimacs}-\acr{cnf} formát.

Většina dnešních \acr{sat} řešičů
využívá v~základu algoritmus \acrf{dpll},
který používá několik hlavních operací~\cit{smt-de_moura}:
\begin{itemize}
\item základní simplifikace klauzulí,
\item \hl{substituce}~---~přiřazení hodnoty proměnné,
\item \hl{propagace}~---~aplikace deduktivních pravidel,
   zejména pravidla jednotkové klauzule%
   \footnote{Klauzule s~jediným literálem
   vynucuje jednoznačné ohodnocení této proměnné, aby mohla být celá
   \acr{cnf} formule splněna.},
\item \hl{návrat}~---~navrácení do~nějakého předchozího bodu substituce
   při~nalezení konfliktních ohodnocení.
\end{itemize}

Každý lepší řešič také implementuje nějakou formu učení,
které spočívá v~přidávání dalších klauzulí
na~základě průběžně nacházených konfliktů.

Známými \acr{sat} řešiči jsou např. Mini\acr{sat}~\cit{minisat}%
\footnote{Mini\acr{sat} zvítězil
ve~všech průmyslových kategoriích
v~soutěži \name{\acr{sat} 2005 competition}
a je často integrován pro~svůj
minimalistický a snadno rozšiřitelný návrh.},
Pico\acr{sat} a CryptoMini\acr{sat}.
Příklady použití \acr{sat} řešičů jsou:
\begin{itemize}
\item \acrf{bmc},
\item funkční testování obvodů:\\
   logický obvod s~injektovanou poruchou
   je převeden do~Booleovské formule
   a je ověřena její splnitelnost,
\item statická analýza kódu programu,
\item plánování a grafové problémy
\end{itemize}
a mnoho dalších. Obecně se však většinou jedná
o~nějakou formu formální verifikace.
\end{section} %% \acr{sat} řešiče

%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Mon 09 Apr 2018 02:31:50 PM CEST
\begin{section}{Řešení \acr{smt} problému}\label{s:search:smt}
Jak už bylo zmíněno v~sekci \rf{ss:theory:formulation:smt},
zásadní vliv na~výpočet má teorie použitá ve~vstupní formuli.
\acr{smt} řešiče typicky ovládají jen některé teorie
a jejich fragmenty, nebo některé rozhodují jen s~omezenou efektivitou.

Řešič má za~úkol nalézt splňující ohodnocení
pro~všechny termy vstupní formule,
které se nazývá \name{model}.
Výstupem pak je zpravidla \id{sat} a (volitelně) model.
Pokud formule není splnitelná,
řešiče většinou umožňují vygenerovat
\hl{důkaz} jako certifikát dokládající nesplnitelnost.
Výstupem pak je zpravidla \id{unsat}
a (volitelně) důkaz.
Také se může stát,
že o~splnitelnosti vstupu není možné rozhodnout
(např. pokud řešič nemá implementovány
všechny funkcionality nutné pro~daný vstup).
Výstupem pak může být např. \id{unknown}.

Existují dva základní přístupy k~řešení \acr{smt} problémů:
\name{pilný} (angl. \name{eager}) a \name{líný} (angl. \name{lazy}),
nebo i~jejich kombinace~\cit{smt-stanford}.

%%%

% Sat 10 Mar 2018 03:55:11 PM CET
\begin{paragraph}{Pilný přístup}\label{p:search:smt:eager}
soustředí většinu výpočtů
do~\hl{externího} \acr{sat} řešiče tak,
že se snaží v~\hl{jediném kroku} celou \acr{smt} formuli zakódovat
do~\acr{sat} formule (např. celá čísla pomocí bitů
jako Booleovských proměnných).

Výkonnost tohoto postupu je zcela závislá na~použitém \acr{sat} řešiči
a nevyužívá zřejmých faktů vázaných k~dané teorii
(např. komutativita)~\cit{smt}.
Na~druhou stranu je z~hlediska rozhraní a výpočtu
v~podstatě nezávislý na~použitém \acr{sat} řešiči.
Je flexibilnější než druhý přístup,
protože část specifickou pro~teorii tvoří \uv{jen}
optimalizovaný překlad formule,
samotný výpočet už ne.
\end{paragraph} %%Pilný přístup

%%%

% Sun 18 Mar 2018 10:32:18 PM CET
\begin{paragraph}{Líný přístup}\label{p:search:smt:lazy}
spočívá v~použití \acr{sat} řešiče
založeném na~\acr{dpll}
a \set{T}-řešiče
jako dvou více či méně \hl{spolupracujících komponent}
(varianty \name{online} a \name{offline}~\cit{smt-stanford}),
kde \set{T} je nějaká teorie.

Predikáty teorie (resp. omezení, např. lineární nerovnice)
jsou překládány \set{T}-řešičem
na~abstraktní Booleovské literály,
které je interní \acr{sat} řešič schopen pojmout.
V~případě, že je taková formule splnitelná (nutná podmínka),
\set{T}-řešič je použit pro~ověření vytvořeného modelu,
zda je ohodnocení predikátů splnitelné i~v~dané teorii \set{T}.
Tento proces probíhá opakovaně
dokud není dosaženo konvergence~\cit{smt-de_moura}.
Tedy, oba řešiče navzájem intenzivně komunikují
a formování Booleovské formule probíhá (typicky) inkrementálně%
\footnote{To také umožňuje dynamicky
přídávat a odebírat formule s~omezeními.}
s~možností návratů.
V~případě \name{online} varianty jsou oba řešiče
více propojeny a \set{T}-řešič využívá funkce \acr{sat} řešiče přímo.

\set{T}-řešič musí být navržen
speciálně pro~danou teorii \set{T}, typicky \hl{ad hoc}.
\end{paragraph} %%Líný přístup

%%%

\bigskip

Dalším hlediskem je, zda je \acr{smt} řešič jako celek
\name{inkrementální}, který umožňuje
dynamické formování vstupních formulí
a vícenásobné ověřování splnitelnosti nad různými kontexty.
Neinkrementální řešič pracuje jen nad~jediným statickým kontextem
jakožto celým vstupem. Inkrementální umožňuje
průběžně přidávat či odebírat omezení,
která se typicky ukládají do~\hl{zásobníku}.
Ověření splnitelnosti pak lze provést kdykoliv
nad~obsahem vrcholu zásobníku.

\acr{smt} řešiče často pracují nad~kombinací více teorií
kvůli větší expresivitě.
V~takovém případě je z~hlediska výkonu
důležité udržovat teorie v~hierarchii
a v~každém kroku použít
jen nezbytně nutnou úroveň~\cit{smt-stanford}.

%%%%%%%%%%%%%

% Mon 09 Apr 2018 02:39:23 PM CEST
\begin{subsection}{\acr{smt}-LIB standard}\label{ss:search:smt:smtlib}
\acr{smt}-LIB je iniciativa
založená pro~účely rozvoje výzkumu a vývoje \acr{smt} řešičů,
jejíž nejvýznamnější činností
je standardizace teorií
a vstupně-výstupního jazyka pro~řešiče~\cit{smtlib}.
S~tím souvisí udržování komunity vývojářů
a souboru standardizovaných výkonnostních úloh (benchmarks),
ve~kterých jednotlivé týmy soutěží např. v~rámci \name{\acr{smt}-COMP},
podobně jako tomu je u~komunity \acr{sat} řešičů.

\acr{smt}-LIB jako teorie označuje
teorie v~základním znění bez~dalších omezení.
Pro~konkrétní fragment teorie,
ve~kterém je daná vstupní formule vyjádřena,
se používá termín \name{logika}.
Tyto logiky se pak navzájem kombinují
či se redukují jejich restrikce.
Z~pohledu řešiče (konformního s~tímto standardem)
se operuje pouze s~logikami;
teorie slouží pouze jako teoretický základ.

Pro~odlišení prvků pocházejících z~různých teorií
se používají \name{druhy} prvků (angl. \name{sort}),
které připomínají datové typy programovacích jazyků.
Proměnné ve~formuli jsou označovány jako konstanty%
\footnote{Proměnná by mohla vyvolávat dojem,
že lze do~proměnných, podobně jako v~programovacích jazycích,
dynamicky přiřazovat hodnoty, což nelze.};
pojmy term a predikát
nejsou používány~---~všechny konstrukty
formule \acr{fol} jsou vyjádřeny
pomocí konstant a funkcí,
které jsou případně logického druhu.

Momentálně existuje verze 2 standardu,
která definuje hierarchii dílčích logik,
z~důvodu možnosti aplikace efektivnějších výpočtů pro~jednodušší formule,
a protože pak lze v~rámci izolovaných logik
efektivněji srovnávat řešiče navzájem.
Logiky povolují jen některé druhy konstant a funkcí
(podle použitých teorií)
a případně povolují i~definici volných druhů.

%%%

% Sat 24 Mar 2018 10:45:22 PM CET
\begin{paragraph}{Názvosloví logik.}\label{p:search:smt:smtlib:name}
Standard definuje konvence pro~pojmenování jednotlivých logik
podle použitých teorií, např.:
\begin{itemize}
\item \id{BV} (bit vectors)~---~teorie bitových vektorů omezené šířky,
\item \id{IA} (integer arithmetic)~---~teorie celých čísel,
\item \id{RA} (reals arithmetic)~---~teorie reálných čísel,
\item \id{IRA}~---~kombinace \id{IA} a \id{RA},
\end{itemize}
a jejich fragmentů jako předpony:
\begin{enumerate}
\item \id{QF\_} (quantifier-free)~---~fragment bez~kvantifikátorů,
\item \id{UF} (uninterpreted functions)~---~fragment povolující
   použití volných druhů prvků a neinterpretovaných funkcí,
\item \id{L}, resp. \id{N} (linear, resp. non-linear)~---~lineární,
   resp. nelineární fragment aritmetické logiky.
\end{enumerate}

Příklady některých logik:
\id{BV}, \id{UF}, \id{QF\_\-LRA}, \id{QF\_\-UFNRA}, \id{UFNIA}, \dots
\end{paragraph} %%Názvosloví logik.

%%%

\bigskip

Základní příkazy jazyka jsou deklarace či definice konstant a funkcí,
nových druhů, a přidávání formulí do \name{asercí}.
neboli podmínek, které musí být splněny.
Ověření splnitelnosti pak spočívá v~hledání ohodnocení
všech konstant a funkcí splňující konjunkci všech asercí,
podobně jako v~\acr{sat} řešičích.

Jazyk lze použít i~pro~inkrementální řešiče,
pro~které lze využít operací přidávání a odebírání
asercí ze~zásobníku.
Ověření splnitelnosti pak vždy probíhá
nad~vrcholem zásobníku.

Základní vlastnosti standardu verze~2
uvádí např. tento tutoriál~\cit{smtlib-tutorial-art}.
Podrobný popis \acr{smt}-LIB standardu verze 2.6
je k~nalezení v~referenčním dokumentu~\cit{smtlib-reference-art}.
\end{subsection} %%\acr{smt}-LIB standard

%%%%%%%%%%%%%

% Sat 24 Mar 2018 07:49:48 PM CET
\begin{subsection}{\acr{smt} řešiče}\label{ss:search:smt:solver}
\cmt{Všechny zde uvedené \acr{smt} řešiče používají
líný přístup \cmt{jakto?}.}
Použití \acr{smt} řešičů se do~značné míry kryje se \acr{sat} řešiči,
často je nahradily, resp. rozšířily.

%%%

% Sun 18 Mar 2018 10:04:17 PM CET
\begin{paragraph}{Open\acr{smt}}\label{p:search:smt:solver:opensmt}
(konkrétně jeho druhá verze)
je inkrementální open-source \acr{smt} řešič napsán v~jazyce C++,
který podporuje standardní iniciativu
\acr{smt}-LIB~\cit{opensmt}\cit{opensmt-art}.
Je postaven
nad~\acr{sat} řešičem Mini\acr{sat}2.
Nástroj byl implementován
s~důrazem na~snadnou rozšiřitelnost o~nové \set{T}-řešiče,
současně však zůstává efektivní%
\footnote{V~letech 2008 a 2009
byl oceněn v~soutěži \name{\acr{smt}-COMP}
jako nejrychlejší open-source \acr{smt} řešič
ve~čtyřech logikách ze~\acr{smt}-LIB.}.

Open\acr{smt} používá líný přístup.
Jeho architektura je dekomponována do~tří hlavních bloků:
preprocesor a \acr{sat} a \set{T}-řešič.
\set{T}-řešiče mají standardizované rozhraní,
které slouží ke~komunikaci se \acr{sat} řešičem a také vzájemné,
je-li použita kombinace více logik, a tedy \set{T}-řešičů.
\set{T}-řešiče lze také přizpůsobovat
konkrétním problémům,
v~případě že je lze řešit efektivněji než v~obecném případě.

Řešič lze v~aplikacích používat také odděleně
jako \name{černou skříňku} (angl. \name{black box}),
a to buď prostřednictvím volání funkcí \acr{api},
nebo zpracováním formule jako textového vstupu
(např. ve~formátu \acr{smt}-LIB).

\cmt{Vyjmenovat logiky}
\end{paragraph} %%Open\acr{smt}

%%%

% Wed 07 Mar 2018 02:06:57 PM CET
\begin{paragraph}{\acr{cvc}4}\label{p:search:smt:solver:cvc4}
je open-source \acr{smt} řešič~\cit{cvc4}.
Stejně jako Open\acr{smt} je navržen
pro~snadné rozšiřování a poskytuje rozhraní v~C++
a také rozhraní textové přes vstupní jazyk,
tzn. že nástroj lze použít jak jako knihovnu,
tak samostatně.

\acr{cvc}4 přijímá vlastní vstupní jazyk,
nebo standard \acr{smt}-LIB verze 1 nebo 2,
kde však neposkytuje plnou functionalitu
(nelineární aritmetiky nejsou zatím adekvátně podporovány).
Má již vestavěno několik základních teorií,
např. číselné aritmetiky, bitvektory, řetězce \dots
Podporuje kvantifikátory
a je schopen generovat modely.

\cmt{1. v~\acr{smt}-COMP 2017}
\cmt{složitější než Open\acr{smt}}
\cmt{Vyjmenovat logiky}
\cmt{\cit{cvc4-art}}
\end{paragraph} %%\acr{cvc}4

%%%

\end{subsection} %%\acr{smt} řešiče}

%%%%%%%%%%%%%

\end{section} %%Řešení \acr{smt} problému

%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Mon 12 Mar 2018 10:16:54 PM CET
\begin{section}{Numerické metody řešení \acr{ode}}\label{s:search:ode}
Tyto metody numericky \hl{aproximují} průběh \acr{ode}.
Obecně používají nějaký \name{krok},
který určuje vzdálenost mezi sousedními vypočítávanými body.
Krok může být fixní či variabilní.
Některé metody používají více kroků,
což kromě různých vzdáleností také znamená,
že hodnota bodů závisí na~více než jednom předchozím bodu.
Obecně platí, že čím menší je zvolený krok,
tím je menší odchylka od exaktního řešení,
ale současně vzrůstá výpočetní složitost.

%%%

% Mon 12 Mar 2018 10:16:43 PM CET
\begin{paragraph}{Značení.}\label{p:search:ode:sign}
$t_n$ je hodnota nezávislé proměnné $t$ v~$n$-tém kroku;
$h_n = {t_{n+1} - t_{n}}$ je vzdálenost mezi kroky v~$n$-tém kroku
($h$ pokud je délka konstantní);
${y_n \sim y(t_n)}$;
${f_n \sim f(t_n, y_n)}$.

O~metodě je volně řečeno, že je (má přesnost) \name{řádu} $p$,
pokud její odchylka aproximace od~exaktního řešení
konverguje k~${\set{O}( h^{\set{O}(p)} )}$\:%
\footnote{Jedná se o~intiutivní definici,
přesné definice řádu metody,
lokální a globální chyby a dalších termínů
nalezne čtenář např. zde~\cit{ode-nsolve-intro}.}.
\end{paragraph} %%Značení.

%%%

\bigskip

Metody řešení \acr{ode} se dělí
na~\name{explicitní} a \name{implicitní}.
Explicitní metody počítají každý bod explicitně
pouze na~základě dosud zjištěných hodnot, např.
\begin{equation}\label{eq:ode:explicit}
   y_{n+1} = y_n + h f_n
\end{equation}
kdežto implicitní získávají každý bod implicitně z~řešení rovnice,
která obsahuje i~dosud neznámé hodnoty, např.
\begin{equation}\label{eq:ode:implicit}
   y_{n+1} = y_{n} + h f_{n+1}
\end{equation}
Explicitní metody jsou časově efektivnější,
ale nehodí se pro~řešení
\name{rovnic se silným tlumením} (angl. \name{stiff})%
\footnote{Pro rovnice se silným tlumením
neexistuje přesná definice.
Jsou volně definovány
jako takové, kde je pro~explicitní metody buď nutné nastavit
velmi malou velikost kroku,
nebo je řešení nestabilní~\cit{ode-nsolve},
na rozdíl od implicitních metod,
které mohou naopak být stabilní
i~pro~jakoukoli zvolenou velikost kroku~\cit{ode-nsolve-intro}.
Tyto rovnice často obsahují funkce s~několika
časovými škálami s~rozdílnými granularitami.},
u~kterých je výpočet \hl{nestabilní}.
Implicitní metody jsou mnohem pomalejší, ale obecně stabilnější
a právě vhodné pro~tyto těžké rovnice~\cit{ode-nsolve-intro}.
Míra nestability se odvíjí od nutnosti nastavit co nejmenší krok tak,
aby byla odchylka od~exaktního řešení přijatelná.

Základní metodou pro~řešení \acr{ode}
je \name{Eulerova metoda},
která má jak explicitní
(vztah \rfeq{ode:explicit}),
tak implicitní
(vztah \rfeq{ode:implicit})
variantu,
kde $h$ může a nemusí být konstantní.
Metoda vychází ze standardní derivační aproximace~\cit{ode-nsolve-book}:
\begin{equation}\label{eq:der:apx}
   \der{y}(t) \approx \frac{y(t+h) - y(t)}{h}
\end{equation}
neboli posunu po~tečně ke křivce funkce.
Tato metoda je poměrně nepřesná,
ale je snadno pochopitelná
a většina numerických metod z~ní vychází~\cit{ode-nsolve-intro}.

Existují dvě známé rodiny metod pro~numerické řešení \acr{ode}:
\name{lineární vícekrokové metody}
a \name{metody Runge--Kutta}.
Obě skupiny souhrnně nazývám
\name{klasickými numerickými metodami}
a jsou uvedeny v~následující podsekci.
Již existující hybridní řešiče
však používají jiné metody než tyto,
případně jejich nadstavby.
Liší se tím,
že na~rozdíl od~klasických \acr{ode} řešičů
garantují rozsah chyby aproximace, ale jsou příliš pomalé.
Jejich princip je popsán v~další podsekci.

%%%%%%%%%%%%%

% Mon 12 Mar 2018 10:17:05 PM CET
\begin{subsection}{Klasické numerické metody}\label{ss:search:ode:classic}
Použití těchto metod bylo hlavním cílem této práce,
neboť jsou rychlejší než metody použité ve~stávajících hybridních řešičích.

Lineární vícekrokové i~Runge--Kutta metody sdílejí několik společných rysů:
\begin{itemize}
\item řeší \acr{ivp} \acr{ode} prvního řádu,
\item průběh funkce počítají na~základě jedné a více předchozích hodnot,
\item vyskytují se v~nich jak explicitní, tak implicitní metody,
\item spadá do~nich Eulerova metoda,
\item garantují konvergenci aproximační chyby
   ve~vztahu k~velikosti kroku $h$ a k~řádu $p$~\cit{ode-nsolve-book},
   nikoliv však její přesný rozsah,
\item výstupem jsou páry ${(t_n, y_n)}$.
\end{itemize}

Obě skupiny spadají do~\name{obecných lineárních metod}
jako speciální případy~\cit{ode-nsolve-intro},
toto zobecnění ale nebude v~tomto dokumentu diskutováno.

%%%%%%%

% Mon 12 Mar 2018 10:17:15 PM CET
\begin{subsubsection}{Lineární vícekrokové metody}
\label{sss:search:ode:classic:lmm}
Jedná se o~obvyklou variantu (obecných) vícekrokových metod.
Vícekrokové metody při~výpočtech využívají hodnoty několika předchozích kroků,
které se uchovávají a mohou být použity i~vícekrát.
Lineární varianta používá \hl{lineární kombinaci}
těchto hodnot~\cit{ode-nsolve-lec}:
\begin{equation}\label{eq:ode:lmm}
   \sum_{j=0}^{k} \alpha_{j} y_{n+j} =
      h \sum_{j=0}^{k} \beta_{j} f_{n+j}
\end{equation}
kde $k$ je počet zpětně sledovaných kroků,
${\alpha_{j} \in \set{R}}$ a ${\beta_{j} \in \set{R}}$ jsou konstanty,
přičemž ${\alpha_{k} \neq 0}$ a ${\alpha_{0} \neq 0 \lor \beta_{0} \neq 0}$.
Pro~${\beta_k = 0}$ je metoda explicitní, jinak je implicitní.
Podle $k$ je konkrétní metoda nazývána jako $k$-kroková.

Funkce $f$ je vyčíslována v~pravidelně rozložených bodech
(vyskytuje se vždy ve~formě $f_n$),
což umožňuje zpětné používaní těchto hodnot
při větším počtu kroků.
Je to hlavní důvod,
proč je počet vyhodnocení $f$
obecně menší, než u~Runge--Kutta metod,
které hodnoty předchozích mezikroků nevyužívají.
Pokud je vyčíslení $f$ náročné,
pak významně závisí na~jejím počtu~---~v~těchto případech
jsou tyto metody
většinou efektivnější než metody Runge--Kutta
v~rámci požadované přesnosti.
Nevýhodou těchto metod však je,
že je nutné prvních ${k-1}$ kroků spočítat jinou metodou
(kromě počátečních podmínek nejsou známy)~\cit{ode-nsolve-book}.

Následují příklady těchto metod
podle~\cit{ode-nsolve-lec} a \cit{ode-nsolve-book}.

%%%

% Sat 24 Mar 2018 08:09:54 PM CET
\begin{paragraph}{Eulerova metoda}\label{p:search:ode:classic:lmm:euler}
(vztahy \rfeq{ode:explicit} a \rfeq{ode:implicit}).
Získáme ji dosazením ${k = 1}$, ${\alpha_{1} = 1}$, ${\alpha_{0} = -1}$
a ${\beta_{1} = 0}$, ${\beta_{0} = 1}$ pro~explicitní,
resp. ${\beta_{1} = 1}$, ${\beta_{0} = 0}$ pro~implicitní variantu,
do~\rfeq{ode:lmm}.
Jedná se o~\hl{jednokrokovou} metodu řádu ${p = 1}$.
\end{paragraph} %%Eulerova metoda

%%%

% Sat 24 Mar 2018 08:24:43 PM CET
\begin{paragraph}{Lichoběžníková metoda:}\label{p:search:ode:classic:lmm:trap}
\begin{equation}\label{eq:ode:lmm:trap}
   y_{n+1} - y_{n} = \frac{h}{2} \left( f_{n+1} + f_{n} \right)
\end{equation}
(${k = 1}$, ${\alpha_{1} = 1}$, ${\alpha_{0} = -1}$,
${\beta_{1} = \beta_{0} = \frac{1}{2}}$)
je \hl{implicitní} a \hl{jednokroková}
metoda řádu ${p = 2}$.
\end{paragraph} %%Lichoběžníková metoda:

%%%

% Sat 24 Mar 2018 08:27:40 PM CET
\begin{paragraph}{Adams--Bashforthovy metody}
\label{p:search:ode:classic:lmm:adamsb}
jsou tvaru ${\alpha_{k} = 1}$, ${\alpha_{k-1} = -1}$,
$\alpha_{k-2} = \dots = \alpha_{0} = \beta_k = 0$,
a ${\forall_{j \neq k} \: \beta_{j}}$ jsou zvolena jednoznačně
pomocí interpolace polynomem%
\footnote{Jedná se o~aproximaci průběhu funkce $y$ pomocí polynomu $P$
tak, aby ${y(x_i) = P(x_i)}$ pro ${x_0, \dots, x_n}$.}
stupně~$q$ funkcí $f$ v~bodech ${t_{n+k-1}, \dots, t_{n}}$ tak,
aby ${q+1 = p = k}$.
Spadá sem tedy i~explicitní Eulerova metoda
(${q = 0}$, ${k = p = 1}$, vztah \rfeq{ode:explicit}).

Příklady dalších metod:
\begin{alignat*}{99}
   &q = 1, \: k~= p = 2 &&: \  y_{n+2} - y_{n+1} &&= \:
      & \frac{h}{2}\: & ( &    &         \: \: &    &         \: \:
      &  3 & f_{n+1} \:-\: &   & f_{n} ) \\
   &q = 2, \: k~= p = 3 &&: \  y_{n+3} - y_{n+2} &&= \:
      & \frac{h}{12}  & ( &    &         \: \: & 23 & f_{n+2} \:-\:
      & 16 & f_{n+1} \:+\: & 5 & f_{n} ) \\
   &q = 3, \: k~= p = 4 &&: \  y_{n+4} - y_{n+3} &&= \:
      & \frac{h}{24}  & ( & 55 & f_{n+3} \:-\: & 59 & f_{n+2} \:+\:
      & 37 & f_{n+1} \:-\: & 9 & f_{n} )
\end{alignat*}

Jsou to efektivní \hl{explicitní} $k$-krokové metody,
často používané pro~rovnice bez~silného tlumení.
\end{paragraph} %%Adams--Bashforthovy metody

%%%

% Sat 24 Mar 2018 08:32:38 PM CET
\begin{paragraph}{Adams--Moultonovy metody}
\label{p:search:ode:classic:lmm:adamsm}
mají shodný tvar s~Adams--Bashforthovými metodami
s~těmi rozdíly, že jsou \hl{implicitní},
tj.~${\beta_k \neq 0}$,
a ${q+1 = p = k+1}$
s~výjimkou pro~${q = 0}$, kde ${k = 1}$
(implicitní Eulerova metoda, vztah \rfeq{ode:implicit}).
Spadá sem i~lichoběžníková metoda
(${q = k = 1}, {p = 2}$, vztah \rfeq{ode:lmm:trap}).

Další příklady:
\begin{alignat*}{99}
   &q = k~= 2, \: p = 3 &&: \quad y_{n+2} - y_{n+1} &&= \:
      & \frac{h}{12} & ( &   &         \: \: &  5 & f_{n+2} \:+\:
      & 8 & f_{n+1} \:-\: &   & f_{n} ) \\
   &q = k~= 3, \: p = 4 &&: \quad y_{n+3} - y_{n+2} &&= \:
      & \frac{h}{24} & ( & 9 & f_{n+3} \:+\: & 19 & f_{n+2} \:-\:
      & 5 & f_{n+1} \:+\: &   & f_{n} )
\end{alignat*}
\end{paragraph} %%Adams--Moultonovy metody

%%%

% Sat 24 Mar 2018 08:34:17 PM CET
\begin{paragraph}{\acrf{bdf}}\label{p:search:ode:classic:lmm:bdf}
jsou \hl{implicitní} $k$-krokové metody často používané
pro~rovnice se silným tlumením
pro~jejich vlastnosti stability
(ač jen pro~${k \leq 6}$).

Jejich tvar je
${\beta_{k-1} = \dots} = {\beta_{0} = 0}$,
ostatní koeficienty ($\beta_{k}$ a ${\forall \alpha_{j}}$)
jsou zvoleny tak, aby ${q = p = k}$
(opět pomocí interpolace,
tentokrát ale pro~funkce $y$).
Spadá sem opět implicitní Eulerova metoda
(${q = k = p = 1}$~%
\footnote{Pro~vztah \rfeq{ode:implicit}
jakožto Adams--Moultonovy metody platilo ${q = 0}$,
tentokrát se však jedná o~polynom na~levé straně rovnosti \rfeq{ode:lmm},
tedy ${q = 1}$.}).

Příklady:
\begin{alignat*}{99}
   &q = k~= p = 2&&: \quad &    &               &  3 & y_{n+2} \:-\:
      & 4 & y_{n+1} \:+\: &   & y_{n} &&= \: & 2 & h f_{n+2} \\
   &q = k~= p = 3&&: \quad & 11 & y_{n+3} \:-\: & 18 & y_{n+2} \:+\:
      & 9 & y_{n+1} \:-\: & 2 & y_{n} &&= \: & 6 & h f_{n+3}
\end{alignat*}
\end{paragraph} %%\acrf{bdf}}

%%%

\end{subsubsection} %%Lineární vícekrokové metody

%%%%%%%

% Sun 11 Mar 2018 03:42:25 PM CET
\begin{subsubsection}{Runge--Kutta metody}\label{sss:search:ode:classic:rk}
Tyto iterativní metody vycházejí z~aproximace
pomocí rozvoje Taylorova polynomu,
které jsou ale pomalé z~důvodu požadavku
na~výpočet derivací vyšších řádů~\cit{ode-nsolve-book}.
Runge--Kutta metody toto obchází
vícenásobným vyčíslováním funkce $f$
v~několika bodech (mezikrocích)
z~intervalu $[t_{n}, t_{n+1}]$.
Tím je dosaženo vyšších řádů přesnosti $p$.

Přesto se jedná o~metodu \hl{jednokrokovou},
kde každý krok sestává z~několika mezikroků, \name{fází}.
Jedná se o~to,
že hodnoty mezikroků jsou obecně různé
a nemohou být znovu využívány tak,
jak tomu je u~vícekrokových metod,
obecně totiž platí,
že po~každém kroku Runge--Kutta metod
jsou všechny mezikroky zapomenuty.

To může činit potíže,
pokud je vyčíslení funkce $f$ náročné,
neboť je nutné ji počítat často.
Nicméně, tyto metody
mají odlišné vlastnosti stability
od~vícekrokových metod
a jejich použití může být mnohdy výhodnější,
zejména u~rovnic se silným tlumením.
Dále tyto metody umožňují lepší průběžné řízení chyby aproximace
či adaptaci na~ni
a mohou být použity jako základ
řešičů s~garancí rozsahu chyby~\cit{ode-valid-runge_kutta-art}.

Obecná $s$-fázová Runge--Kutta metoda je definována
podle~\cit{ode-nsolve-book}\cit{ode-valid-runge_kutta-art} vztahy
\begin{equation}\label{eq:ode:rk}
\begin{split}
   y_{n+1} &= y_{n} + h \sum_{i=1}^{s} b_{i} k_{i} \\
   k_{i}   &= f \! \left( t_{n} + c_{i} h, z_{i} \right) \\
   z_{i}   &= y_{n} + h \sum_{j=1}^{S_{i}} a_{i,j} k_{j} \\
   c_{i}   &= \sum_{j=1}^{i-1} a_{i,j}
\end{split}
\end{equation}
kde ${\forall b_{i}}, c_{i}, a_{i,j}$ jsou konstanty
plně charakterizující konkrétní Runge--Kutta metodu,
uspořádané do~tzv. \name{Butcherovy tabulky}:
\begin{equation}\label{eq:ode:rk:tab}
\begin{array}{r|cccc}
   c_{1}  & a_{1,1} & a_{1,2} & \cdots & a_{1,s} \\
   c_{2}  & a_{2,1} & a_{2,2} & \cdots & a_{2,s} \\
   \vdots & \vdots  & \vdots  & \ddots & \vdots  \\
   c_{s}  & a_{s,1} & a_{s,2} & \cdots & a_{s,s} \\ \hline
          & b_{1}   & b_{2}   & \cdots & b_{s}
\end{array}
\end{equation}
Jejich hodnoty jsou hledány podle Taylorova rozvoje
a podle požadovaného řádu metody $p$.
Není znám přesný vztah pro $p$ a $s$,
ale obecně platí ${p \leq s}$.

Hodnota $S_{i}$ ve~vztahu pro $z_{i}$ rozlišuje typ metody:
\begin{itemize}
\item \hl{explicitní}: ${S_{i} \coloneqq i-1}$,
   tj. ${\forall_{i,j} \: i \leq j : \: a_{i,j} = 0}$;
   ${c_{1} = 0}$;
   ${\forall k_{i}}$ závisí pouze na ${k_{j}, \: j < i}$;
   Butcherova tabulka je v~striktně dolním trojúhelníkovém tvaru
   s~nulovou diagonálou;
   z~toho vyplývá ${z_{1} = y_{n}}, {k_{1} = f_{n}}$;
\item \hl{implicitní}: ${S_{i} \coloneqq s}$;
   ${\exists_{i,j} \: i \leq j : \: a_{i,j} \neq 0}$.
\end{itemize}

Příklady Runge--Kutta metod:

%%%

% Sat 24 Mar 2018 08:42:08 PM CET
\begin{paragraph}{Eulerova metoda}\label{sss:search:ode:classic:rk:euler}
(vztahy \rfeq{ode:explicit}
a \rfeq{ode:implicit})~---~${s = p = 1}$,
${b_{1} = 1}$ a
${c_{1} = a_{1,1} = 0}$ pro explicitní;
${c_{1} = a_{1,1} = 1}$ pro implicitní metodu:
\begin{equation*}
\begin{split}
   y_{n+1}             &= y_{n} + h k~\\
   k~&= f \! \left( t_{n} + h, y_{n} + h k~\right)
      = f \! \left( t_{n+1}, y_{n+1} \right) \\
   \Rightarrow y_{n+1} &= y_{n} + h f_{n+1}
\end{split}
\end{equation*}

Jejich Butcherovy tabulky:
\begin{equation*}
\begin{array}{r|c}
   0  &   \\ \hline
      & 1
\end{array}
\qquad
\begin{array}{r|c}
   1  & 1 \\ \hline
      & 1
\end{array}
\end{equation*}
\end{paragraph} %%Eulerova metoda

%%%

% Sat 24 Mar 2018 08:43:46 PM CET
\begin{paragraph}{Lichoběžníková metoda}
\label{sss:search:ode:classic:rk:trap}
(vztah \rfeq{ode:lmm:trap})~---~${s = p = 2}$, je implicitní.

Tabulka:
\begin{equation*}
\begin{array}{r|cc}
   0  &           0 &           0 \\
   1  & \frac{1}{2} & \frac{1}{2} \\ \hline
      & \frac{1}{2} & \frac{1}{2}
\end{array}
\end{equation*}
\end{paragraph} %%Lichoběžníková metoda

%%%

% Sat 24 Mar 2018 08:44:02 PM CET
\begin{paragraph}{Klasická Runge--Kutta metoda (RK4):}
\label{sss:search:ode:classic:rk:rk4}
\begin{equation}\label{eq:ode:rk:rk4}
\begin{split}
   y_{n+1} &= y_{n} + \frac{h}{6} ( k_1 + 2 k_2 + 2 k_3 + k_4 ) \\
   k_1     &= f_n \\
   k_2     &= f \! \left( t_n + \frac{h}{2}, y_n + \frac{h}{2} k_1 \right) \\
   k_3     &= f \! \left( t_n + \frac{h}{2}, y_n + \frac{h}{2} k_2 \right) \\
   k_4     &= f \! \left( t_n + h, y_n + h k_3 \right)
\end{split}
\end{equation}
je \hl{explicitní} metoda s~parametry ${s = p = 4}$.

Tabulka:
\begin{equation*}
\begin{array}{r|cccc}
             0  &             &             &             &             \\
   \frac{1}{2}  & \frac{1}{2} &             &             &             \\
   \frac{1}{2}  &           0 & \frac{1}{2} &             &             \\
             1  &           0 &           0 &           1 &             \\
\hline
                & \frac{1}{6} & \frac{1}{3} & \frac{1}{3} & \frac{1}{6}
\end{array}
\end{equation*}
\end{paragraph} %%Klasická Runge--Kutta metoda (RK4):

%%%

\bigskip

Existují také \hl{adaptivní} Runge--Kutta metody,
které v~každém kroce počítají odhad chyby aproximace,
podle níž se dynamicky mění délka kroku $h_n$.
\end{subsubsection} %%Runge--Kutta metody

%%%%%%%

% Sat 24 Mar 2018 07:59:43 PM CET
\begin{subsubsection}{\acr{ode} řešiče}\label{sss:search:ode:classic:solver}
Následují řešiče, které některé z~uvedených klasických metod implementují.

%%%

\begin{paragraph}{\acr{sundials}}\label{p:search:ode:classic:solver:sundials}
(\name{\acrl{sundials}}) je nástroj napsán v~jazyce
\acr{ansi} C~\cit{sundials}.
Pracuje s~třídami datových vektorů,
nad~kterými lze vytvářet uživatelsky definované
datové struktury a operace v~rámci aplikačního rozhraní.
Má implementovány výchozí struktury
s~předdefinovanými operacemi
jak pro~sériové prostředí,
tak i~paralelní se sdílenou (\name{\acr{omp}})
nebo distribuovanou (\name{\acr{mpi}}) pamětí.
Veškerá paralelizace je obsažena
pouze v~rámci specifických operací nad~danými vektory
(a lze ji rovněž uživatelsky implementovat),
a tudíž není rozlišováno mezi sériovým a paralelním kódem aplikace.

\acr{sundials} sestává z~více komponent.
Diskutuji pouze jedinou z~nich~---~\name{CV\acr{ode}},
který je určen pro~řešení \acr{ode}.
Další komponenty řeší
také diferenciální algebraické rovnice
(\name{\acr{dae}})~---~\name{IDA}~---~a nelineární
algebraické systémy~---~\name{KINSOL}.
CV\acr{ode} je výsledkem
přepsání řešiče \name{V\acr{ode}} z~Fortranu do~C,
počínaje už rokem 1993~\cit{sundials-art}.

\cmt{CV\acr{ode}S --- includes forward and disjoint sensitivity analysis}
\end{paragraph} %%\acr{sundials}

%%%

\begin{paragraph}{odeint}\label{p:search:ode:classic:solver:odeint}
je flexibilní C++ knihovna
pro~numerické řešení \acr{ode}~\cit{odeint}.
Je navržena v~duchu šablonového metaprogramování
(\name{\acr{tmp}})~---~veškeré její numerické algoritmy
jsou nezávislé na~použitých datových kontejnerech.
Také díky komfortnímu aplikačnímu rozhraní
je implementace numerických simulací rychlá a snadná.

Knihovna je součástí rodiny C++ knihoven \name{Boost}~\cit{boost-libs}.
Obsahuje pouze hlavičkové soubory
a umožňuje změnit chování numerických operací~---~tímto způsobem
lze např. použít odeint
se \acr{simd} operacemi~\cit{odeint-art}.

\cmt{gsl}
\end{paragraph} %%odeint

%%%

\end{subsubsection} %%\acr{ode} řešiče

%%%%%%%

\end{subsection} %%Klasické numerické metody

%%%%%%%%%%%%%

% Wed 14 Mar 2018 04:59:37 PM CET
\begin{subsection}{Garantovaná řešení}\label{ss:search:ode:valid}
Tato řešení využívají \name{intervalovou aritmetiku}%
\footnote{Nejsou nám známy metody s~garantovaným rozsahem aproximační chyby
založená na~jiném principu, než je intervalová aritmetika.},
což umožňuje jednak specifikovat počáteční podmínky
s~nějakou nejistotou jakožto intervalový rozsah,
druhak obalení úseků výsledku do~intervalových uzávěrů,
tzn.~že meze odchylky aproximace od~exaktního řešení
jsou přesně známy.
Taková řešení se nazývají jako \name{garantovaná}
(angl. \name{guaranteed} nebo \name{validated}).
Některé zdroje tento problém formulují
jako problém s~intervalovými počátečními podmínkami
(\name{Interval}~\acr{ivp}, \name{I\acr{ivp}})%
~\cit{ode-valid-runge_kutta-art},
některé setrvávají u~názvu \acr{ivp}.
Garance rozsahu řešení je klíčovým rozdílem
těchto metod
od klasických řešičů \acr{ode}
ze~sekce \rf{ss:search:ode:classic}.

%%%

% Wed 14 Mar 2018 09:20:11 PM CET
\begin{paragraph}{Značení.}\label{p:search:ode:sign}
${[t_n]}$ je interval ${[t_{n}, t_{n+1}]}$ délky $h_n$;
${[y_n]}$ je uzávěr ${[y^{min}_{n}, y^{max}_{n}}]$ v~bodě $t_n$
(tj.~garantované meze řešení v~$t_n$);
${[\pred{y}_n]}$ je uzávěr ${[\pred{y}^{min}_{n}, \pred{y}^{max}_{n}}]$
pro~celé ${[t_n]}$.
\end{paragraph} %%Značení.

%%%

\bigskip

Celý výpočet je rozdělen do~kroků v~bodech $t_n$.
Je-li metoda jednokroková,
je její průběh následující~\cit{ode-valid-runge_kutta-art}:
\begin{enumerate}
\item v~každém kroku se operuje nad~intervalem ${[t_{n}]}$,
\item nejprve je hledán volnější uzávěr ${[\pred{y}_n]}$,
\item ${\forall t \in [t_n]}$ je garantována existence
   ${\forall y_n \in [y_n]}$, přičemž
   ${[y_n] \subseteq [\pred{y}_n]}$,
\item délka $h_n$ je největší možná v~souladu s~garantovaným řešením,
\item výpočet ${[y_{n+1}]}$.
\end{enumerate}
Výstupem jsou trojice ${(t_n, [y_n], [\pred{y}_n])}$
obsahující uzávěry (namísto diskrétních hodnot).

Tyto metody používají interní \acr{ode} řešiče
stávajících hybridních řešičů,
které jsou uvedeny v~následující sekci.
\end{subsection} %%Garantovaná řešení

%%%%%%%%%%%%%

\end{section} %%Numerické metody řešení \acr{ode}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Sat 24 Mar 2018 10:30:12 AM CET
\begin{section}{Hybridní řešiče}\label{s:search:hybrid}
Řešiče, které umí analyzovat modely hybridních systémů,
již existují,
nicméně nezachází dobře s~praktickými úlohami z~reálného světa.
A~to proto, že používají řešiče pro~\acr{ode}
s~intervalovou aritmetikou,
která je zbytečně přesná a ve~výsledku pomalá,
neboť je exaktní ve~smyslu zaručení rozsahu chyby aproximace
(viz.~sekce \rf{ss:search:ode:valid}).

Našim cílem bylo sestrojit řešič,
který nemusí být tolik přesný,
ale dokáže analyzovat
modely i~rozsáhlých systémů
v~únosně krátké době,
a tím by byl použitelný i~v~praxi,
použitím klasických numerických metod
(viz.~sekce \rf{ss:search:ode:classic}).

Zkoumané hybridní řešiče nám však posloužily
jako zdroj cenných informací
pramenících z~kombinace diskrétního a spojitého modelu
a také nás inspirovaly ve~volbě vstupního jazyka.
S~těmito řešiči budou také srovnány výsledky našeho produktu.

\cmt{\cit{hydlogic-art}}

%%%

\begin{paragraph}{i\acr{sat}-\acr{ode}}\label{p:search:hybrid:isat-ode}
\uv{kombinuje \name{i\acr{sat}},
který řeší rozsáhlé Boolovské kombinace aritmetických omezení,
s~rovnicemi \acr{ode}}~\cit{isat-ode}\cit{isat-ode-art}.

K~řešení \acr{ode} používá interní nástroj
\name{VN\acr{ode}-LP}~\cit{vnode-lp},
který se nejprve pokouší dokázat,
že existuje jediné řešení problému,
a poté hledá meze, do~kterých toto řešení spadá.

Podobně jako v~našem případě kombinuje oba nástroje odděleně,
tj. oba jsou samostatně použitelné na~svou podmnožinu úloh.

Projekt nezveřejnil zdrojové kódy,
přístupný je jen dynamicky linkovaný binární soubor
s~externími závislostmi
a je stále ve~stádiu vývoje.

\cmt{Zatím jsem nebyl schopen spustit kvůli chybějícím starým knihovnám.}
\end{paragraph} %%i\acr{sat}-\acr{ode}

%%%

% Fri 23 Mar 2018 09:44:23 PM CET
\begin{paragraph}{dReal}\label{p:search:hybrid:dreal}
je nástroj napsán v~jazyce C++, který rozhoduje,
zda je vstupní formule nesplnitelná (\id{unsat}),
nebo $\delta$-splnitelná (\id{$\delta$-sat})~\cit{dreal}.
Nesplnitelnost je rozhodnuta exaktně a doložena důkazem;
$\delta$-splnitelnost je numericky aproximována
(resp. exaktně rozhodnuta na~zjednodušené formuli)
s~přesností $\delta$ (racionální číslo).
\cmt{Přesněji: řeší exaktně 'delta-perturbated' formule,
nevím zda je to přepsáno správně.}

dReal je postaven nad~některými existujícími nástroji,
zejména Open\acr{smt}2~\cit{opensmt} a Mini\acr{sat}~\cit{minisat}
a na~straně diferenciálních rovnic pak CAPD
(viz.~\cit{dreal-smt-format-art}),
který počítá intervalové uzávěry \acr{ode}.
Zpracovává nelineární logiky
reálných čísel, zejména nad~polynomy,
trigonometrickými či exponenciálními funkcemi,
rozšířené o~\acr{ode}.

Integrace nástrojů je v~implementaci řešena interně.
Základ tvoří lineární \set{T}-řešič v~Open\acr{smt},
který je doplněn o~nelineární logiku a \acr{ode}.
Konkrétně rozšiřuje logiku \id{QF\_\-LRA}
na~\id{QF\_\-NRA} a ještě
o~diferenciální rovnice, nazvanou \id{QF\_\-NRA\_\-\acr{ode}}.
Z~hlediska jazyka spočívá rozšíření v~přidání několika málo příkazů
pro~definice \acr{ode}, nastavení invariant,
propojení diskrétních stavů s~\acr{ode} apod.
Nad tímto vstupem operuje řešič přímo,
tj.~\acr{smt} a \acr{ode} část
se nespouští zvlášť v~nezávislých komponentách.
Tento vstupní jazyk~\cit{dreal-smt-format-art}
byl hlavním zdrojem naší inspirace
při~návrhu vlastního vstupního jazyka.

Program také používá vlastní specifikační jazyk,
ze~kterého se generují nástrojem dReach \acr{smt} formule
podle zvoleného počtu kroků%
\footnote{dReal tento proces
nazývá přímo jako \acr{bmc}.}.
Tento předstupeň je lépe lidsky čitelný
a navíc brání chybám
vzniklým z~ručního vytváření rozsáhlých \acr{smt} formulí.

V~projektu je zahrnuto několik výkonnostních úloh
ve~vstupních jazycích dReal (specifikace i~\acr{smt} formule).
\cmt{např. dron se očividně počítá hodně dlouho;
v~testech (ctest) několik úloh timeoutuje}

\cmt{\cit{dreal-smo-art}}
\end{paragraph} %%dReal

%%%

\end{section} %%Hybridní řešiče

%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Mon 16 Apr 2018 09:11:53 PM CEST
\chapter{Návrh zvoleného řešení}\label{ch:design}
V~této kapitole rozebírám teoretický návrh řešení problému
zvolený před~vlastní implementací.
Zatím neuvádím implementační detaily
a konkrétní používané nástroje a programovací jazyky.
Nejprve popíši specifikaci celého nástroje
a jeho vstupy (vstupní jazyk,
v~němž budou přijímány textové vstupy)
a výstupy.
Následně uvedu softwarový model celého řešiče.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Sat 28 Apr 2018 10:53:16 PM CEST
\begin{section}{Specifikace nástroje}\label{s:design:spec}
Nástroj má fungovat jako řešič kombinace
dvou problémů: problému \acr{smt}
podle přístupů diskutovaných v~sekci \rf{s:search:smt},
a problému numerického řešení diferenciálních rovnic
s~použitím klasických numerických metod,
jak bylo diskutováno v~sekci \rf{ss:search:ode:classic}.
Tvar počátečních podmínek není omezen,
avšak není-li množina podmínek konečná
(tj.~např. intervaly),
doba výpočtu není definována a zpravidla neterminuje.
Intervaly však lze aproximovat výčtem hodnot z~intervalu.

Nástroj má sloužit jako \hl{prototyp}
odlišného přístupu ke~zkoumání hybridních modelů systémů
než~dosavadní řešiče
uvedené v~sekci \rf{s:search:hybrid}.
Hlavním účelem práce je \hl{srovnání}
s~některým stávajícím řešičem
z~hlediska efektivity
i~jiných vlastností.
Neformálním požadavkem pak je,
aby pro~alespoň některou podmnožinu
úloh, s~nižšími požadavky na~přesnost, byl náš prototyp
rychlejší než~stávající řešiče,
a to i~přesto, že by nebyl příliš optimalizován,
jelikož náš přístup
klade menší požadavky na~přesnost
a měl by být výpočetně výrazně méně náročný.

Nástroj bude přijímat jako vstup textový soubor
spadající do~námi specifikovaného vstupního jazyka.
Výstupem bude zejména příznak úspěchu
a volitelně také nějaká forma výsledných dat.
Vstupy a výstupy jsou podrobněji popsány ve~vlastních podsekcích.

Jedním z~případů užití nástroje je \acr{bmc}
(viz.~sekce \rf{p:theory:formulation:sat:bmc}),
u~kterého se velikost vstupu a délka výpočtu
odvíjí od~zvoleného počtu kroků ověřování modelu.
Kroky jsou v~tomto případě odděleny
skoky~---~změnami diskrétního stavu
systému~---~ke~kterým dochází při~porušení
nějakého \name{invariantu} vázaného k~aktuálnímu stavu.
Jedná se o~systém \name{řízený událostmi}
(angl. \name{event trigerred}).
Nemusí tedy být předem zřejmé,
ve~kterých časových okamžicích bude docházet k~integraci
a ve~kterém výpočet skončí.
Tento způsob používá např. nástroj dReal
(viz.~sekce \rf{p:search:hybrid:dreal}).

Náš řešič ale s~takovými kroky nepracuje
(alespoň ne v~této verzi),
nýbrž pracuje s~předem specifikovanými časovými okamžiky,
mezi kterými dochází k~integraci po~předem danou dobu,
a poté se mění stav systému závisle na~výstupech integrace
pomocí ověření splnitelnosti \acr{smt} řešičem.
Jedná se tedy o~systém \name{řízený časem}
(angl. \name{time trigerred})%
\footnote{V~našem případě však (pochopitelně) odpadá
výhoda systémů řízených časem oproti těm řízených událostmi,
že je porucha detekována na~straně přijímače,
jelikož zde pracujeme s~\uv{bezporuchovým} řešičem.}.
Tyto úseky výpočtu budu označovat jako \name{fáze}.
Náš řešič kriticky závisí na~zvoleném rozložení fází,
jak z~hlediska přesnosti, tak z~hlediska délky výpočtu.
Pokud změny stavů modelu závisí na~invariantech
integrovaných funkcí,
je nutné zvolit délku fází co nejnižší,
aby bylo porušení invariant detekováno co nejdříve.
Invarianty totiž nejsou kontrolovány v~průběhu integrace.
V~opačném případě, nebo pokud není porušení invariant kritické,
postačují vyšší délky fází,
čímž se urychluje výpočet.

Nástroj není koncipován jako konečný produkt,
není příliš uživatelsky přívetivý
a může obsahovat řadu chyb.
Nástroj má sloužit pro~účely experimentování
s~navrženým způsobem řešení úloh,
a dále buď jako zdroj inspirace
pro~vývojáře průmyslového nástroje,
anebo přímo jako postupně se vyvíjející projekt
na~bázi stávajících otevřených zdrojových kódů.

%%%%%%%%%%%%%

% Tue 24 Apr 2018 12:23:10 PM CEST
\begin{subsection}{Vstupní jazyk}\label{ss:design:spec:ilang}
Vstupním jazykem je záhodno postihnout
použití \acr{smt} formulí
a současně umožnit definovat \acr{ode}
a propojit je s~diskrétními \acr{smt} stavy.
Vycházel jsem z~jazyka \acr{smt}-LIB
(viz.~sekce \rf{ss:search:smt:smtlib})
a ze~vstupního jazyka nástroje dReal
(viz.~sekce \rf{p:search:hybrid:dreal}).
Použité názvosloví vychází z~\acr{smt}-LIB.

Ač je náš vstupní jazyk podobný na~ty referované,
není s~nimi kompatibilní,
zejména \hl{není konformní} se~standardem \acr{smt}-LIB,
který je relativně robustní,
umožňuje nastavovat parametry pro~řešič,
podporuje inkrementální operace, apod.
Také definuje výstupní jazyk.
Náš řešič sice interně tento jazyk hojně využívá,
ale svůj vstup omezuje jen na~některé části.
Vstupní specifikace modelů musí
spadat do~některé \hl{teorie reálných čísel}
(konkrétní logiky jsou uvedeny dále).
Tyto logiky jsou pochopitelně rozšířeny o~\acr{ode}.
Nad těmito vstupy lze provést pouze neinkrementální ověření splnitelnosti.
Většina zodpovědnosti pojená se~vstupní specifikací
\acr{smt} části vstupu je přímo delegována
na~\acr{smt} řešič, včetně kontroly validity vstupu.

Jazyk používá plně uzávorkovanou prefixovou notaci%
\footnote{Tato syntaxe je známa zejména z~jazyka \name{Lisp}.}.
Podmnožina příkazů týkající se~jen specifikace \acr{smt} formulí
je převzata z~\acr{smt}-LIB
a k~nim jsou ortogonálně doplněny
příkazy týkající se nadstavby o~\acr{ode}.
Obě skupiny jsou popsány ve~zvláštních podsekcích.

Vstupní jazyky jsou obecně definovány tak,
aby byly pokud možno nezávislé na~konkrétně použitých řešičích.

%%%

% Tue 20 Mar 2018 11:39:27 PM CET
\begin{paragraph}{Značení.}\label{ss:design:spec:ilang:sign}
Znaky \id{<>} nejsou součástí syntaxe a ohraničují či seskupují argumenty
(nejsou-li již nějak ohraničeny);
\id{*} značí, že dotčený řetězec
se může opakovat vícekrát nebo být prázdný;
\id{+} je jako \id{*}, ale zakazuje prázdný řetězec;
\id{|} značí více možností pro~jednu pozici argumentu.
\end{paragraph} %%Značení.

%%%

%%%%%%%

% Mon 23 Apr 2018 11:40:51 PM CEST
\begin{subsubsection}{Syntaxe jazyka}\label{sss:design:spec:ilang:syntax}
Vstupní jazyk je sekvence \name{tokenů}, \name{výrazů},
bílých znaků a komentářů.
U~znaků abecedy se rozlišuje velikost písmen.

%%%

% Tue 20 Mar 2018 11:39:45 PM CET
\begin{paragraph}{Bílé znaky.}\label{p:design:spec:ilang:struct:ws}
Povolenými bílými znaky jsou:
\begin{center}
\begin{tabular}{r|ccc}
   Název       & mezera & tabulátor & nová řádka \\ \hline
   \acr{ascii} &   $32$ &       $9$ &  $(13+{})10$ \\
\end{tabular}
\end{center}

S~výjimkou oddělení dvojic tokenů jsou bílé znaky ignorovány.
\end{paragraph} %%Bílé znaky.

%%%

% Tue 20 Mar 2018 11:39:53 PM CET
\begin{paragraph}{Komentář.}\label{p:design:spec:ilang:struct:cmt}
Jako komentář je interpretován každý úsek řádku
začínající znakem \hll{\id{;}} až po~konec řádku.
Jejich obsah je ignorován.
\end{paragraph} %%Komentář.

%%%

% Mon 23 Apr 2018 11:42:51 PM CEST
\begin{paragraph}{Token}\label{p:design:spec:ilang:struct:token}
je sekvence znaků závisle na~typu tokenu,
vždy však bez~bílých znaků, které slouží jako jejich oddělovače.
Tokeny se dělí na~\name{identifikátory} a \name{literály}.

\hll{Identifikátory} sestávají z~alfanumerických znaků a znaků
\begin{center}
\id{+ \  - \  * \  / \  \^{} \  = \  < \  > \  \_ \  . \  ?}
\end{center}
Musí být předem deklarovány, definovány nebo rezervovány
a nesmí začínat číslicí%
\footnote{Vzhledem k~jen minimálním restrikcím na~název identifikátoru
je vhodné, aby se uživatel vyvaroval zavádějících názvů,
např. obsahujících symboly operátorů
(\id{a<b} apod.),
a aby důsledně odděloval tokeny bílými znaky
nebo do~výrazů.}.
Reprezentují buď \name{příkazy}
(pak se vždy jedná o~rezervovaný token;
jsou interpretovány výhradně interně v~řešiči),
nebo \name{funkce},
které mohou být i~uživatelsky definované,
či \name{druh} prvků, výrazů apod. (angl. \name{sort}).
Speciálním případem funkce je \name{konstanta},
která nemá žádné argumenty.
Pojem proměnných se nepoužívá,
neboť hodnotám identifikátorů nelze dynamicky přiřazovat nové hodnoty,
stejně jako v~\acr{smt}-LIB.

\hll{Literály} jsou bezejmenné konstanty
nějakého druhu.
Numerické obsahují číslice a případně desetinnou tečku (\id{\hll{.}})
nebo záporné znaménko (\id{-})%
\footnote{Záporné literály v~\acr{smt}-LIB povoleny nejsou,
proto je nutné provést transformaci na~výraz
s~unární funkcí \id{-} a kladným literálem.};
na~začátku nejsou povoleny přídavné \id{0} a kladné znaménko;
desetinná čísla musí obsahovat číslici před i~po~desetinné tečce;
není podporován semilogaritmický tvar.
Booleovské literály jsou \id{true} a \id{false}.
\end{paragraph} %%Token

%%%

% Fri 27 Apr 2018 01:17:21 AM CEST
\begin{paragraph}{Výraz}\label{p:design:spec:ilang:struct:expr}
je vždy uzavřen v~závorkách:
\begin{center}
\id{( <{}<token> | <expr>{}>* )}
\end{center}
kde \id{<expr>} je vnořený výraz
a \id{<token>} token.
Pokud je výraz umístěn v~kořenové úrovni vstupu,
pak se musí jednat o~příkaz.
V~příkazu musí být prvním elementem výrazu
token s~názvem příkazu.
Obecné výrazy toto omezení nemají,
ale pokud se jedná o~funkci,
platí pro ni~totéž co pro~příkazy.
Příkazy nemusí mít druh návratové hodnoty,
funkce ano.

(Bílé znaky a komentáře nejsou v~sekvenci zahrnuty;
při~vyhodnocení je jejich obsah ignorován.)
\end{paragraph} %%Výraz

%%%

\end{subsubsection} %%Syntaxe jazyka

%%%%%%%

% Tue 24 Apr 2018 12:25:17 PM CEST
\begin{subsubsection}{\acr{smt} konstrukty}\label{sss:design:spec:ilang:smt}
Je použita pouze podmnožina konstruktů
týkajících se povolených teorií reálných čísel.
Jedná se o~druhy výrazů
a o~rezervované příkazy a funkce.

%%%

% Tue 20 Mar 2018 11:40:10 PM CET
\begin{paragraph}{Druhy prvků:}\label{p:design:spec:ilang:smt:sorts}
\begin{itemize}
\item \id{Bool}~---~logický typ,
\item \id{Real}~---~typ reálných čísel.
\end{itemize}
Celočíselný druh není akceptován;
pro~diskrétní konstanty je nutno využít výhradně druh \id{Bool},
typicky pro~diskrétní stav systému, který je konečný.
\end{paragraph} %%Druhy prvků:

%%%

% Fri 27 Apr 2018 01:58:57 AM CEST
\begin{paragraph}{Rezervované funkce.}\label{p:design:spec:ilang:smt:reserved}
Zahrnuty jsou následující funkce (resp. operátory)
se~standardní sémantikou:
\begin{itemize}
\item Unární:  \quad \id{not}
\item Binární: \quad \id{/}
\item $n$-ární:
   \begin{itemize}
   \item levá asociativita:
      \begin{itemize}
      \item ${n \geq 1}$: \quad \id{- \ and \  or}
      \item ${n \geq 2}$: \quad \id{+ \  *}
      \end{itemize}
   \item pravá asociativita, ${n \geq 2}$: \quad \id{=>}
   \item se~zřetězením, ${n \geq 2}$:  \quad \id{= \  < \  > \  <= \  >=}
   \end{itemize}
\end{itemize}
a dále tyto funkce:
\begin{itemize}
\item \id{distinct}~---~$n$-ární funkce s~${n \geq 2}$,
   která vrací nerovnost všech dvojic prvků,
\item \id{ite}~---~ternární funkce s~prvním argumentem druhu \id{Bool},
   který když je pravdivý,
   vrací se druhý argument, jinak třetí argument.
\end{itemize}
\end{paragraph} %%Rezervované funkce.

%%%

% Thu 03 May 2018 01:56:05 PM CEST
\begin{paragraph}{\id{set-logic}}\label{p:design:spec:ilang:smt:logic}
nastavuje logiku použitou v~\acr{smt} řešiči:
\begin{center}
\id{(set-logic <logic\_\-name>)}
\end{center}
kde \id{<logic\_\-name>} je jedna z~následujících logik
teorií reálných čísel s~volnými funkčními symboly,
podle \acr{smt}-LIB:
\begin{itemize}
\item \id{QF\_\-UFLRA}~---~lineární bez~kvantifikátorů,
\item \id{QF\_\-UFNRA}~---~nelineární bez~kvantifikátorů,
\item \id{UFLRA}~---~lineární s~kvantifikátory.
\end{itemize}

Příkaz smí být volán nejvýše jednou
a musí předcházet všem ostatním uvedeným příkazům.
Není-li příkaz uveden, je jako výchozí logika zvolena \id{QF\_\-UFLRA}.

Pokud to implementace umožňuje,
smí být také podporovány zmíněné logiky
bez~volných funkčních symbolů (názvy jsou bez~znaků \id{UF}).
Pak je jako výchozí logika volena \id{QF\_\-LRA}.
\end{paragraph} %%\id{set-logic}

%%%

% Mon 23 Apr 2018 11:54:12 PM CEST
\begin{paragraph}{\id{declare-fun}}\label{p:design:spec:ilang:smt:declfun}
slouží k~deklaraci nové funkce (resp. konstanty)
bez její interpretace.
Je tvaru
\begin{center}
\id{(declare-fun <fun\_\-name> (<arg\_\-sort>*) <sort>)}
\end{center}
Argumenty příkazu:
\begin{itemize}
\item \id{<fun\_\-name>}~---~název identifikátoru funkce,
\item \id{<arg\_\-sort>*}~---~výčet identifikátorů druhů
   argumentů funkce (prázdné v~případě konstanty),
\item \id{<sort>}~---~identifikátor druhu návratové hodnoty.
\end{itemize}
Příklady:
\begin{center}
\id{(declare-fun y (Real) Real)}\\
\id{(declare-fun empty? () Bool)}
\end{center}

Funkce a konstanty jsou deklarovány globálně
a mohou být za~místem deklarace
libovolně používány uvnitř dalších funkcí.
\end{paragraph} %%\id{declare-fun}

%%%

% Mon 23 Apr 2018 11:57:05 PM CEST
\begin{paragraph}{\id{define-fun}}\label{p:design:spec:ilang:smt:defun}
rozšiřuje%
\footnote{Každá funkce je buď jen deklarována,
nebo definována, ne obojí.}
\id{declare\--fun} o~definici funkce:
\begin{center}
\id{(define-fun <fun\_\-name> ((<arg> <arg\_\-sort>)*) <sort> <expr>)}
\end{center}
se~shodnými argumenty kromě:
\begin{itemize}
\item \id{(<arg> <arg\_\-sort>)*}~---~výčet párů identifikátorů
   názvu argumentů funkce a jejich druhů,
\item \id{<expr>}~---~výraz nebo token definující chování funkce
   s~druhem návratové hodnoty \id{<sort>}
   a (ne nutně) obsahující jednotlivé argumenty \id{<arg>}.
\end{itemize}
Příklad:
\begin{center}
\id{(define-fun v~((s~Real) (t Real)) Real (/ s~t))}
\end{center}
\end{paragraph} %%\id{define-fun}

%%%

% Tue 20 Mar 2018 11:40:25 PM CET
\begin{paragraph}{\id{assert}}\label{p:design:spec:ilang:smt:assert}
zavádí formule modelu, které musejí být splněny:
\begin{center}
\id{(assert <expr>)}
\end{center}
kde \id{<expr>} je výraz nebo token s~druhem návratové hodnoty \id{Bool}.
Příklad:
\begin{center}
\id{(assert (or (= mode a) (= mode b) ))}
\end{center}
\end{paragraph} %%\id{assert}

%%%

\end{subsubsection} %%\acr{smt} konstrukty}

%%%%%%%

% Tue 24 Apr 2018 12:00:22 AM CEST
\begin{subsubsection}{Konstrukty \acr{ode}}
\label{sss:design:spec:ilang:ode}
V~kontextu \acr{ode} lze zjednodušovat
syntaxi příkazů s~následujícími pravidly:
\begin{itemize}
\item název nezávislé proměnné v~\acr{ode} je vždy \id{t},
\item druhy funkcí i~jejich derivací a nezávislé proměnné je \id{Real}.
\end{itemize}
Tyto skutečnosti nebudou nadále zmiňovány.

Vstup může obsahovat vícero závislých či nezávislých
diferenciálních rovnic, označovaných jako \id{ode}.
Každá \id{ode} dále sestává z~jedné či více variant derivací,
z~nichž v~každé fázi je pro~každou \id{ode} platná právě jedna varianta.
Varianty derivací budou označovány jako \id{dt}.
\id{dt} umožňují volit různé předpisy pro~derivace neznámých funkcí
závisle na~aktuálním stavu celého systému.

%%%

% Sat 07 Apr 2018 07:17:16 PM CEST
\begin{paragraph}{Nové druhy prvků:}\label{p:design:spec:ilang:ode:sorts}
\begin{itemize}
\item \id{Dt}~---~druh určující zvolenou variantu derivace \id{dt}.
\end{itemize}
\end{paragraph} %%Nové druhy prvků:

%%%

% Fri 27 Apr 2018 02:09:56 AM CEST
\begin{paragraph}{Nové rezervované funkce.}
\label{p:design:spec:ilang:ode:reserved}
\acr{smt} logiky neumějí dobře zacházet s~některými
nelineárními reálnými funkcemi,
k~nimž lze využít \acr{ode} řešič
a namísto s~funkcemi pracovat s~konstantami,
jimž jsou přiřazeny výsledky integrování.
Přidány jsou následující unární funkce:
\begin{center}
\id{abs \  sqrt \  cbrt \  sin \  cos \  tan \  exp \  ln}
\end{center}
a binární funkce (resp. operátor): \quad \id{\^{}} \\
Tyto však mohou být využity pouze uvnitř příkazu \id{define\--dt}
(viz.~dále).
\end{paragraph} %%Nové rezervované funkce.

%%%

% Tue 24 Apr 2018 12:11:52 AM CEST
\begin{paragraph}{\id{define-dt}}\label{p:design:spec:ilang:ode:dt}
slouží k~definici \id{dt}, tj.~výrazu popisujícího variantu derivace funkce,
a současně k~deklaraci \id{ode} neznámé funkce
u~první zmíněné varianty \id{dt}.
Všechny \id{dt} musí v~rámci \id{ode}
sdílet stejnou signaturu (viz.~dále).

Tvar příkazu:
\begin{center}
\id{(define-dt <fun\_\-name> <dt\_\-name> (<arg>*) <expr>)}
\end{center}
s~argumenty:
\begin{itemize}
\item \id{<fun\_\-name>}~---~název \id{ode},
   tj.~identifikátoru neznámé funkce nezávislé
   proměnné \id{t} obsahující všechny varianty \id{dt},
\item \id{<dt\_\-name>}~---~název \id{dt},
   tj.~identifikátoru varianty derivace funkce \id{<fun\_\-name>},
\item \id{<arg>*}~---~identifikátory argumentů výrazu,
   které jsou druhu \id{Real} a musí být
   \hl{shodné} u~všech variant \id{dt};
   \hl{neobsahují} funkci \id{<fun\_\-name>}
   a nezávislou proměnnou \id{t},
   které jsou zahrnuty implicitně;
   mohou obsahovat i~identifikátory jiných \id{ode},
   více viz.~níže,
\item \id{<expr>}~---~výraz nebo token popisující tvar derivace funkce,
   který může obsahovat funkci \id{<fun\_\-name>}
   a nezávislou proměnnou \id{t}\:%
   \footnote{Funkce se uvádí bez~závislosti na~\id{t},
   tj.~jako konstanta.}
   a jednotlivé argumenty \id{<arg>}.
   Na~rozdíl od~\acr{smt} funkcí
   \id{<expr>} nepřijímá globální funkce a konstanty.
\end{itemize}
Příklady:
\begin{center}
\id{(define-dt x dx () 1)}\\
\id{(define-dt y dy\_\-on () (- (* (/ 3 t) y) 2))}\\
\id{(define-dt z dz\_\-a (k) (+ (/ 1 z) k))}
\end{center}

Identifikátory \id{<fun\_\-name>}
je nutné používat výhradně uvnitř \id{int-ode} příkazů.
Identifikátory \id{<dt\_\-name>} jsou zavedeny jako konstanty druhu \id{Dt},
které lze používat uvnitř příkazů \id{assert}
pro~účely propojení konstant druhu \id{Dt} se~stavem systému.

Argumenty \id{<arg>} vstupují do~výrazu \id{<expr>}
jako konstanty druhu \id{Real} jakožto počáteční podmínky integrace
a také jako vstupní hodnoty v~každé fázi integrace.
Pokud \id{<arg>} pochází z~konstanty, její hodnota se nemění;
pokud se však jedná o~identifikátor některé \id{ode}
(pocházející z~\id{<fun\_\-name>}),
její hodnota se průběžně mění,
jelikož jsou všechna \acr{ode} integrována synchronně.
Tímto způsobem se definují soustavy více \acr{ode}%
\footnote{Pokud chcete z~nějakého důvodu
použít funkci některé \id{ode}
jako \hl{konstantní} vstup pro jinou \id{ode},
zvolte pro~tento argument \id{<arg>}
název odlišný od~\id{<fun\_\-name>};
vstupní konstanty pro~příkaz \id{int-ode} zůstávají stejné.}, př.:
\begin{center}
\id{(define-dt x dx (y) (+ x y))}\\
\id{(define-dt y dy (x) (- x y))}
\end{center}
\end{paragraph} %%\id{define-dt}

%%%

% Sat 28 Apr 2018 06:18:39 PM CEST
\begin{paragraph}{\id{int-ode}}\label{p:design:spec:ilang:ode:int}
obaluje výraz integrace neznámé funkce v~konkrétní fázi
a dosazuje do~\id{ode} hodnoty či konstanty.
Návratová hodnota výrazu je druhu \id{Real} a lze jej používat
uvnitř příkazů \id{assert}.

Tento příkaz se chová jako funkce a musí být umístěn v~místě,
kde jsou funkce povoleny,
což např. není vrcholová úroveň vstupu.

Na~rozdíl od~příkazu \id{define\--dt} pracuje tento
výhradně s~identifikátory, ne s~obecnými klíči.
Slouží k~tomu, aby dosazoval do~rovnic definovaných
příkazem \id{define\--dt} konkrétní
počáteční a koncové hodnoty
a vybíral některou variantu \id{dt}.

Tvar příkazu:
\begin{center}
\id{(int-ode <fun\_\-name> <dt> (<init> <t\_\-1> <t\_\-2>) (<arg\_\-val>*))}
\end{center}
s~argumenty:
\begin{itemize}
\item \id{<fun\_\-name>}~---~název \id{ode},
   tj.~identifikátor neznámé derivované funkce
   zavedený příkazy \id{define\--dt},
\item \id{<dt>}~---~konstanta druhu \id{Dt}, která určuje
   některou z~variant derivací \id{dt} definovaných příkazy \id{define\--dt}%
   \footnote{Nejedná se o~konstanty pocházející z~příkazu \id{define\--dt},
   ale o~pomocné konstanty, které jsou ohodnoceny \acr{smt} řešičem
   na~základě asercí se~stavem modelu.},
\item \id{<init>}~---~počáteční hodnota funkce \id{<fun\_\-name>}
   v~bodě \id{<t\_\-1>},
\item \id{<t\_\-1> <t\_\-2>}~---~počáteční a koncová hodnota
   nezávislé proměnné \id{t},
\item \id{<arg\_\-val>*}~---~počáteční hodnoty argumentů druhu \id{Real}
   předané výrazu zvolené varianty derivace.
\end{itemize}
Názvy všech vstupních konstant mohou být libovolné identifikátory,
jejich struktura a návaznosti jsou zodpovědností uživatele.
Příklady:
\begin{center}
\id{(int-ode x dx\_\-0 (x\_\-0 t\_\-0 t\_\-1) ())} \\
\id{(int-ode x dx\_\-1 (x\_\-1 t\_\-1 t\_\-2) ())} \\
\id{(int-ode y dy\_\-1 (y\_\-1 t\_\-1 t\_\-2) ())} \\
\id{(int-ode y der\_\-25 (var-3 tt\_\-5 xy56) ())} \\
\id{(int-ode z dz\_\-1 (z\_\-1 t\_\-1 t\_\-2) (k))} \\
\id{(int-ode z dz\_\-2 (z\_\-1 t\_\-1 t\_\-3) (k))}
\end{center}
\end{paragraph} %%\id{int-ode}

%%%

% Sat 07 Apr 2018 07:01:24 PM CEST
\begin{paragraph}{\id{define-ode-step}}\label{p:design:spec:ilang:ode:step}
definuje (počáteční) velikost kroku
v~interním \acr{ode} řešiči:
\begin{center}
\id{(define-ode-step <h>)}
\end{center}
kde \id{<h>} je konstanta druhu \id{Real}.
\end{paragraph} %%\id{define-ode-step}

%%%

\end{subsubsection} %%Konstrukty \acr{ode}

%%%%%%%

% Fri 27 Apr 2018 12:19:36 PM CEST
\begin{subsubsection}{Struktura a použití jazyka}
\label{sss:design:spec:ilang:struct}
V~této podsekci je uveden tvar doporučené struktury vstupu,
který by validně popisoval model hybridního systému
a umožňoval jeho analýzu našim nástrojem.

Vzhledem k~tomu, že se v~jazyce nevyskytují žádné proměnné,
není možné, aby se průběh stavu systému
v~rámci jednoho ověření splnitelnosti
dynamicky měnil~---~výsledkem je vždy statické ohodnocení.
Jelikož je vstup statický,
je pro~modelování průběhu nutné použít mnoho konstant
o~předem známém počtu.

Rozložení fází je určeno obecně
podle navazujících časových mezí příkazů \id{int-ode}
(hodnoty konstant nezávislé proměnné \id{t}).

Následují jednotlivé sekce,
které by se měly objevit ve~vstupech.
Kromě těchto smí uživatel používat
i~další \acr{smt} konstrukty tohoto jazyka.

%%%

% Fri 27 Apr 2018 12:58:39 PM CEST
\begin{paragraph}{Deklarace a inicializace konstant.}
\label{p:design:spec:ilang:struct:const}
Všechny konstanty musejí být deklarovány a konstanty
počátečních podmínek
musí být i~definovány.
Každé konstantě se typicky dává jako přípona číslo fáze,
ale řešič na~to nebere žádný ohled.

Je vhodné deklarovat konstanty
nezávislé proměnné \id{t},
průběhů neznámých funkcí, diskrétních stavů
a konstant voleb variant derivací \id{dt}%
\footnote{Pozor na~konflikt identifikátorů konstant \id{dt}
s~identifikátory variant derivací
z~příkazu \id{define\--dt}.}.

Intervalové počáteční podmínky lze aproximovat
pomocí logického součtu několika rovností.

Příklad:
\begin{Verbatim}[samepage=true]
;; Literals definition
(define-fun t0   () Real 0)
(define-fun y0_0 () Real 1) (define-fun y0_1 () Real 2)
(define-fun run0 () Bool false)
;; Constants declaration
(declare-fun t_0    () Real) (declare-fun t_1    () Real)
(declare-fun y_0    () Real) (declare-fun y_1    () Real)
(declare-fun run_0  () Bool) (declare-fun run_1  () Bool)
(declare-fun dy_0   () Dt)
;; Initial conditions
(assert (and (= t_0 t0) (= run_0 run0)
             (or (= y_0 y0_0) (= y_0 y0_1))
))
\end{Verbatim}
\end{paragraph} %%Deklarace a inicializace konstant.

%%%

% Mon 16 Apr 2018 01:34:14 PM CEST
\begin{paragraph}{Definice derivací funkcí}
\label{p:design:spec:ilang:struct:ode}
se provádí pomocí příkazů \id{define\--dt}.
Příklad:
\begin{Verbatim}[samepage=true]
(define-dt y dy_run  ()    1 )
(define-dt y dy_idle () (- 1))
\end{Verbatim}

Identifikátory variant derivací \id{dt}
\hl{nesmí} kolidovat s~konstantami
volených variant v~jednotlivých fázích, př.:
\begin{Verbatim}[samepage=true]
(declare-fun dy_0   () Dt) (declare-fun dy_1   () Dt)
;; ...
(define-dt y dy_1   () 1)  ;; conflict !!
\end{Verbatim}
\end{paragraph} %%Definice derivací funkcí

%%%

% Fri 27 Apr 2018 02:17:14 AM CEST
\begin{paragraph}{Invarianty}
\label{p:design:spec:ilang:struct:inv}
znamenají zavedení podmínek,
které musí být splněny \hl{mezi} všemi fázemi,
ale mohou být porušeny v~průběhu integrace.
Mohou a nemusí být závislé na~aktuálním stavu systému.
Pro~stanovení podmínek pro~konstanty závisle
na~konkrétním diskrétním stavu systému
doporučujeme použít až část definice skoků uvedenou dále.

Pokud to implementace \hl{explicitně} sama neprovádí,
je nutné omezit všechny konstanty jednotlivých fází druhu \id{Dt}
pouze na~výčet možných variant derivací z~příkazů \id{define\--dt}.

Doporučujeme zkonstruovat pomocnou funkci \id{invariant}, př.:
\begin{Verbatim}[samepage=true]
(define-fun invariant ((dy Dt) (y Real)) Bool
    (and (or (= dy dy_run) (= dy dy_idle))
         (<= y ymax)
))
\end{Verbatim}

Příklad s~použitím funkce \id{invariant}:
\begin{Verbatim}[samepage=true]
(assert (and (invariant dy_0 y_0)
             (invariant dy_1 y_1)
))
\end{Verbatim}
\end{paragraph} %%Invarianty

%%%

% Sat 07 Apr 2018 08:05:17 PM CEST
\begin{paragraph}{Nastavení voleb variant derivací}
\label{p:design:spec:ilang:struct:connect}
se provádí pomocí příkazu \id{assert},
ve~kterém se kombinuje libovolný stav systému
a konstanty druhu \id{Dt}.
Tím dochází k~propojení diskrétní a spojité domény modelu.

Doporučujeme zkonstruovat pomocnou funkci \id{connect}, př.:
\begin{Verbatim}[samepage=true]
(define-fun connect ((dy Dt) (run Bool)) Bool
    (and (=>      run  (= dy dy_run ))
         (=> (not run) (= dy dy_idle))
))
\end{Verbatim}

Příklad s~použitím funkce \id{connect}:
\begin{Verbatim}[samepage=true]
(assert (and (connect dy_0 run_0)
             (connect dy_1 run_1)
))
\end{Verbatim}
\end{paragraph} %%Nastavení voleb variant derivací

%%%

% Fri 27 Apr 2018 01:38:44 PM CEST
\begin{paragraph}{Definice skoků.}\label{p:design:spec:ilang:struct:jump}
Skoky, tj.~změny diskrétního stavu,
lze definovat též pomocí asercí
mezi sousedními stavy a dalšími konstantami.

Doporučujeme zkonstruovat pomocnou funkci \id{jump}, př.:
\begin{Verbatim}[samepage=true]
(define-fun jump ((run1 Bool) (run2 Bool) (y2 Real)) Bool
    (and (=> (and      run1  (<  y2 bound_1) )      run2  )
         (=> (and      run1  (>= y2 bound_1) ) (not run2) )
         (=> (and (not run1) (>  y2 bound_2) ) (not run2) )
         (=> (and (not run1) (<= y2 bound_2) )      run2  )
))
\end{Verbatim}

Příklad s~použitím funkce \id{jump}:
\begin{Verbatim}[samepage=true]
(assert (and (jump run_0 run_1 y_1)
             (jump run_1 run_2 y_2)
))
\end{Verbatim}

Pokud je požadavek na~libovolnou změnu
spojitého stavu modelu při~některém skoku
(např. reset časovače),
je nutné tyto konstanty v~jednotlivých fázích zdvojit,
kde první značí např. hodnotu na~začátku fáze
a druhá na~konci fáze.
Příklad:
\begin{Verbatim}[samepage=true]
(declare-fun tau_0_0  () Real) (declare-fun tau_0_1  () Real)
(declare-fun tau_t_0  () Real) (declare-fun tau_t_1  () Real)
;; ...
(define-fun jump ( (run1 Bool)  (run2 Bool)
                   (tau1t Real) (tau20 Real)
                 ) Bool
    (and (=> (and      run1  (<  tau1t 5) )
             (and      run2  (=  tau20 tau1t) ))
         (=> (and      run1  (>= tau1t 5) )
             (and (not run2) (=  tau20 0) ))
         ;; ...
))
(assert (and (jump run_0 run_1 tau_t_0 tau_0_1)
             (jump run_1 run_2 tau_t_1 tau_0_2)
))
\end{Verbatim}
\end{paragraph} %%Definice skoků.

%%%

% Fri 27 Apr 2018 01:06:37 PM CEST
\begin{paragraph}{Nastavení fází}\label{p:design:spec:ilang:struct:step}
znamená definovat časové okamžiky mezi integracemi,
tj.~např. hodnotami konstant \id{t\_\-i}.
Nejjednodušším způsobem je zavedení
konstantní periody \id{T}, např.:
\begin{Verbatim}[samepage=true]
(define-fun T () Real 1)
(assert (and (= t_1 (+ t_0 T)) (= t_2 (+ t_1 T)) ))
\end{Verbatim}
\end{paragraph} %%Nastavení fází.

%%%

% Sat 07 Apr 2018 08:05:17 PM CEST
\begin{paragraph}{Integrace}\label{p:design:spec:ilang:struct:int}
se provádí příkazy \id{int\--ode}.
Dochází tím k~propojení konkrétních vstupních a výstupních konstant
druhu \id{Real} a konstant druhu \id{Dt}.
Podle argumentů mezí nezávislé proměnné \id{t}
těchto příkazů je určeno rozložení fází výpočtu.
Všechna \acr{ode} ve~stejných časových mezích jsou
integrována synchronně.

Příklad:
\begin{Verbatim}[samepage=true]
(assert (and (= y_1 (int-ode y dy_0 (y_0 t_0 t_1) ()))
             (= y_2 (int-ode y dy_1 (y_1 t_1 t_2) ()))
))
\end{Verbatim}
a pro~případ zdvojených konstant fází (viz.~definice skoků):
\begin{Verbatim}[samepage=true]
(assert (and (= y_t_0 (int-ode y dy_0 (y_0_0 t_0 t_1) ()))
             (= y_t_1 (int-ode y dy_1 (y_0_1 t_1 t_2) ()))
))
\end{Verbatim}
\end{paragraph} %%Integrace

%%%

\end{subsubsection} %%Struktura a použití jazyka

%%%%%%%

% Sat 28 Apr 2018 08:55:39 PM CEST
\begin{subsubsection}{Předzpracování vstupu}
\label{sss:design:spec:ilang:macros}
Předzpracování vstupu znamená jeho úpravu
na~úrovni substitucí textu,
před samotným zpracováním,
bez~sémantické analýzy.
Základní funkcí předzpracování vstupu je odstranění komentářů.

Protože vstupy zpravidla obsahují velké množství opakujícího se kódu
plynoucí z~rozdělení výpočtu do fází,
byla do~možností předzpracování vstupního jazyka přidána \name{makra},
která umožňují parametrizované generování textového kódu.
Princip se podobá makrům jazyka C.
Rozlišují se \hl{příkazová} a \hl{uživatelská} makra.
Příkazová makra slouží jako direktivy pro~předzpracovač vstupu
a lze pomocí nich zavést uživatelská makra.
Uživatelská makra umožňují parametrizovanou textovou substituci.

Název každého makra musí být určen jediným tokenem,
který začíná znakem \id{\#}.
Pokud je makro parametrizováno,
musí být token následován výrazem s~parametry.
Pokud makro parametrizováno není,
token může a nemusí být následován prázdným výrazem \id{()},
doporučujeme však prázdný výraz používat,
čímž se zamezuje případné chybné interpretaci následujícího výrazu,
který není (nemá být) seznamem parametrů.
Parametry makra jsou v~jeho těle použita
jako dočasná uživatelská makra. Pokud název parametru
koliduje s~dříve definovaným uživatelským makrem,
má parametr přednost.

Makra mohou obsahovat vnořená makra.
Jsou-li makra expandována, vyhodnocení je provedeno rekurzivně
a není kontrolováno, zda je rekurze konečná.

Makra umí pracovat s~numerickými literály (včetně celočíselných),
ale ne s~literály \id{true} a \id{false} druhu \id{Bool}.

%%%

% Mon 23 Apr 2018 08:24:55 PM CEST
\begin{paragraph}{Příkazová makra}
\label{p:design:spec:ilang:macros:cmd}
se nesmí nacházet uvnitř vstupních výrazů,
ale mohou se nacházet uvnitř jiných maker.
Mezi tato makra patří:
\begin{itemize}
\item
   \begin{enumerate}
   \item \label{i:macro:if:if}
      \id{\#if <cond> <body> \#endif}
   \item \label{i:macro:if:else}
      \id{\#if <cond> <body1> \#else <body2> \#endif}
   \end{enumerate}
   Podmíněně \hl{expanduje} text \id{<body>},
   pokud je \hl{literál} \id{<cond>} vyhodnocen jako pravdivý.
   Ve~variantě \rf{i:macro:if:else}
   je navíc při nesplnění podmínky \id{<cond>}
   expandována část \id{<body2>}.
   Výsledkem může být i~prázdný text.
\item
   \begin{enumerate}
   \item \label{i:macro:def:def}
      \id{\#def <name> <|(<arg>*)> <body> \#enddef}
   \item \label{i:macro:def:define}
      \id{\#define <name> <|(<arg>*)> <body>}
   \end{enumerate}
   Zavádí \hl{globální uživatelské makro} s~názvem \id{<name>},
   s~parametry, nebo bez nich,
   s~obsahem \id{<body>}.
   Je povolena nejvýše jedna definice globálního makra \id{<name>}.
   Makro \id{<name>} \hl{není expandováno} v~místě definice,
   ale až v~místě volání.
   \id{<body>} tedy může obsahovat i~libovolná vnořená makra
   včetně dalších definic; korektnost závisí až na~kontextu
   místa volání makra. Makro smí být definováno i~rekurzivně,
   ale je nutné ohlídat koncové podmínky.

   Ve~variantě \rf{i:macro:def:def} může být tělo i~víceřádkové;
   varianta \rf{i:macro:def:define} je zakončena koncem řádku.
\item \id{\#let <name> <{}<body>|(<body>)> <scope> <|\#endlet <name>{}>} \\
   Zavádí \hl{lokální uživatelské makro}
   v~rámci \id{<scope>} s~názvem \id{<name>}
   bez~parametrů. Smí být definováno i~několik lokálních maker \id{<name>},
   platné je to naposledy definované.
   \id{<body>} je expandováno už v~místě definice,
   výsledkem expanze smí být i~prázdný text.
   Neuzávorkované \id{<body>} je interpretováno jako jediný token.
   \id{\#endlet} ukončuje platnost aktuálního makra.
\item
   \begin{enumerate}
   \item \label{i:macro:for:int}
      \id{\#for (<var> <init> <end>) <body> \#endfor}
   \item \label{i:macro:for:cond}
      \id{\#for (<var> <init> (<cond>) (<step>)) <body> \#endfor}
   \item \label{i:macro:for:list}
      \id{\#for (<var> (<list>)) <body> \#endfor}
   \end{enumerate}
   Expanduje text \id{<body>}, který může záviset na \id{<var>}
   jakožto lokálním uživatelském makru.
   Text je opakovaně expandován s~měnící se hodnotou \id{<var>}
   závisle na~uvedených podmínkách.

   V~těle smí být obsažena vnořená makra \id{\#for}.

   Varianta \rf{i:macro:for:int} generuje \id{<var>}
   s~celočíselnými hodnotami od~\id{<init>} do~\id{<end>} včetně,
   s~jednotkovým krokem.
   Varianta \rf{i:macro:for:cond} generuje \id{<var>}
   s~počáteční hodnotou \id{<init>} a následujícími hodnotami
   odpovídající vyhodnocení výrazu \id{(<step>)},
   dokud je výraz \id{(<cond>)} vyhodnocován jako pravdivý.
   Varianta \rf{i:macro:for:list} generuje \id{<var>}
   postupně se~všemi hodnotami uvedenými ve~výčtu \id{(<list>)}.
\end{itemize}

Příklady příkazových maker:
\begin{Verbatim}
#define TO_BOOL(cond) #if #cond true #else false
\end{Verbatim}
\begin{Verbatim}[samepage=true]
#define N() 5
#def SUM_SQR() (+
   #for (i 0 #N)  ;; equiv. to: #for (i 0 (<= #i #N) (+ #i 1))
                  ;; equiv. to: #for (i (0 1 2 3 4 5))
   #let j ((+ #i 1))
       (* #i #j)
   #endlet j
   #endfor
) #enddef
\end{Verbatim}
\end{paragraph} %%Příkazová makra

%%%

% Tue 24 Apr 2018 10:51:38 PM CEST
\begin{paragraph}{Uživatelská makra}
\label{p:design:spec:ilang:macros:user}
musejí být před použitím alespoň jednou definována
pomocí příkazových maker \id{\#def}, \id{\#define} nebo \id{\#let},
nebo jako parametry makra.
Parametry maker jsou interně zavedeny pomocí mechanismu
lokálních uživatelských maker
(s~tělem odpovídajícím hodnotě parametru v~místě volání),
a proto mezi nimi
nebude nadále rozlišováno.
Názvy lokálních a globálních maker se mohou navzájem překrývat,
přednost má vždy naposledy definované lokální makro.

V~každém místě volání jsou makra nahrazena za~definovaný text,
který může být závislý na~parametrech
nebo i~na~samotném makru~---~pak hovoříme o~\hll{rekurzi}.
Rekurze mají velkou vyjadřovací schopnost,
jelikož lze používat vnořených podmíněných maker \id{\#if}.
Pomocí těchto rekurzí lze např. zavést
makra \id{\#for}.
Průběh rekurzivních expanzí ale není nijak kontrolován.

Expanze maker je prováděna i~uvnitř tokenů.
Každý token je rozdělen na~části
podle znaků \id{\#}
a každá část je vyhodnocena zvlášť.
Je-li token složen z~více než jedné takové části,
jsou všechny expandované části \hl{složeny do~jediného tokenu},
a to i~v případě, že těla maker obsahují více než jeden token;
nesmí však obsahovat výrazy.
Vnitřní makra také nemohou mít žádné parametry,
jelikož parametry maker nikdy nejsou součástí tokenu,
protože se uvádí ve~výrazech.
Pouze poslední část tokenu smí obsahovat parametry
umístěné v~následujícím výrazu.

Nejen pro~účely oddělení částí maker a textu v~rámci jednoho tokenu
jsou zavedena dvě rezervovaná makra s~prázdným názvem
a s~názvem \id{\#}
(tj. volají se jako \id{\#} a \id{\#\#}).
\id{\#} je z~textu smazáno%
\footnote{\id{\#} může být použito pouze na~konci tokenu,
jinak je interpretováno jako makro s~názvem,
který následuje za~\id{\#}.};
\id{\#\#} je expandováno na~prázdný token.
Obě makra lze použít na~vynucení složení expanze makra do~jednoho tokenu.

Znak \id{\#} je možné použít jako escape sekvenci:
\id{\textbackslash\#},
čímž se zamezí expanzi makra (nebo je odložena)
a znak \id{\#} je ponechán nedotčen.
Toto je užitečné pro~účely předávání
tokenů, které obsahují lokální uživatelská makra,
jako parametrů globálního uživatelského makra,
pokud je žádoucí, aby bylo lokální makro expandováno až uvnitř těla
na~základě lokální definice.
(Příkazová makra \id{\#def}* svá těla neexpandují,
proto v~nich není potřeba escape sekvence používat.)
Bez použití escape sekvencí
není možné docílit toho, aby makro vygenerovalo znak \id{\#},
tj.~jakékoli neexpandované makro.

Doporučujeme používat tuto konvenci pro~názvy uživatelských maker:
velká písmena pro globální makra (\id{MACRO})
a malá písmena pro lokální makra (\id{macro}).
\end{paragraph} %%Uživatelská makra

%%%

% Fri 27 Apr 2018 02:22:15 AM CEST
\begin{paragraph}{Aritmetická expanze}\label{p:design:spec:ilang:macros:arith}
je dalším nástrojem v~rámci předzpracování vstupu,
který slouží k~nahrazení vstupního výrazu rezervované funkce
za~jeho aritmetické vyhodnocení.
Výraz nesmí obsahovat nepřímé argumenty,
jinak dojde k~chybě při vyhodnocení.
(Ve~fázi předzpracování lze používat pouze literály a makra,
ne konstanty a funkce.)

Expanze se provede předřazením tokenu \id{\$} před výraz (bez~\id{\#}).
(Vnořené výrazy už před sebou mít token \id{\$} nemusí.)
Výchozím typem argumentů vyhodnocovaných výrazů
jsou reálná čísla (resp. čísla s~plovoucí řádovou čárkou).
Typ lze také určit explicitně
přidáním znaku do~tokenu s~\id{\$}:
\begin{itemize}
\item \id{<d | i>} $\rightarrow$ celočíselný typ,
\item \id{f} $\rightarrow$ reálný typ.
\end{itemize}
\end{paragraph} %%Aritmetická expanze


%%%

\clearpage

% Fri 27 Apr 2018 05:18:55 PM CEST
\begin{paragraph}{Příklady obecného použití maker:}
\label{p:design:spec:ilang:macros:examples}
\begin{Verbatim}[samepage=true]
#define STEPS() 10
#define STEPS-1() $d (- #STEPS 1)
#def INT_ODE(f)
#for (i 0 #STEPS-1)
#let j $d(+ #i 1)
    (= #f##_#j (int-ode #f d#f##_#i (#f##_#i t_#i t_#j) ()))
#endlet j
#endfor
#enddef
(assert (and
    #INT_ODE(x) ;; (= x_1 (int-ode x dx_0 (x_0 t_0 t_1) ()))
                ;; (= x_2 (int-ode x dx_1 (x_1 t_1 t_2) ())) ...
    #INT_ODE(y) ;; (= y_1 (int-ode y dy_0 (y_0 t_0 t_1) ())) ...
))
\end{Verbatim}
\begin{Verbatim}[samepage=true]
#def FACT(n)
#if $(= #n 0)  *
#else          #FACT( $d(- #n 1) ) #n
#endif
#enddef
(assert (= $(#FACT(5)) 120) ) ;; $(* 1 2 3 4 5) == 120  => true
#define SEQ() 1 2 3
( #SEQ )  ;; (1 2 3)
( #SEQ# ) ;; (123)
( #FACT#(3) )  ;; error: missing parameters for 'FACT' !
( #FACT(3)# )  ;; (* 1 2 3)
( ##FACT(3) )  ;; (FACT(3))
( ###FACT(3) ) ;; (*123)
\end{Verbatim}
\end{paragraph} %%Příklady použití maker:

%%%

\clearpage

% Fri 27 Apr 2018 05:18:55 PM CEST
\begin{paragraph}{Použití maker ve~vstupním jazyce:}
\label{p:design:spec:ilang:macros:usage}
\begin{itemize}
\item Definice numerických literálů,
   které lze použít i~v~příkazech \id{define\--dt}:
   \begin{Verbatim}[samepage=true]
   #define K() 5
   (define-dt x dx () (* #K t))
   \end{Verbatim}
\item Nastavení fází výpočtu:
   \begin{Verbatim}[samepage=true]
   #define T()     0.5
   #define T_MIN()   0
   #define T_MAX()  10
   #define STEPS() $d(+ $f(/ (- #T_MAX #T_MIN) #T) )
   ;; ...
   #def T_STEPS()
   #for (j 1 #STEPS)
   #let i $d(- #j 1)
       (= t_#j  (+ t_#i  #T))
   #endlet j
   #endfor
   #enddef
   \end{Verbatim}
\item Deklarace všech konstant fází:
   \begin{Verbatim}[samepage=true]
   #def DECL_CONSTS(const type)
   #for (i 0 #STEPS)
       (declare-fun #const##_#i () #type)
   #endfor
   #enddef
   #DECL_CONSTS(t  Real)
   ;; ...
   \end{Verbatim}
   Stejný způsob lze použít pro~invarianty,
   volby variant derivací, skoky a integrace.
\item Aproximace intervalových počátečních podmínek:
   \begin{Verbatim}[samepage=true]
   #def INIT_INTERVAL(var min max step) (or
   #for (i #min (<= #i #max) (+ #i #step))
      (= #var #i)
   #endfor
   ) #enddef
   \end{Verbatim}
\item Kaskádní kompozice systémů:
   každý systém reprezentovat vlastní sadou konstant
   s~nějakou číselnou příponou
   a vstup generovat pomocí maker \id{\#for}
   nebo rekurzivních maker.
   Krajní systémy generovat zvlášť,
   nebo pomocí makra \id{\#if},
   a ostatní propojit pomocí parametrických uživatelských maker,
   např. s~parametrem \id{\#i} a \id{\#let j \$d(+ \#i 1)}.
\end{itemize}
\end{paragraph} %%Použití maker ve~vstupním jazyce:

%%%

\end{subsubsection} %%Předzpracování vstupu

%%%%%%%

\end{subsection} %%Vstupní jazyk

%%%%%%%%%%%%%

% Sat 28 Apr 2018 11:04:53 PM CEST
\begin{subsection}{Výstupy}\label{ss:design:spec:out}
Výstupem řešiče je především příznak splnitelnosti.
Je-li vstup splnitelný,
pak volitelně také ohodnocení diferencovaných konstant
v~jednotlivých fázích.
Pokud je navíc zadán výstupní soubor,
jsou do~něj zapsány celé trajektorie
všech diferencovaných funkcí
a z~těchto dat je vykreslen společný graf.

V~případě konečné množiny počátečních podmínek
je výstupem \id{sat} nebo \id{unsat}
v~případě splnitelného nebo nesplnitelného vstupu.
S~výjimkou zanedbání aproximačních chyb \acr{ode} řešiče
jsou tyto výstupy exaktní,
jelikož řešič buď nalezne splňující ohodnocení,
nebo prozkoumá všechny možnosti a ověří, že žádná není splnitelná.

V~případě nekonečné množiny počátečních podmínek
je možný výstup \id{sat},
ale pokud je vstup nesplnitelný,
výpočet pravděpodobně nikdy neskončí.

Výstup \id{unknown} \hl{není} navržen,
ač by byl v~některých případech vhodný,
např. pro~nesplnitelné intervalové počáteční podmínky.
\end{subsection} %%Výstupy

%%%%%%%%%%%%%

\end{section} %%Specifikace nástroje

%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Mon 09 Apr 2018 02:15:54 PM CEST
\begin{section}{Softwarová architektura}\label{s:design:arch}
V~následující sekci popíši abstraktní návrh
modelu komponent celého řešiče,
jejich vztahů a rozhraní a rozdělení zodpovědností.
Poté rozeberu interní návrh jednotlivých komponent.

%%%%%%%%%%%%%

% Mon 09 Apr 2018 02:17:08 PM CEST
\begin{subsection}{Model komponent}\label{ss:design:arch:comp}
Stěžejními komponentami jsou \acr{smt} a \acr{ode} řešič.
Úkolem je zajistit jejich vzájemnou komunikaci
a řídit centrální algoritmus celého procesu
od~přijmutí vstupu ve~vstupním jazyce po výpis výsledků.

Průběh výpočtu se řídí zejména \acr{smt} řešičem.
První otázkou bylo, zda celý systém řídit
z~\acr{smt} řešiče, nebo jej použít jako externí komponentu
a centrální bod umístit mimo něj.
Pokud by byl \acr{smt} řešič centrálním bodem,
mohly by být maximálně využity všechny jeho funkce.
Nevýhodou by však byla nutnost
zvolit konkrétní řešič
a komunikaci s~\acr{ode} řešičem
implementovat uvnitř,
což by vyžadovalo podrobnější obeznámení se
s~fungováním \acr{smt} řešiče.
Je však tento postup nutný?

Pokud by byl \acr{smt} řešič
implementován jako černá skříňka,
bylo by použití celého systému mnohem flexibilnější.
\acr{smt} řešiče jsou stále v~aktivním vývoji
a možnost použít libovolnou verzi
by bylo velkým přínosem.
Proto bylo snahou nalézt řešení
využívající tohoto postupu.

%%%%%%%

% Wed 02 May 2018 07:57:32 PM CEST
\begin{subsubsection}{\acr{smt} řešič jako nezávislá komponenta}
\label{sss:design:arch:comp:smt}
\acr{smt} řešič lze použít
jako téměř nezávislou komponentu,
pokud splňuje tyto požadavky:
\begin{itemize}
\item je inkrementální,
\item je konformní s~\acr{smt}-LIB standardem.
\end{itemize}
Každý takový řešič pak lze používat
a komunikovat s~ním výhradně prostřednictvím
\acr{smt}-LIB jazyka,
tj.~přes soubory nebo standardní vstup a výstup.

Vzhledem k~tomu, že \acr{smt}-LIB
obsahuje operace se~zásobníkem asercí
(viz.~sekce \rf{ss:search:smt:smtlib}),
je možné dynamicky přidávat a odebírat
klauzule, což lze použít
pro~přijímání hodnot z~\acr{ode} řešiče.
Druhá možnost je přidávání
podmíněných a konfliktních klauzulí
s~vypočtenými hodnotami z~\acr{ode} řešiče.
Tyto postupy jsou možné z~toho důvodu,
že \acr{ode} řešič v~našem pojetí
pracuje výhradně s~pevnými počátečními podmínkami
a má tedy i~jednoznačný výstup.
Hodnoty konstant jsou získávány postupně
od~počátečních podmínek a přidávány jako nové aserce.
Při~porušení některých invariant
se provede návrat.
Podrobnější algoritmus je popsán
v~centrální komponentě.

Svým způsobem lze tento postup použít
i~jako opakovaně generované celistvé statické vstupy
pro~neinkrementální \acr{smt} řešič,
ale předpokládá se, že inkrementální řešič
si bude počínat efektivněji.

Tímto je získáno velké flexibility
ze~strany \acr{smt} řešiče,
vzhledem k~tomu, že \acr{smt}-LIB standard
podporuje většina řešičů.
Jediné potenciální riziko
je neefektivní počínání řešičů
v~inkrementálním módu,
tj. pokud by obecně operace ověření splnitelnosti
byla výpočetně náročná,
vzhledem k~tomu, že tato operace bude prováděna často.
Předpokládá se však,
že doba výpočtu by měla být výrazně nižší
v~následujících fázích,
které přidávají jen malé množství nových asercí,
oproti první fázi,
který řeší celý počáteční vstup.

Používání textového rozhraní pomocí \acr{smt}-LIB
by mělo mít zanedbatelný vliv na~výkon
oproti použití programového rozhraní,
v~porovnání s~dobou samotných výpočtů
\acr{smt} a \acr{ode} řešičů.
Implementace si však musí poradit
s~korektními konverzemi čísel s~plovoucí řádovou čárkou
z~textu či do~textu,
protože \acr{smt} řešič pracuje s~exaktními hodnotami.
\end{subsubsection} %%\acr{smt} řešič jako nezávislá komponenta

%%%%%%%

% Fri 27 Apr 2018 10:09:24 PM CEST
\begin{subsubsection}{\acr{ode} řešič}\label{sss:design:arch:comp:ode}
\acr{ode} řešič postačuje použít jako samostatnou komponentu,
jelikož má fungovat jako
filtr~---~pro~každý vstup vrátí odpovídající výstup.
Výjimkou je jen jeho inicializace,
kdy se musí nastavit tvary diferenciálních rovnic.
Konkrétní rozhraní nehraje důležitou roli,
jen je důležité dávat pozor na~nastavení přesnosti
čísel s~pohyblivou řádovou čárkou,
protože \acr{smt} řešič pracuje s~racionálními čísly,
které jsou exaktní. To může činit potíže zejména
při~komunikaci prostřednictvím znakových řetězců.

Důležitým požadavkem je však to,
aby byl řešič schopen přijímat
specifikace diferenciálních rovnic
dynamicky jako text,
protože tak jsou reprezentovány ve~vstupním jazyce.
Např. řešiče odeint a \acr{sundials}
přijímají specifikace jako kompilované funkce
přímo v~programovacím jazyce,
což je efektivní, ale pro tento účel
nevhodná varianta.
Řešiče, které to umějí, existují
(např.~\acr{gnu} Plotutils,
\acr{gnu} Octave, SageMath;
nemluvě o~komerčních nástrojích),
ale problém je např.~v~tom,
že (pochopitelně) nemají navzájem
nijak standardizován vstupní formát,
jako tomu je třeba u~\acr{smt} řešičů
s~\acr{smt}-LIB standardem.
Pokud bychom zvolili některý z~nich,
mohlo by být následně poměrně obtížné umožnit
nasazení jiného řešiče.

Komponentu s~\acr{ode} řešičem
by bylo možné navrhnout tak,
aby nějakým způsobem obalovala
obecné funkcionality řešiče
bez~ohledu na konkrétní použitý nástroj.
Toho lze docílit navržením komponenty
jako abstraktní třídy
obstarávající veřejné rozhraní
a konkrétní implementaci přenechat
na~odvozených třídách.
Pokud by byl zvolený \acr{ode} řešič
implementován v~jazyce C++ nebo C,
měla by být jeho implementace
uvnitř odvozené třídy snadná,
a navíc by takové řešení mělo být efektivní.

Po~řešiči je (prozatím) vyžadována
pouze integrace na~základě
exaktních počátečních podmínek
a koncových podmínek
určených předem danou délkou integrace,
bez~řešení jakýchkoli invariant.
\end{subsubsection} %%\acr{ode} řešič

%%%%%%%

% Wed 02 May 2018 07:57:55 PM CEST
\begin{subsubsection}{Zpracování vstupu}\label{sss:design:arch:comp:parse}
Vstupní jazyk je navržen podobně
jako jazyk \acr{smt}-LIB standardu,
což značně usnadňuje zpracování vstupu,
jelikož stačí zpracovat jen přidané \acr{ode} konstrukty
a celý zbytek vstupu delegovat s~jen minimálními změnami
na~\acr{smt} řešič jako inicializaci.
\acr{ode} řešič je nutné inicializovat
definicemi všech diferenciálních rovnic
a jejich argumentů.

Přidanou hodnotou je umožnění použití maker,
pomocí nichž lze vstupy parametrizovat
a ke generování není zapotřebí dalšího nástroje.
Předzpracování vstupu, tak jak je navrženo,
je zcela nezávislé
na~sémantice vstupního jazyka
a mělo by být implementováno jako samostatná komponenta.

Komponenta zpracování vstupu bude s~konstantami a funkcemi
pracovat výhradně na~úrovni jejich identifikátorů
a nebude řešit jejich možné hodnoty;
to bude zodpovědnost centrální komponenty
a \acr{smt} řešiče.
\end{subsubsection} %%Zpracování vstupu

%%%%%%%

% Fri 27 Apr 2018 10:26:30 PM CEST
\begin{subsubsection}{Centrální komponenta}
\label{sss:design:arch:comp:center}
Zodpovědností centrálního bodu je
na~základě zpracovaného vstupu
nastavit diferenciální rovnice
a ty související sjednotit,
inicializovat oba řešiče
a určit fáze výpočtu.
Následně pak řídit
průběh výpočtu
a komunikaci mezi oběma řešiči.

Díky několika možným rozhraním u~obou řešičů
je návrh poměrně volný
a důraz je kladen hlavně na~zvolený řídící algoritmus,
který musí korektně ověřit všechny možnosti
ohodnocení vstupních konstant a funkcí
a přiměřeně efektivně zacházet
s~inkrementálním \acr{smt} řešičem, zejména s~návraty.
Návrh algoritmu je uveden v~samostatné sekci.
\end{subsubsection} %%Centrální komponenta

%%%%%%%

\end{subsection} %%Model komponent

%%%%%%%%%%%%%

% Tue 10 Apr 2018 10:38:59 AM CEST
\begin{subsection}{Návrh \acr{ode} řešiče}\label{ss:design:arch:ode}
Problém s~dynamickými textovými specifikacemi diferenciálních rovnic
a sestavení odpovídajících funkcí
jsem se rozhodl řešit formou stromových struktur výrazů
a jejich transformací na~funkce s~argumenty.
Tyto struktury pak lze použít jako vstupní specifikace při~inicializaci
a vytvořené funkce volat ve~fázích integrace.

Nejprve popíši návrh avizované struktury
a poté návrh abstraktního řešiče.

%%%%%%%

% Tue 10 Apr 2018 10:40:12 AM CEST
\begin{subsubsection}{Výrazy a jejich vyhodnocení}
\label{sss:design:arch:ode:exprs}
Tato datová struktura sestává
z~\name{výrazů} a z~jejich i~několika \hl{vyhodnocení}.

%%%

% Fri 27 Apr 2018 10:40:29 PM CEST
\begin{paragraph}{Výraz}\label{p:design:arch:ode:exprs:expr}
je obecná stromová struktura
sestavená z~prefixových textových výrazů.
Každý výraz obsahuje spojový \hl{seznam} potomků,
z~nichž každý je buď další podvýraz,
nebo token s~textovou hodnotou.
Seznam je použit proto,
že se předpokládá sekvenční průchod jeho strukturou,
a aby bylo možné efektivně odkudkoli odebírat či přidávat prvky.

Výraz ve~výchozí formě nemá určen žádný datový typ
a používá pouze znaky.
Může být tedy použit pro~libovolné účely
vyžadující vytvoření hierarchické struktury
z~(ne zcela nutně) prefixového vstupu,
např. i~pro~účely syntaktického rozboru
textového vstupu, který ani není výrazem,
ale používá prefixovou notaci.

Po~této struktuře je vyžadováno,
aby co nejvíce zpřístupnila sekvenční čtení i~zápis,
což budou velmi časté operace.
\end{paragraph} %%Výraz

%%%

% Tue 24 Apr 2018 02:09:07 PM CEST
\begin{paragraph}{Vyhodnocení}\label{p:design:arch:ode:exprs:eval}
se vždy vztahuje k~jedinému výrazu,
ale výraz může mít přidružených i~několik vyhodnocení.
Úloha vyhodnocení je vytvořit z~obecné textové struktury
výrazu strom konkrétních funkcí s~přímými či nepřímými argumenty
konkrétního aritmetického typu,
který lze v~inicializaci volit různě.
Tato struktura musí umožňovat volání jako funkce,
případně i~s~parametry,
pokud výraz obsahuje nepřímé argumenty.

Když je výraz transformován na~vyhodnocení,
musí být jeho první prvek token s~názvem nějaké funkce,
typicky aritmetickým operátorem.
Následující prvky nemají žádná omezení
(kromě toho zmíněného pro~podvýrazy)
a platí pro~ně následující:
\begin{itemize}
\item je-li prvek další podvýraz, vytváří se další vyhodnocení,
\item je-li prvek token, provede se konverze na~datový typ;
   pokud konverze selže (token nereprezentuje hodnotu daného typu),
   je token považován za~nepřímý argument.
\end{itemize}
Nepřímé argumenty se později dosadí
jako parametry při~volání vyhodnocení
a textové hodnoty tokenů jsou uloženy jako klíče argumentů.
Nepřímých argumentů se~stejným klíčem
může být ve~výrazu obsaženo více.
\end{paragraph} %%Vyhodnocení

%%%

\end{subsubsection} %%Výrazy a jejich vyhodnocení

%%%%%%%

% Tue 24 Apr 2018 02:11:09 PM CEST
\begin{subsubsection}{Abstraktní řešič}\label{sss:design:arch:ode:solver}
Řešič bude implementován abstraktní třídou tak,
aby umožňoval snadné odvození na~konkrétní \acr{ode} řešič
s~implementací různých metod integrace funkcí.
Odvozené třídy by měly řešit pouze implementaci konkrétních metod,
ale veřejné i neveřejné rozhraní by měla řešit abstraktní třída,
včetně stanovení použitých datových struktur.

Řešič bude umožňovat inicializaci
specifikací diferenciálních rovnic
primárně pomocí datových struktur výrazů uvedených
v~sekci \rf{p:design:arch:ode:exprs:expr}.
K~těmto výrazům si řešič interně sestaví odpovídající
vyhodnocení tak, jak jsou uvedeny
v~sekci \rf{p:design:arch:ode:exprs:eval}.
Uživatel bude pracovat pouze s~výrazy,
od~vyhodnocení bude odstíněn.
Naopak implementace odvozených řešičů
budou pracovat pouze se~sestavenými vyhodnoceními.
Vyhodnocení budou vždy obsahovat i~nepřímé argumenty,
implicitně alespoň argument integrované funkce
a volitelně také argument nezávislé proměnné \id{t}
(viz.~vztah \rfeq{ode}).

Specifikované diferenciální rovnice bude možné počítat opakovaně
s~různými vstupními argumenty podle konstant
aktuálních příkazů \id{int\--ode}.
Při výpočtech budou v~implementaci
interně volána sestavená vyhodnocení
v~každém kroce integrace,
což vyžaduje, aby bylo volání vyhodnocení
přiměřeně efektivní,
jelikož kroků integrace
bude řádově stovky až statisíce
(podle délky fází výpočtu).

Třída by se však měla pokud možno chovat
jako obecný \acr{ode} řešič
bez~užších vazeb na~problém \acr{smt}.
Tuto zodpovědnost by měla řešit centrální komponenta.

Řešič bude také podporovat ukládání průběhu
integrací všech \acr{ode} a jejich výpis.

Takový řešič bude možné používat jako filtr
(s~výjimkou inicializace)~---~na~každý vstup
odpoví výstupními hodnotami.
\end{subsubsection} %%Abstraktní řešič

%%%%%%%

\end{subsection} %%Návrh \acr{ode} řešiče

%%%%%%%%%%%%%

% Thu 03 May 2018 01:52:27 PM CEST
\begin{subsection}{Návrh zpracování vstupu}\label{ss:design:arch:parse}
Úkolem komponenty pro~zpracování vstupu
je nalézt příkazy \acr{ode} vstupního jazyka
(viz.~\rf{sss:design:spec:ilang:ode})
a částečně také \acr{smt} konstrukty
(viz.~\rf{sss:design:spec:ilang:smt}),
zpracovat je a nahradit je za~konstrukce
výhradně \acr{smt}-LIB standardu,
nebo je zcela vyřadit.
Postup je následující:
\begin{enumerate}
\item Nastavení \acr{smt} vstupu: zvolení logiky,
   definice druhu \id{Dt}, ad.
\item Zpracování definic diferenciálních rovnic:
   načtení definic diferenciálních rovnic do~výrazů
   a načtení seznamů klíčů nepřímých argumentů pro~\acr{ode} řešič
   z~příkazů \id{define\--dt};
   definice konstant variant derivací druhu \id{Dt}
   s~názvy podle identifikátorů z~\id{define\--dt}.
\item Substituce příkazů integrací \id{int\--ode}
   za~pomocné konstanty nebo funkce druhu \id{Real};
   sekvenční uložení identifikátorů argumentů příkazů \id{int\--ode}
   a roztřízení podle jednotlivých \acr{ode}
   a podle unikátních párů identifikátorů nezávislých proměnných \id{t}.
   (Nastavení fází je zodpovědnost centrální komponenty.)
\item (Volitelné) nastavení počáteční délky kroku integrací
   z~příkazu \id{define\--ode\--step} a jeho smazání.
\item Transformace zbylých konstruktů nekompatibilních
   s~\acr{smt}-LIB standardem, které jsou povoleny ve~vstupním jazyce
   (např. záporné numerické literály).
\end{enumerate}

Ke~zpracování vstupu lze s~výhodou
použít struktury výrazů
ze~sekce \rf{p:design:arch:ode:exprs:expr},
jelikož vstupní jazyk používá prefixovou notaci.
\end{subsection} %%Návrh zpracování vstupu

%%%%%%%%%%%%%

% Tue 24 Apr 2018 03:13:08 PM CEST
\begin{subsection}{Návrh předzpracování vstupu}
\label{ss:design:arch:preprocess}
Tato komponenta má fungovat samostatně pro~libovolný prefixový vstup,
tak jak je definována v~sekci \rf{ss:design:spec:ilang},
ale bez ohledu na~sémantiku tokenů a výrazů,
s~výjimkou komentářů a maker.
Návrh maker je uveden v~podsekci \rf{sss:design:spec:ilang:macros}.

V~první řadě se provedou nejjednodušší substituce textu
na~úrovni řádků, bez~ohledu na strukturu výrazů i~maker.
V~této fázi dojde ke~smazání komentářů
a k~nahrazení řádkových maker \id{\#define}
za~jejich uzavřený ekvivalent ve~tvaru makra \id{\#def}.
Poté je vstup nezávislý na~řádcích
a je závislý výhradně na~struktuře výrazů a maker.

Následné zpracování textu bude (opět) založeno na~třídách výrazů
ze~sekce \rf{p:design:arch:ode:exprs:expr}.
Výrazy a makra budou procházeny rekurzivně
a každý token obsahující makro bude náležitě zpracován,
což bude vyžadovat operace vkládání a odstraňování potomků výrazů.
\end{subsection} %%Návrh předzpracování vstupu

%%%%%%%%%%%%%

% Sat 28 Apr 2018 01:56:13 PM CEST
\begin{subsection}{Řídící algoritmus}\label{ss:design:arch:alg}
Úlohou algoritmu je dospět v~\acr{smt} řešiči
k~ohodnocení všech konstant
na~základě výsledků rovnic z~\acr{ode} řešiče.
Hlavní výzvou je problém s~návraty,
kdy v~průběhu výpočtu dochází k~tomu,
že vstup v~aktuální podobě není splnitelný.
Návraty má efektivně implementován \acr{smt} řešič,
ale je otázkou, jakým způsobem je na~něj delegovat.

Složitost roste s~počtem fází výpočtu
a s~počtem všech možných voleb derivací.
V~nejhorším případě se musí projít všechny možnosti,
tomu se nelze vyhnout, kromě použití nějakých heuristik,
které ale nebudou uvažovány.
Rovněž nebudou uvažovány možnosti paralelizace.

%%%

% Sat 28 Apr 2018 01:56:20 PM CEST
\begin{paragraph}{Diskuze redukce ověření splnitelností.}
\label{ss:design:arch:alg:discuss}
Důležitým aspektem je poměr výpočetních náročností
operací ověření splnitelnosti \acr{smt} řešičem
a výpočtu diferenciálních rovnic \acr{ode} řešičem.
Vzhledem k~tomu, že celý výpočet je rozdělen
do~mnoha relativně málo vzdálených fází,
je délka integrací poměrně malá
oproti běžným případům užití.
Navíc integrace počítá jen s~malým množstvím
vstupních hodnot,
oproti \acr{smt} řešiči,
který musí v~každé fázi ověřit splnitelnost kompletně celého vstupu,
ač v~inkrementálním módu.
Dá se tedy očekávat,
že \acr{ode} řešič bude rychlejší než \acr{smt} řešič,
a efektivní algoritmus by měl redukovat
počet operací ověření splnitelnosti
a částečně do~nich delegovat návraty.

Návraty na~\acr{smt} řešič bohužel není v~rozumné míře
možné delegovat zcela,
protože takový postup by vyžadoval
spočítat úplně všechny možnosti průchodů.
Důvod je ten, že každá dílčí integrace závisí
na~konkrétních vstupních hodnotách,
a tyto zase tranzitivně závisí
na~všech předešlých.
Tudíž není možné mít v~každé fázi
pokryty všechny možnosti,
např. pomocí podmíněných klauzulí,
aniž by složitost rostla exponenciálně.

Částečná redukce ověření splnitelnosti
je možná pomocí způsobu,
kdy se v~každé fázi vyřeší
kromě \acr{smt} řešičem zvolené varianty derivací
navíc také všechny ostatní kombinace voleb variant
v~rámci aktuální fáze
a přidají se jako podmíněné klauzule.
Tím by se pokrylo lokální okolí aktuální fáze
a počet nutných ověření splnitelnosti
by se redukovalo o~jednu úroveň stromu prohledávaného prostoru,
a pomocí podmíněných klauzulí by se částí návratů zabýval \acr{smt} řešič.

Počet všech kombinací variant derivací
závisí na~produktu počtu variant derivací každé \acr{ode},
kterých je omezený počet a nezávisí na~velikosti vstupu (počtu fází),
ale výhradně na~obecné specifikaci modelu.
Tento počet by tedy neměl být velký
a pokud by byl \acr{ode} řešič výrazně rychlejší
než \acr{smt} řešič,
měla by redukce počtu ověření splnitelnosti
převážit nad~nadbytečným výpočtem diferenciálních rovnic.
Takový algoritmus by si však v~případě návratů
musel nějakým způsobem pamatovat,
které vypočtené varianty už procházel a které ještě ne.

Postup řešením více variant derivací
lze dále modifikovat~---~řešit jich více či méně,
o~více fází napřed, apod.
Efektivita zvoleného řešení by závisela
na~empirickém měření složitosti,
analyticky ji lze těžko předpovědět.
\end{paragraph} %Diskuze redukce ověření splnitelností.

%%%

% Sat 28 Apr 2018 01:56:07 PM CEST
\begin{paragraph}{Základní algoritmus.}
\label{ss:design:arch:alg:discuss}
Pro~účely prototypu navrhnu zatím alespoň základní algoritmus,
který postupuje jen po~jednotlivých
cestách ve~stromu prohledávaného prostoru,
výhradně na~základě aktuálního ohodnocení konstant,
bez~předběžných výpočtů jiných variant.
Takový postup je jednodušší implementovat,
ale v~každé fázi vyžaduje ověření splnitelnosti,
a tedy významně závisí na~její výkonnosti.

V této variantě ztrácí smysl přidávat
nové hodnoty jako podmíněné klauzule,
namísto toho stačí aserce jen vkládat do~zásobníku asercí.
Důvod, proč samotné podmíněné klauzule nefungují,
je ten, že nově vypočtené hodnoty
jsou podmíněny jejich vstupními podmínkami,
ale \acr{smt} řešič nic nenutí tyto vstupní podmínky zvolit
a smí si zvolit i~jiné varianty derivací,
které ale ještě nejsou spočtené,
a tudíž si za~výsledek integrace smí dosadit libovolnou hodnotu.
Tudíž by bylo nutné kromě podmíněné klauzule
navíc explicitně přidat klauzule,
které vyžadují vstupní hodnoty v~předpokladech.
Tím ale podmíněné klauzule ztrácí smysl
a stačí jen rovnou přidat předpoklady
i~výsledky do~asercí bez~podmínek.

Bez~použití podmíněných klauzulí
je však nutné při~návratu
přidané aserce odebrat,
což umožňují operace se zásobníkem asercí.
Je nutné přidávat konfliktní klauzule,
tím se definitivně uzavírají větve
ve~stromu prohledávaného prostoru
a algoritmus tak konverguje k~výsledku.
Se~vzrůstajícím množstvím konfliktních klauzulí
však roste složitost dílčích operací ověření splnitelnosti.

Postup je následující:
\begin{enumerate}
\item Překlad vstupní formule:
   \begin{enumerate}
   \item Uložení definic diferenciálních rovnic
      ze~zpracovaného vstupu, určení rozložení fází výpočtu%
      \footnote{Tato operace není diskutována,
      nicméně ve~zcela obecném případě se může jednat
      o~poměrně náročnou úlohu.}.
   \item Sloučení všech \acr{ode}, které obsahují
      společné klíče nepřímých argumentů,
      do~soustav \acr{ode}.
   \item Inicializace \acr{smt} řešiče,
      tj.~zaslání modifikovaného vstupu
      bez~specifikací diferenciálních rovnic.
   \item Inicializace \acr{ode} řešiče,
      tj.~zaslání specifikací (soustav) diferenciálních rovnic.
   \end{enumerate}
\item Nastav počáteční číslo fáze na~$0$: \id{s~:= 0}.
\item \label{i:design:alg:check-sat}
   Ověření splnitelnosti \acr{smt} formule:
   \begin{itemize}
   \item Je-li splnitelná, získej model,
      tj.~ohodnocení všech konstant.
   \item Není-li splnitelná, proveď návrat:
      \begin{enumerate}
      \item Pokud \id{s = 0}, vstup není splnitelný. Konec.
      \item Odeber vrchní úroveň zásobníku asercí: \id{(pop~1)}.
      \item Přidej konfliktní klauzuli (aserci)
         znemožňující vstupní (nikoli výstupní%
         \footnote{Přidání výstupních hodnot do~konfliktní
         klauzule by umožnilo řešiči za~ně dosadit jiné hodnoty
         a tím zneplatnit celou klauzuli.})
         ohodnocení předchozí fáze.
      \item Vrať se do~předchozí fáze:
         \id{s-{}-}, jdi na~bod \rf{i:design:alg:check-sat}.
      \end{enumerate}
   \end{itemize}
\item Pokud je dosaženo celkového počtu fází,
   jdi na~bod \rf{i:design:alg:end}.
\item Vyber ohodnocené konstanty,
   které do~fáze vstupují jako vstupní argumenty.
\item Proveď výpočet všech diferenciálních rovnic
   v~rámci aktuální fáze a ulož výstupy.
\item Přidej výstupní i~vstupní hodnoty této fáze
   jako aserce do~nové úrovně zásobníku asercí: \id{(push~1)}.
\item Přejdi do~další fáze: \id{s+{}+},
   jdi na~bod \rf{i:design:alg:check-sat}.
\item \label{i:design:alg:end}
   Vypiš získaný model. Konec.
\end{enumerate}

Tento postup se díky konfliktním klauzulím
podobá algoritmu \acr{dpll}.
\end{paragraph} %%Základní algoritmus.

%%%

\end{subsection} %%Řídící algoritmus

%%%%%%%%%%%%%

\end{section} %%Softwarová architektura

%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Wed 02 May 2018 09:31:27 PM CEST
\chapter{Realizace}\label{ch:impl}
V~implementaci řešiče jsem postupoval
po~jednotlivých softwarových komponentách
podle jejich návrhu.
V~některých případech,
zejména u~centrální komponenty,
je realizace oproti návrhu zjednodušena,
což je v~odpovídající sekci explicitně zmíněno.
Výsledný prototyp lze použít
pro~účely experimentování s~různými modely hybridních systémů
a pro~účely srovnání s~řešičem
pracujícím s~intervalovou metrikou,
konkrétně dReal (viz.~sekce \rf{p:search:hybrid:dreal}).

Nejprve popíši projekt jako celek,
poté rozeberu implementaci jednotlivých komponent,
centrální komponentou konče.
Na~závěr uvedu výčet některých nedostatků
a dosud chybějících funkcionalit
jako seznam úkolů do~budoucna.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Wed 02 May 2018 09:55:23 PM CEST
\begin{section}{Struktura a vlastnosti projektu}\label{s:impl:proj}
Projekt jsem nazval \name{\acrf{sos}}.
Řešič je koncipován
jako soubor knihoven, appletů a hlavní aplikace,
implementovaných převážně v~jazyce C++ (není-li řečeno jinak).
Přestože se jedná o~prototyp, je projekt strukturně koncipován tak,
aby byla jeho případná rozšíření a další vývoj
možná provést snadno přímo v~něm.
Projekt je zamýšlen jako soubor knihoven
umožňující použití různých \acr{smt} a \acr{ode}
řešičů jak jako samostatných aplikací, tak jako C++ knihoven.
Projekt používá verzovací systém \name{git},
má otevřené zdrojové kódy
a je veřejně dostupný včetně tohoto textu práce na~adrese
\url{https://github.com/Tomaqa/sos}.

Zdrojové kódy napsané v~C++ používají standard C++14
(nejsou zpětně kompatibilní se staršími standardy)
a jsou umístěny ve~jmenném prostoru \id{SOS}.
Moduly, které zprostředkovávají některý z~řešičů,
jsou izolovány od dalších zodpovědností.
Tyto moduly jsou pochopitelně závislé na~knihovnách třetích stran.
Kromě těchto (vyměnitelných) modulů je však celý projekt
se~základními funkcemi
nezávislý od~externích knihoven a využívá výhradně
vlastní a standardní knihovny \acr{stl}
a \acr{posix}.
C++ zdrojové kódy jsou zapsány ve~stylu Stroustrup%
\footnote{Podle tvůrce jazyka C++: Bjarne Stroustrup.}.

Hlavní aplikace je umístěna v~souboru \binFn{sos\_\-odeint}.
Je implementována v~jazyce C++
a podrobněji rozebrána ve~vlastní sekci.
Původně byla vyvíjena ve~skriptovacím jazyce Bash
v~souboru \binFn{prototype.sh},
který již v~aktuální verzi není přítomen,
ale je zpětně dohledatelný.

Před použitím nástroje je nutné jej sestavit.
Návod je umístěn v~příloze \cmt{link}.
Všechny uvedené soubory aplikací či appletů
jsou přístupné až po~tomto sestavení.

Nástroj byl vyvíjen a testován pouze v~\acr{os} Linux.
\end{section} %%Struktura a vlastnosti projektu

%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Tue 24 Apr 2018 03:57:40 PM CEST
\begin{section}{Realizace výrazů a jejich vyhodnocení}
\label{s:impl:exprs}
Vzhledem k~tomu, že tyto struktury využívá většina komponent projektu,
jsou implementovány jako samostatná knihovna
a uvedeny ve~vlastní sekci.

Výrazy reprezentuje třída \id{Expr}
a jejich vyhodnocení šablonová třída \id{Expr::\-Eval<Arg>}.

%%%

% Thu 03 May 2018 12:58:59 PM CEST
\begin{paragraph}{\id{Expr}}\label{p:impl:exprs:expr}
je odvozená třída od~abstraktní třídy \id{Expr\_\-place}.
\id{Expr} využívá polymorfismu~---~obsahuje
stromovou strukturu jako seznam ukazatelů na~\id{Expr\_\-place},
které představují argumenty výrazu.
Argumenty jsou objekty tříd odvozených od~\id{Expr\_\-place}:
buď uzly jako další podvýrazy (\id{Expr}),
nebo koncové listy, které reprezentují nějakou hodnotu.
Ty jsou implementovány šablonovou třídou \id{Expr\_\-value<Arg>},
která může jako šablonový parametr obsahovat i~netextový typ
(což je vlastně v~rozporu s~návrhem).
Jako její speciální odvozená třída je zavedena
třída \id{Expr\_\-token}, která obsahuje textovou hodnotu.
Pokud uživatel nepoužívá objekty
\id{Expr\_\-value<Arg>},
pak je struktura nezávislá od~interpretace.

\id{Expr\_\-token} umožňuje šablonovou
interpretaci svého textového obsahu
jako aritmetického typu pomocí \id{get\_\-value},
a také nastavení podle aritmetické hodnoty pomocí \id{set\_\-value}.
Tyto konverze však mohou být nepřesné,
např. v~případě čísel s~plovoucí řádovou čárkou.
V~takovém případě může být vhodnější použít \id{Expr\_\-value<Arg>}.

Zjištění typu ukazatele je doporučeno provádět pomocí funkcí
\id{is\_\-evalue}, \id{is\_\-etoken} a \id{is\_\-expr}.
Přetypování ukazatelů na~nekterý odvozený typ
je rovněž doporučeno provádět pomocí explicitních funkcí
(\id{ptr\_\-to\_\-expr}, apod.).

\id{Expr} se typicky sestavuje z~textového vstupu:
\id{std::\-string} nebo \id{std::\-istream}.
Jedinými speciálními znaky textového vstupu
jsou znaky kulatých závorek \id{(} a \id{)},
které interpretují argument jako (pod)výraz.
Všechny ostatní znaky jsou interpretovány jako tokeny
oddělené bílými znaky, jež nikdy nejsou součástí tokenů.
Pro~listy jsou použity pouze objekty
textového typu~---~\id{Expr\_\-token}.

Každý objekt třídy obsahuje interní iterátor
indikující pozici v~seznamu potomků
a s~ním související funkce
umožňující sekvenční čtení i~zápis,
případně spojené i~s~přetypováním,
např. \id{peek}, \id{get}, \id{extract},
\id{get\_\-token}, \id{extract\_\-expr},
\id{add\_\-new\_\-expr\_\-at\_\-pos},
\id{erase\_\-at\_\-pos}, \dots

Dále jsou vřazeny šablonové funkce,
které provedou konverzi potomka libovolného typu
na~aritmetický typ (\id{ptr\_\-to\_\-value}, \id{get\_\-value} apod.).

Nad~sestavenými výrazy lze provést některé základní operace:
\begin{itemize}
\item \id{simplify}~---~všechny (pod)výrazy (včetně kořenového),
   které obsahují jen jediný argument typu token,
   jsou převedeny na~token.
\item \id{to\_\-binary}~---~výraz je transformován tak,
   aby každý (pod)výraz (včetně kořenového)
   obsahoval nejvýše tři argumenty,
   z~nichž první musí být token s~libovolným názvem funkce
   bez~ohledu na~její interpretaci.
\item \id{flatten}~---~všechny vnořené tokeny jsou přesunuty
   do~kořenového výrazu a podvýrazy jsou smazány.
\item \id{transform\_\-to\_\-args<Arg>}~---~výraz,
   který obsahuje výhradně tokeny,
   je transformován na~pole prvků typu \id{Arg}.
\item \id{get\_\-eval<Arg>}~---~provede se \id{to\_\-binary}
   a vrátí se objekt typu \id{Expr::\-Eval<Arg>}
   sestavený z~položek výrazu.
\end{itemize}

Vyhodnocení výrazu je vždy externím objektem,
není obsaženo jako členská proměnná.
Dokud není použita operace \id{get\_\-eval},
je objekt zcela nezávislý na~svém vyhodnocení
a implementace třídy \id{Expr::\-Eval<Arg>} ani nemusí být přítomna.
Třídu \id{Expr} je tedy možné použít
i~pro~libovolné účely vytvoření hierarchické struktury
z~prefixového textového vstupu
bez~jakékoli spojitosti s~aritmetickým vyhodnocením.
\end{paragraph} %%\id{Expr}

%%%

% Tue 17 Apr 2018 01:00:32 PM CEST
\begin{paragraph}{\id{Expr::\-Eval<Arg>}.}\label{p:impl:exprs:eval}
Nové objekty vyhodnocení se konstruují z~objektů třídy \id{Expr},
které musí být v~binárním či unárním tvaru, či v~jejich kombinaci.
Vytvoření objektu vyhodnocení s~přímými a nepřímými argumenty
se děje podle návrhu uvedeném
v~sekci \rf{p:design:arch:ode:exprs:eval}.

Klíče nepřímých argumentů jsou ukládány dynamicky bez~duplikací
v~pořadí prefixového průchodu výrazem.
Objekty třídy \id{Expr::\-Eval<Arg>} mají přetížen operátor
volání funkce, tj.~ \id{()}, s~pozičními parametry
s~hodnotami pro~nepřímé argumenty v~pořadí,
v~jakém byly uloženy jejich klíče.

Aby bylo pořadí parametrů vyhodnocení jednoznačné,
je možné mu je explicitně přiřadit při~konstrukci.
Pokud výraz obsahuje další klíče,
které dosud nejsou obsaženy,
jsou umístěny na~konec seznamu klíčů.
Mohou být obsaženy i~redundantní klíče,
které ve~výrazu obsaženy nejsou,
ale hodnota jim při~volání přiřazena být musí (ač libovolná).

V~unárních a binárních funkcích jsou přítomny všechny
rezervované funkce specifikované ve~vstupním jazyce
v~sekcích \rf{sss:design:spec:ilang:smt} a \rf{sss:design:spec:ilang:ode}.

\id{Expr::\-Eval<Arg>} obsahuje stromovou strukturu
objektů třídy \id{Eval::\-Oper}
reprezentující hierarchii vyhodnocení výrazů \id{Expr},
dále pole klíčů nepřímých argumentů a pole jejich hodnot.
Pole hodnot je nastaveno při~volání celého vyhodnocení jako funkce.

\id{Eval::\-Oper} představuje binární nebo unární funkci
s~argumenty tří možných typů:
\begin{itemize}
\item přímý argument~---~hodnota,
\item nepřímý argument~---~ukazatel do~pole hodnot klíčů,
\item podvýraz~---~ukazatel na~další objekt typu \id{Eval::\-Oper}.
\end{itemize}
Argumenty je nutné vyhodnotit až v~momentě volání funkce,
proto je použit princip \name{líného vyhodnocení}
(angl. \name{lazy evaluation})~---~argumenty jsou uloženy
jako nulární funkce, které jsou volány společně
s~voláním vyhodnocení objektu \id{Eval::\-Oper}.
Celý výraz \id{Expr::\-Eval<Arg>} je pak vyhodnocen
voláním kořenového objektu \id{Eval::\-Oper}.
\end{paragraph} %%\id{Expr::\-Eval<Arg>}.

%%%

\bigskip

Obě třídy jsou dostupné jako knihovny.
Také je možné je využít pomocí aplikace \appletFn{eval},
která vyhodnocuje vstupní výrazy,
které mohou obsahovat i~nepřímé argumenty.
\end{section} %%Realizace vyhodnocení výrazů

%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Thu 03 May 2018 04:01:22 PM CEST
\begin{section}{Implementace adaptéru \acr{smt} řešiče}\label{s:impl:smt}
\acr{smt} řešič je vhodné mít implementován flexibilně tak,
aby byla snadná jeho výměna, jak bylo diskutováno
v~sekci \rf{sss:design:arch:comp:smt}.
V~našem prototypu je řešič použit jako samostatná aplikace
s~textovým rozhraním podle \acr{smt}-LIB standardu verze~2.
Náš nástroj byl testován s~řešiči \acr{cvc}4 a z3
(viz.~sekce \rf{p:search:smt:solver:cvc4} \cmt{a z3}).

\acr{smt} řešič reprezentuje třída \id{SMT::\-Solver},
která momentálně zahrnuje jak potřebné rozhraní, tak implementaci
související s~propojením textového rozhraní
se~synovským procesem \acr{smt} řešiče.
Výhledově by bylo vhodné rozhraní a implementaci oddělit,
tj.~třídu realizovat jako abstraktní,
která poskytuje operace obecně potřebné
k~řešení hybridních modelů
bez~ohledu na~konkrétní implementaci.
K~této třídě by byla poskytnuta
jako základní implementace odvozená třída
s~názvem např. \id{SMT::\-Smtlib},
která by operace delegovala přes textové rozhraní.
Bylo by však možné zvolit libovolnou jinou třídu,
která by např. operovala přímo s~programovým
rozhraním konkrétního \acr{smt} řešiče jako knihovny%
\footnote{Oba zmíněné \acr{smt} řešiče jsou implementovány v~jazyce C++.
Pokud by byly vyšší požadavky na~výkon nástroje,
bylo by možné je použít jako externí knihovnu s~C++ rozhraním.}.

Komponenta zahrnuje i~část zodpovědností,
které nesouvisí výhradně jen s~\acr{smt} řešičem,
ale jsou částečně spjaty s~kombinováním
řešiče s~diferenciálními rovnicemi.
Úlohou komponenty je zprostředkování \acr{smt} řešiče
pro~účely tohoto nástroje,
ne implementace nezávislého řešiče.

%%%

% Thu 03 May 2018 12:13:22 AM CEST
\begin{paragraph}{Identifikátory a hodnoty}\label{p:impl:smt:consts}
vstupních konstant jsou uloženy podle příkazů \id{int\--ode}
po~řádcích reprezentovaných strukturou \id{Const\_\-ids\_\-rows},
resp. \id{Const\_\-values\_\-rows}
(pole struktur \id{Const\_\-ids\_\-row},
resp. \id{Const\_\-values\_\-row})
pro každou \acr{ode} zvlášť.
Klíčem každého řádku identifikátorů je unikátní dvojice konstant
počáteční a koncové hodnoty nezávislého parametru \id{t}
(\id{Time\_\-const\_\-ids})
a hodnotou je \id{Const\_\-ids\_\-entries}
(pole struktur \id{Const\_\-ids\_\-entry}),
tj.~pole identifikátorů voleb derivací, počátečních hodnot
a vstupních parametrů každého jednotlivého systému,
který používá danou \acr{ode} v~daném okamžiku.
Použití pole umožňuje,
aby definovanou \acr{ode}
mohlo současně používat více systémů nezávisle,
např. v~případě kaskádní kompozice.
Struktury hodnot konstant jsou analogické.
\end{paragraph} %%Identifikátory a hodnoty konstant

%%%

% Wed 02 May 2018 10:52:48 PM CEST
\begin{paragraph}{\id{SMT::\-Solver}}\label{p:impl:smt:solver}
komunikuje s~\acr{smt} řešičem
pomocí operací definovaných \acr{smt}-LIB standardem
(viz.~sekce \rf{ss:search:smt:smtlib}),
nicméně jedná se o~obecný koncept operací
použitelný pro~různé implementace.
Každá uvedená operace je později rozvedena
včetně konkrétních použitých funkcí.
Realizace komunikace s~\acr{smt} řešičem
je uvedena až v~další části.

Kromě inicializace se jedná o~tyto operace:
\begin{itemize}
\item \id{(check\_\-sat)}~---~ověření splnitelnosti
   aktuálních asercí; výstupem je \id{sat} nebo \id{unsat}
   (nebo \id{unknown}, což je považováno za~chybu),
\item \id{(get\_\-value)}~---~získání hodnot
   konkrétních konstant, čemuž musí předcházet \id{check\_\-sat};
   výstupem jsou exaktní racionální čísla
   zpravidla ve~tvaru zlomků,
\item \id{(assert)}~---~přidání hodnot
   konstant spjatých s~aktuální fází výpočtu,
   jako podmínky nebo jako konfliktu,
   do~vrcholové úrovně zásobníku asercí,
\item \id{(push)} a \id{(pop)}~---~přidání či odebrání úrovně
   zásobníku asercí.
\end{itemize}

Získávání hodnot se vždy vztahuje pouze ke~vstupním konstantám
dané fáze. Pokud je výstup reprezentován výrazem,
je vyhodnocen pomocí objektu třídy \id{Expr::\-Eval}.
Tyto výrazy mohou mít teoreticky neomezenou přesnost,
což by vyžadovalo použití dynamických struktur
s~možností rozšiřující přesnosti.
Implementovány jsou ale jen statické typy
čísel s~plovoucí řádovou čárkou.
Problém nastává v~momentě,
kdy je potřeba takové číslo vypsat zpět ve~tvaru textu,
aby hodnota zůstala stejná.
Výpis řeším zjednodušeně pomocí fixního počtu desetinných míst
a ořezáním výsledných hodnot integrací na~ještě menší počet,
abych ponechal určitý prostor pro~případné navýšení desetinných míst
z~navazujících výpočtů hodnot konstant v~\acr{smt} řešiči.
Jedná se o~poměrně náchylné řešení,
lepším způsobem by bylo pamatování si načítaných textových reprezentací
hodnot konstant a jejich opětovné použití při~výpise.

Hodnoty dané fáze lze získat s~různou granularitou
od~nejvyšší po~nejnižší se~strukturami (či jejími částmi)
\id{Const\_\-}*\id{\_\-row}
pomocí funkcí \id{get\_\-step\_\-time\_\-values} počínaje
a \id{get\_\-step\_\-row\_\-values} konče.
Vždy však jen v~rámci jediné fáze i~\acr{ode}.

Aserce lze přidávat obecně pomocí funkce \id{assert},
ale praktičtější je použití funkce \id{assert\_\-step\_\-row},
která vytvoří formule s~veškerým obsahem struktur
\id{Const\_\-ids\_\-row}, \id{Const\_\-values\_\-row}
a výsledků integrace \acr{ode}.
Současně se provede operace \id{push}.
Vložené aserce jsou interně ukládány do~zásobníku,
aby bylo možné v~případě konfliktu
provést i~více návratů v~řadě.
Návrat provede prostřednictvím funkce
\id{assert\_\-last\_\-step\_\-row\_\-conflict}
operaci \id{pop} a přidá negaci
všech formulí se~vstupními konstantami fáze
ze~zásobníku (tj.~nevyžaduje žádné argumenty).

Rozhraní všech dosud zmíněných funkcí by mělo být nezávislé
na~konkrétní implementaci adaptéru \acr{smt} řešiče.
\end{paragraph} %%\id{SMT::\-Solver}

%%%

% Thu 03 May 2018 01:45:33 AM CEST
\begin{paragraph}{Komunikace s~\acr{smt} řešičem}\label{s:impl:smt:pipe}
je zprostředkována pomocí dvojice nepojmenovaných
\name{rour} (angl. \name{unnamed} či \name{anonymous pipes})
standardu \acr{posix}. Každá roura je jednosměrná
a je realizována v~paměti, tj.~mimo souborový systém.
Cílovou platformou tohoto řešení jsou systémy z~rodiny Unix,
v~rámci nichž by mělo fungovat standardně.

Nastavení komunikace provádí funkce \id{fork\_\-solver}
technikou fork-exec:
\begin{enumerate}
\item Vytvoření dvou rour: funkce \id{pipe}.
\item Vytvoření synovského procesu \acr{smt} řešiče: funkce \id{fork}.
\item Synovský proces přesměruje standardní vstup a výstup do~rour:
   funkce \id{dup2}.
\item Synovský proces se nahradí procesem \acr{smt} řešiče:
   funkce \id{execlp}.
\end{enumerate}

Poté rodičovský proces komunikuje prostřednictvím rour
přes~jejich získané deskriptory.
K~tomu slouží standardní funkce \id{write} a \id{read},
které pracují na~úrovni (binárních) bytů.
V~takové komunikaci je nutné mít dohodnutý nějaký protokol.
V~našem případě stačí jako zprávy přijímat
buď celistvé výrazy, pokud zpráva začíná závorkou,
nebo řádky.

Přijímání zpráv je implementováno sekvenčně po~jednom znaku,
aby bylo možné detekovat konec zprávy a nečíst žádné znaky navíc.
To je potenciálně neefektivní~---~lepším řešením by bylo
vyhradit samostatné vlákno pro~přijímaní bloků dat
poskytovaných jako jednotlivé zprávy.
Takové řešení by bylo náročnější na implementaci
a vyžadovalo by synchronizaci vláken.
\end{paragraph} %%Komunikace s~\acr{smt} řešičem

%%%

\end{section} %%Implementace adaptéru \acr{smt} řešiče

%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Wed 18 Apr 2018 03:30:27 PM CEST
\begin{section}{Implementace adaptéru \acr{ode} řešiče}\label{s:impl:ode}
V~sekci \rf{sss:design:arch:comp:ode} jsem rozebral
a oddůvodnil návrh adaptéru pro~\acr{ode} řešiče
pomocí abstraktní třídy a odvozených tříd.
Podrobnější návrh komponenty \acr{ode} řešiče
jsem uvedl v~sekci \rf{ss:design:arch:ode}.
Jako primární řešiče jsem zvolil odeint a \acr{sundials},
které je možné použít jako externí knihovny
uvnitř odvozených tříd bez nutnosti dalších rozhraní,
jelikož jsou napsány v~jazyce C++, resp. v~C.
\acr{sundials} jsem ale nakonec neimplementoval,
jelikož nepodporuje některé funkcionality jazyka C++,
např. objektové zapouzdření,
přetěžování operátorů, šablonové programování.
Jeho nasazení by vyžadovalo ve~srovnání s~řešičem odeint
zavádění dodatečných tříd,
které by poskytovaly nějakou abstrakci nad~strukturami a funkcemi.
Proto jsem zvolil pouze řešič odeint.

Realizaci dynamických specifikací diferenciálních rovnic
z~textových řetězců a jejich vyhodnocení
jsem provedl prostřednictvím
vlastních tříd pro~výrazy a jejich vyhodnocení
podle avizovaného návrhu v~sekci \rf{sss:design:arch:ode:exprs}.
Realizace těchto tříd byla popsána v~sekci \rf{s:impl:exprs}.

Nejprve popíši abstraktní třídu \acr{ode} řešiče,
a poté odvozené třídy s~konkrétními implementacemi řešení \acr{ode}.

%%%%%%%%%%%%%

% Wed 18 Apr 2018 12:22:26 PM CEST
\begin{subsection}{Abstraktní třída řešiče}
\label{ss:impl:ode:solver}
Abstraktní třída \id{\acr{ode}::\-Solver}
poskytuje většinu potřebných funkcionalit
pro~obecný \acr{ode} řešič,
který přijímá vstupní specifikace diferenciálních
rovnic prostřednictvím objektů třídy \id{Expr}
a jejich vyhodnocení provádí interně
pomocí objektů třídy \id{Expr::\-Eval}.
Externí \acr{ode} řešič má na starosti
pouze samotné řešení rovnic na~základě
konkrétně definovaných výrazů,
ostatní operace deleguje na~abstraktní třídu.

Třída není závislá na~navrženém vstupním jazyce
a celkově na~kombinování s~\acr{smt} řešičem.
Měla by být použitelná jako obecný \acr{ode} řešič,
jen s~tím rozdílem, že je možné pro~každou \acr{ode}
nastavit více variant derivací.

%%%%%%%

% Wed 18 Apr 2018 10:30:07 AM CEST
\begin{subsubsection}{Specifikace rovnic}\label{sss:impl:ode:solver:spec}
Základní forma inicializace řešiče se provádí
z~páru objektů typu \id{\acr{ode}::\-Odes\_\-spec}
a \id{\acr{ode}::\-Param\_\-keyss}.

\id{Odes\_\-spec} reprezentuje množinu
struktur typu \id{Ode\_\-spec},
které reprezentují všechny varianty derivací
pro~danou funkci~---~objekty typu \id{Dt\_\-spec}
(alias pro~\id{Expr}).
Pro~každý objekt \id{Dt\_\-spec}
je sestaveno vyhodnocení typu \id{Dt\_\-eval}
(alias pro~\id{Expr::\-Eval}).

\id{Param\_\-keyss} obsahuje množinu
struktur \id{Param\_\-keys},
které reprezentují pole klíčů
pro~korespondující vyhodnocení \id{Dt\_\-eval}.
Pole klíčů je vždy shodné pro~všechny \id{Dt\_\-spec}
(resp. \id{Dt\_\-eval})
v~rámci \id{Ode\_\-spec}, tj.~\acr{ode}.

Standardně tedy každá dvojice z~množin
\id{Odes\_\-spec} a \id{Param\_\-keyss}
představuje jednu \acr{ode}.
Každá rovnice je pak řešena nezávisle na~ostatních
a také klíče má nezávislé.
Tento stav nazývám jako \name{nezávislý}.

Nezávislost rovnic může být výhodná, ale také ne.
Pokud kterákoliv rovnice obsahuje jako argument
funkci některé \acr{ode}
(a má za ni být považována),
výsledek výpočtu bude chybný,
neboť tato funkce bude předložena jako konstanta
a nebude se měnit současně s~právě řešenou funkcí \acr{ode},
protože každá \acr{ode} je řešena nezávisle.

%%%

% Thu 03 May 2018 01:54:49 AM CEST
\begin{paragraph}{Sjednocení klíčů.}\label{p:impl:ode:solver:spec:unif}
Pokud je potřeba všechny \acr{ode} řešit synchronně
(myšleno synchronizovaně po~krocích integrace),
rovnice se na sobě stávají závislými.
Stačí jediná taková závislost,
aby byl jako závislý automaticky chápán celý vstup.
Takový stav nazývám jako \name{sjednocený}.
Důvodem je, že zejména z~implementačních důvodů
je vhodné mít pro~všechny \acr{ode}
sjednocené pole klíčů
a každá \acr{ode} při~svém vyhodnocení
dosazuje aktuální hodnoty závisle
na~integracích ostatních rovnic.

Podle tvaru vstupu je možné implicitně rozpoznat,
zda se jedná o~sjednocený stav,
konkrétně podle \id{Param\_\-keyss}~---~pokud obsahuje
jen jedinou položku \id{Param\_\-keys},
nebo pokud jsou všechny položky identické.
Pak je první položka interpretována jako sjednocené klíče
pro~všechny \acr{ode}.

Sjednocení klíčů lze také explicitně vynutit,
ale to je možné pouze při konstrukci řešiče.
V~tomto případě se vytvoří mapování nesjednocených klíčů
na~vytvořené sjednocené pomocí číselných indexů,
které je přístupné z~funkce \id{cunif\_\-param\_\-keyss\_\-ids}.
Druhá strana si tak může pomocí tohoto přeorganizovat
své specifikace rovnic a nadále používat
pouze sjednocených klíčů.
To je sice efektivní varianta, ale relativně nepohodlná.
Proto je umožňěno i~nadále při řešení
rovnic poskytovat vstupní hodnoty v~nesjednoceném tvaru,
které řešič interně sjednotí sám aplikací mapování.
\end{paragraph} %%Sjednocení klíčů.

%%%

\bigskip

Každé pole klíčů musí splňovat následující pravidla:
\begin{itemize}
\item Pokud je přítomen klíč nezávislé proměnné \id{t},
   musí být umístěn na~poslední pozici.
\item Musí být obsažen alespoň jeden klíč různý od~\id{t},
   který je interpretován jako klíč integrované funkce.
   Jeho pozice musí být následující:
   \begin{itemize}
   \item nezávislý stav $\rightarrow$ první pozice,
   \item sjednocený stav  $\rightarrow$ pozice na~diagonále,
      tj.~pozice klíče odpovídá pozici \id{Ode\_\-spec}
      v~rámci \id{Odes\_\-spec}.
   \end{itemize}
\end{itemize}

Jinou formou inicializace řešiče
je pomocí textového vstupu
(\id{std::\-string} nebo \id{std::\-istream}),
které jsou delegovány na konstrukci pomocí \id{Expr}.
Vstupní řetězec je formátován jako dvojice výrazů,
které mají strukturně shodný tvar
s~dvojicí \id{\acr{ode}::\-Odes\_\-spec}
a \id{\acr{ode}::\-Param\_\-keyss},
s~jedinou výjimkou: pokud je explicitní požadavek
na~sjednocení klíčů, je navíc mezi dvojici výrazů
nutné vložit token \id{*}.
\end{subsubsection} %%Specifikace rovnic

%%%%%%%

% Thu 03 May 2018 02:04:50 AM CEST
\begin{subsubsection}{Řešení rovnic}\label{sss:impl:ode:solver:solve}
Podobně jako u~specifikací rovnic
je možné provést výpočet rovnic
buď přímo s~parametry požadovaných typů,
nebo z~textového vstupu.
Základní vstup tvoří dvojice objektů
typu \id{ODE::\-Dt\_\-ids} a \id{Solver::\-Contexts}.

\id{Dt\_\-ids} reprezentuje pole indexů
zvolených variant derivací \id{Dt\_\-spec}
pro toto řešení.
Tento parametr není závislý na~stavu řešiče,
zda je či není sjednocený.

\id{Contexts} je pole objektů typu \id{Context}.
Pokud je voláno řešení rovnic jako sjednocených,
je nutné předat jen jediný \id{Context},
jelikož mají všechny \acr{ode} sjednocené klíče
a tedy i~hodnoty jim přiřazené.
Lze však použít i~obecnou funkci řešení rovnic
(přijímající \id{\id{Contexts}}),
která, v~případě, že se řešič nachází ve~sjednoceném stavu,
se pokusí aplikovat interní mapování
nesjednocených pozic na~sjednocené
(jak bylo popsáno v~části o~sjednocených klíčích).
(Nebo lze předat \id{Contexts} se shodnými položkami.)

%%%

% Wed 18 Apr 2018 10:54:33 AM CEST
\begin{paragraph}{\id{Context}}\label{p:impl:ode:solver:solve:ctx}
je třída obalující počáteční a koncové podmínky
řešení \acr{ode}.
Počátečními podmínkami
jsou počáteční hodnoty všech parametrů \acr{ode}
a nezávislé proměnné \id{t}
(viz.~vztah \rfeq{ode}).
Jako koncové podmínky se (zatím)
fixně považuje jen koncová hodnota
nezávislé proměnné \id{t}.

Počáteční hodnota \id{t} se vždy uvádí
odděleně od~všech ostatních parametrů
a nesmí být v~nich duplicitně obsažena.
V~případě, že je daná \acr{ode}
závislá na~\id{t},
je její hodnota přidávána automaticky
uvnitř řešiče \id{Solver}.
\end{paragraph} %%\id{Context}

%%%

\bigskip

Řešení rovnic se provádí různými členskými funkcemi
\id{Solver::\-solve}*
závisle na~předávaných parametrech
a na~požadavek sjednocení klíčů.
Pro~řešení jen jediné \acr{ode}
slouží \id{solve\_\-ode}.
Pro~řešení všech rovnic
slouží \id{solve\_\-odes},
která samostatně detekuje,
zda zvolit sjednocený výpočet.
Pro~explicitní požadavek na~sjednocený výpočet
slouží \id{solve\_\-unif\_\-odes},
která selže pokud klíče rovnic nejsou sjednoceny.
Poslední možností je funkce \id{solve},
která přijímá textový vstup
ve~tvaru dvojice výrazů
se~stejnou strukturou jako mají typy
\id{Dt\_\-ids} a \id{Context}(\id{s}).
Pokud je v~druhém výrazu specifikován jen jeden \id{Context},
jsou rovnice řešeny sjednoceně.
\end{subsubsection} %%Řešení rovnic

%%%%%%%

% Tue 24 Apr 2018 05:03:23 PM CEST
\begin{subsubsection}{Další operace}\label{sss:impl:ode:solver:op}
Dalšími operacemi obsaženými ve~veřejném rozhraní třídy jsou:
\begin{itemize}
\item \id{set\_\-step\_\-size}~---~nastaví (počáteční)
   velikost kroku integrací,
\item \id{add\_\-ode\_\-spec}~---~přidá specifikaci další \acr{ode}
   s~klíči parametrů,
\item \id{is\_\-unified}~---~vrátí příznak, zda je řešič ve~sjednoceném stavu;
   pokud není a dosud to nebylo ověřeno,
   je ověřeno, zda skutečně sjednocený není,
\item \id{cparam\_\-keyss}~---~zkonstruuje objekt typu
   \id{\acr{ode}::\-Param\_\-keyss} s~klíči parametrů všech \acr{ode} zvlášť,
\item \id{cunif\_\-param\_\-keys}~---~vrátí referenci na~sjednocené klíče
   všech \acr{ode} typu \id{\acr{ode}::\-Param\_\-keys};
   selže, pokud \id{is\_\-unified} není pravdivé,
\item \id{ctrajects}, \id{cunif\_\-traject}~---~vrátí referenci
   na~objekt typu \id{Solver::\-Traject}(\id{s}) (viz. dále),
\item lidsky čitelný výpis všech obsažených rovnic řešiče.
\end{itemize}
\end{subsubsection} %%Rozhraní řešiče

%%%

% Tue 24 Apr 2018 05:03:15 PM CEST
\begin{paragraph}{\id{Traject}}\label{p:impl:ode:solver:op:traj}
je třída, která shromažďuje průběh (\name{trajektorii})
integrace jedné \acr{ode},
tj.~obsahuje pole hodnot nezávislé proměnné \id{t}
a hodnot všech parametrů \acr{ode}.
Tyto jsou platné jen v~rámci jednoho
řešení rovnic~---~hodnoty jsou při~každém volání funkce \id{solve}*
z~kapacitních důvodů resetovány.

\id{Trajects} je pole objektů \id{Traject} o~velikosti
počtu \acr{ode} řešiče.
\end{paragraph} %%\id{Traject}

%%%

%%%%%%%

\bigskip

Třída \id{Solver} (a její odvozené třídy) je dostupná jako knihovna.
Také je možné ji využít jako aplikaci,
k~čemuž poskytuje šablonovou třídu \id{Solver::\-Run<S>},
kde \id{S} je konkrétní odvozená třída s~implementací integrace.
Aplikace používá inicializaci a řešení rovnic
s~textovými vstupy a chová se jako filtr:
na~inicializaci odpoví výpisem
\id{cparam\_\-keyss} nebo \id{cunif\_\-param\_\-keys}
a na každé řešení (\id{solve}) výpisem výsledku.
Je-li specifikován výstupní soubor,
jsou do~něj průběžně ukládány
výpisy objektů \id{Traject}(\id{s}).
\end{subsection} %%Abstraktní třída řešiče

%%%%%%%%%%%%%

% Wed 18 Apr 2018 02:08:18 PM CEST
\begin{subsection}{Odvozené třídy}
\label{ss:impl:ode:derived}
Třídy odvozené od~\id{\acr{ode}::\-Solver}
musí dodat implementace integrace rovnic.
\id{Solver} obsahuje tři virtuální neveřejné metody:
\id{eval\_\-ode}, \id{eval\_\-odes}
a \id{eval\_\-unif\_\-odes}.
\id{eval\_\-odes} ve~výchozím tvaru
jen vyplní pole výsledků pomocí
jednotlivých volání \id{eval\_\-ode};
zbylé dvě funkce nejsou implementovány.
Odvozená třída tedy musí definovat
jak nezávislé integrování jednotlivých rovnic,
tak synchronní integraci všech rovnic,
mají-li sjednocené klíče.

%%%

% Wed 18 Apr 2018 02:17:57 PM CEST
\begin{paragraph}{\id{Euler}}
\label{p:impl:ode:derived:euler}
poskytuje triviální implementaci integrace
pomocí explicitní Eulerovy metody
(viz.~vztah \rfeq{ode:explicit}).
Tato třída slouží zejména k~demonstračním a testovacím účelům,
jelikož je Eulerova metoda nepřesná.
Třída není závislá na~externích knihovnách.

Spustitelná aplikace třídy je umístěna v~souboru \appletFn{euler}.
\end{paragraph} %%Eulerova metoda

%%%

% Wed 18 Apr 2018 02:28:29 PM CEST
\begin{paragraph}{\id{Odeint}}
\label{p:impl:ode:derived:odeint}
využívá některých funkcí \acr{ode} řešiče odeint
(viz.~sekce \rf{p:search:ode:classic:solver:odeint}).
Odeint je realizován výhradně uvnitř hlavičkových souborů
v~rámci C++ knihoven Boost,
které třída \id{Odeint} částečně zahrnuje.
Zatím je použita pouze výchozí funkce
\id{odeint::\-integrate},
které jsou z~třídy \id{Solver}
v~každém kroce integrace poskytovány vypočtené
hodnoty z~objektů typu \id{Dt\_\-eval}.
Funkce používá metodu Dormand--Prince 5,
což je explicitní adaptivní Runge--Kutta metoda
(viz.~sekce \rf{sss:search:ode:classic:rk}).

Implementace třídy \id{Odeint} je triviální,
neboť řešič odeint nevyžaduje žádnou
inicializaci a pouze se volá funkce \id{integrate}
s~počátečními a koncovými hodnotami
a s~funkčními objekty.

Spustitelná aplikace třídy je umístěna v~souboru \appletFn{odeint}.
\end{paragraph} %%odeint

%%%

\end{subsection} %%Odvozené třídy

%%%%%%%%%%%%%

\end{section} %%Implementace adaptéru \acr{ode} řešiče

%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Thu 03 May 2018 01:45:29 PM CEST
\begin{section}{Implementace zpracování vstupu}\label{s:impl:parse}
Návrh zpracování vstupu je uveden v~sekci \rf{ss:design:arch:parse}.
Pro~tyto účely byla vytvořena třída \id{Parser}.
V~první řadě je vstup předzpracován (viz. další sekce).
Poté je ke~zpracování vstupu použit objekt třídy \id{Expr},
který by měl jako přímé potomky obsahovat pouze další výrazy \id{Expr},
jelikož v~kořenové úrovni nejsou tokeny povoleny
(po~předzpracování).
Výrazy v~první úrovni představují příkazy,
které jsou procházeny rekurzivně,
pokud se nějak dotýkají \acr{ode} řešiče.
Ostatní výrazy, zejména ty týkající se výhradně \acr{smt} řešiče,
jsou ponechány částečně nebo zcela nezpracovány.

Hlavním úkolem je zpracování příkazů \id{define\--dt} a \id{int\--ode},
z~nichž je nutné shromáždit specifikace všech \acr{ode}
a názvy konstant vstupující do \id{int\--ode} jako vstupní argumenty.
K~tomu slouží struktura \id{Odes},
což je pole struktur \id{Ode}.
\id{Ode} je pětice těchto struktur:
\begin{enumerate}
\item \id{Ode\_\-key}~---~klíč (identifikátor) \acr{ode},
\item \id{Dt\_\-keys}~---~pole klíčů (identifikátorů) variant derivací,
\item \id{Ode\_\-spec}~---~pole specifikací rovnic derivací
   (viz.~sekce \rf{sss:impl:ode:solver:spec})
   ve~stejném pořadí, jako \id{Dt\_\-keys},
\item \id{Param\_\-keys}~---~společné klíče nepřímých argumentů
   pro~všechny rovnice v~\id{Ode\_\-spec};
   není kontrolováno, zda jsou klíče napříč všemi rovnicemi
   dané \acr{ode} shodné,
\item \id{Const\_\-ids\_\-rows}~---~pole identifikátorů
   vstupních konstant jednoho příkazu \id{int\--ode},
   jak bylo diskutováno v~sekci \rf{p:impl:smt:consts}.
\end{enumerate}
S~výjimkou \id{Const\_\-ids\_\-rows}
pochází všechny ostatní hodnoty
z~příkazů \id{define\--dt}.
Položky \id{Const\_\-ids\_\-row} jsou v~rámci
příslušného klíče \id{Ode\_\-key} ukládány v~pořadí,
v~jakém jsou ve~vstupu čteny příkazy \id{int\--ode}.
(Určení fází podle konstant názávislých proměnných \id{t}
není zodpovědností zpracování vstupu.)

Hodnoty klíčů, včetně těch z~\id{Const\_\-ids\_\-rows},
jsou také duplicitně ukládány
do~vyhledávacích stromových struktur,
aby byly rychle dohledatelné.

Příkazy, které jsou zpracovány, jsou:
\begin{itemize}
\item \id{set\--logic}~---~povoleny jsou všechny logiky
   zmíněné v~sekci \rf{p:design:spec:ilang:smt:logic},
   a to \hl{včetně} logik bez~volných funkčních symbolů,
\item \id{define\--dt}~---~uloží se specifikace varianty
   derivace dané \acr{ode}; při~prvním výskytu
   klíče \id{Ode\_\-key} dojde k~deklaraci \acr{ode},
   tj.~uložení klíče \id{Ode\_\-key}
   a klíčů nepřímých argumentů \id{Param\_\-keys}
   společných pro~všechny varianty derivací,
\item \id{define\--ode\--step},
\item \id{int\--ode}~---~ze~vstupních argumentů příkazu
   se vytvoří jedna položka \id{Const\_\-ids\_\-row}
   pro~odpovídající klíč \id{Ode\_\-key},
   která je vložena na~konec pole \id{Const\_\-ids\_\-rows};
   příkaz je do~\acr{smt} vstupu transformován jako \hl{konstanta}
   (čemuž předchází její deklarace);
   vstupní argumenty příkazu \hl{musí být globální identifikátory}.
\end{itemize}

Dále je zpracován každý token.
Dosud se provádí jen transformace
záporných numerických literálů na~výrazy.

Komponentu je možné použít jako knihovnu,
nebo pomocí textové aplikace \appletFn{parser},
která na~standardní výstup vypíše
vstup pro~\acr{smt} řešič
a na~chybový výstup
vstup pro~\acr{ode} řešič.
Pomocí přepínače \id{-E}
lze také provést pouze předzpracování vstupu
a výsledek vypsat na~standardní výstup.
\end{section} %%Implementace zpracování vstupu

%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Sat 28 Apr 2018 06:46:55 PM CEST
\begin{section}{Implementace předzpracování vstupu}\label{s:impl:preprocess}
Realizace předzpracování vstupu navazuje na~návrh
uvedený v~sekci \rf{ss:design:arch:preprocess}.
Výsledkem je třída \id{Preprocess},
která je implementována uvnitř třídy \id{Expr}
(viz.~sekce \rf{p:impl:exprs:expr}),
jelikož lze předzpracování použít pro~libovolný textový prefixový vstup
obsahující komentáře a makra stejné se~vstupním jazykem
(viz.~sekce \rf{ss:design:spec:ilang}),
a protože je celé zpracování silně vázáno na~interní objekt třídy \id{Expr}.
Samotná třída \id{Expr} je však nezávislá
na~implementaci třídy \id{Preprocess}.

Globální a lokální makra jsou uložena zvlášť
ve~vyhledávacích stromech
\id{Macros\_\-map} a \id{Lets\_\-map}.
\id{Macros\_\-map} obsahuje jako hodnoty
dvojice \id{Macro\_\-param\_\-keys}
(názvy parametrů makra)
a \id{Macro\_\-body}
(alias pro~\id{Expr}).
\id{Lets\_\-map} obsahuje jako hodnoty
zásobníky objektů \id{Let\_\-body}
(alias pro~\id{Macro\_\-body}).

Příkazové makro \id{\#for} je zatím implementováno
jen ve~formě celočíselného vzestupného rozsahu
řídící proměnné s~jednotkovým krokem
(varianta \rf{i:macro:for:int}).
Pro~ostatní případy lze využít rekurzivních volání uživatelských maker.

%%%

% Wed 25 Apr 2018 12:17:59 AM CEST
\begin{paragraph}{Aritmetické expanze}
\label{s:impl:preprocess:arith}
výrazů jsou implementovány pomocí třídy \id{Expr::\-Eval}
(viz.~sekce \rf{p:impl:exprs:eval}).
Ve~skutečnosti se jedná o~expanzi tokenu,
jelikož výrazy jsou předcházeny tokenem \id{\$}.
Makra \id{\#if} a \id{\#for} používají
ke~svému vyhodnocení
aritmetickou interpretaci tokenů,
k~čemuž je použita buď aritmetická expanze výrazu,
nebo, v~případě, že se jedná o~literál,
získání aritmetické hodnoty z~objektu třídy
\id{Expr\_\-token} pomocí \id{get\_\-value}
(viz.~sekce \rf{p:impl:exprs:expr}).

Vzhledem k~tomu, že C++ není dynamicky typovaný jazyk,
a požadovaný typ argumentů je zjišťován dynamicky z~textového vstupu,
bylo nutné programově odlišit případy použití
reálných a celých čísel.
K~reprezentaci hodnoty jsem použil
konstrukt \id{union},
který umožňuje paměťovou oblast
interpretovat jako různé typy (ačkoli pouze staticky).
\end{paragraph} %%Aritmetické expanze

%%%

% Wed 25 Apr 2018 12:18:02 AM CEST
\begin{paragraph}{Zpracování maker v~rámci tokenu}
\label{s:impl:preprocess:in_token}
je provedeno tak, že se token rozdělí na~části
podle znaků \id{\#}%
\footnote{Každá část může obsahovat nejvýše jeden znak \id{\#}
právě na~první pozici.}.
Pokud jsou obsaženy alespoň dvě takové části,
přidá se každá do~výrazu
jako nový token a zpracuje se zvlášť,
a poté je výsledek všech expanzí spojen do~právě jednoho tokenu,
který může být i~prázdný.
Rezervovaná makra volaná jako \id{\#} a \id{\#\#}
jsou implementována takto:
\begin{itemize}
\item je přidáno globální makro s~prázdným názvem,
\item při~rozdělení tokenu na~části
   je pro~každou nalezenou část (kromě té poslední),
   která je rovna jedinému znaku \id{\#},
   odmazán první znak z~následující části,
   který nutně musí být roven \id{\#}.
   Tím je simulováno volání makra \id{\#\#}.
\end{itemize}
\end{paragraph} %%Zpracování maker v~rámci tokenu

%%%

% Sat 28 Apr 2018 09:16:38 PM CEST
\begin{paragraph}{Escape sekvence}\label{s:impl:preprocess:escape}
\id{\textbackslash\#}
je implementována tak,
že se do~části tokenu, která začíná znakem \id{\#},
a která následuje za~částí,
která končí znakem \id{\textbackslash},
přidá další znak \id{\#} na~začátek.
Pokud je následně při~zpracování expanze makra
toto detekováno, odmaže se první znak
a expanze není provedena.
\end{paragraph} %%Escape sekvence

%%%

\bigskip

Komponentu lze použít jako knihovnu
nebo pomocí aplikace \appletFn{parser}
(viz.~sekce \rf{s:impl:parse}).
\end{section} %%Implementace předzpracování vstupu


%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Thu 03 May 2018 04:15:08 PM CEST
\begin{section}{Realizace řídící komponenty}\label{s:impl:center}
Úlohou centrální komponenty je řídit \acr{smt} a \acr{ode} řešič
(sekce \rf{s:impl:smt} a \rf{s:impl:ode})
a průběh kombinovaného výpočtu.
Postupoval jsem dle návrhu komponenty
uvedeném v~sekci \rf{sss:design:arch:comp:center}
a návrhu řídícího algoritmu ze~sekce \rf{ss:design:arch:alg}.
Komponenta je však realizována jako \hl{prototyp},
některé funkcionality chybí
nebo jsou zjednodušeny.

Řídící komponenta je umístěna v~šablonové třídě \id{Solver<OSolver>},
která komunikuje s~oběma řešiči
výhradně pomocí programového rozhraní
vlastních tříd \id{SMT::\-Solver} a \id{ODE::\-Solver};
teprve na~nich leží zodpovědnost
konkrétní realizace propojení s~řešiči třetích stran.
\id{ODE::\-Solver} slouží jako rozhraní,
konkrétní implementaci obsahuje
zvolená odvozená třída \id{OSolver}.
Výhledově by bylo lépe použít také třídu \acr{smt}
řešiče jako rozhraní s~volitelnou implementací
(jak bylo uvedeno v~sekci \rf{s:impl:smt})
jako šablonového parametru.

Oproti navrženému základnímu řídícímu algoritmu
byla aplikována následující zjednodušení:
\begin{itemize}
\item Fáze výpočtu jsou brány v~pořadí,
   ve~kterém se nachází příkazy \id{int\--ode};
   je zodpovědnost uživatele,
   aby hodnoty vstupních konstant nezávislé proměnné \id{t}
   tvořily neklesající posloupnost.
   Počet příkazů \id{int\--ode} na~jednu fázi,
   včetně shodných \acr{ode},
   však není omezen.
\item Rozložení všech fází musí navíc být pro~všechny \acr{ode} \hl{stejné}.
   To prakticky znamená to, že všechny příkazy \id{int\--ode}
   musí používat pouze jednu společnou sadu konstant
   nezávislé proměnné \id{t}.
\item Všechny odlišné \acr{ode} jsou vkládány
   do~jediné společné soustavy;
   vícenásobný výskyt \acr{ode} v~rámci fází
   je považován za~nový nezávislý systém
   \cmt{!!! tohle je asi blbě ...
   Kaskádní kompozice asi nebude fungovat
   - bude kolize na klíči ODE v ODE řešiči.
   Aby se počítaly synchronně, musí klíč odpovídat názvu ODE,
   takže jen vložení jiné vstupní konstanty nepomůže.
   Mělo by ale fungovat vícenásobná definice více ODE
   s odlišnými názvy - ale se stejným tělem ..}.
   Řešič \id{ODE::\-Solver} je tedy
   vždy používán ve~sjednoceném stavu.
\end{itemize}

Výpočet se provádí funkcí \id{solve},
která zavolá funkci \id{do\_\-step}
pro~počáteční fázi
a počítá se dokud není dosaženo poslední fáze
(pak bylo nalezeno splňující ohodnocení vstupu),
nebo dokud není proveden návrat z~počáteční fáze
(pak vstup není splnitelný).

Interakce s~oběma řešiči
spočívá pouze v~sestavení či přeuspořádání
požadovaných vstupních struktur.

%%%

% Thu 03 May 2018 05:48:25 PM CEST
\begin{paragraph}{Inicializace \acr{ode} řešiče}
\label{p:impl:center:ode_init}
spočívá v~zaslání specifikací rovnic a klíčů nepřímých argumentů
v~nezávislém tvaru. S~výhodou je využito toho,
že \id{ODE::\-Solver} umí explicitně
vynutit sjednocení klíčů
a také později sám provádět mapování
pozic hodnot nezávislých kontextů
do~sjednoceného.
Řídící komponenta tedy kromě příznaku
v~konstruktoru řešiče,
který vyžaduje sjednocení,
je zcela oproštěna od~této skutečnosti
a pracuje s~rovnicemi jako s~nezávislými.
\end{paragraph} %%Realizace řídící komponenty

%%%

\cmt{řešení ode - jak je to s entries? viz. hore}

\bigskip

Celý nástroj lze použít jako knihovnu,
nebo jako aplikaci.
Aktuální podoba aplikace je umístěna v~souboru
\binFn{sos\_\-odeint}, která používá odeint
pro~řešení \acr{ode} (třída \id{ODE::\-Odeint}).
\end{section} %%Realizace řídící komponenty

%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Thu 03 May 2018 06:24:34 PM CEST
\begin{section}{Seznam dalších úkolů}\label{s:impl:todo}
\begin{itemize}
\item Podrobnější dokumentace zdrojových kódů.
\item Implementace řídícího makra \id{\#for} ve~všech variantách.
\item Kontrola příkazů \id{define\--dt}, zda mají všechny
   v~rámci dané \acr{ode} shodné klíče nepřímých argumentů.
\item Lepší zacházení s~výstupními textovými hodnotami z~\acr{smt}
   řešiče, pokud se do~něj následně posílají zpět jako podmínky.
\item Oddělení rozhraní od~implementace ve~třídě \id{SMT::\-Solver};
   odvozenou třídu zavést jako druhý šablonový parametr třídy \id{Solver}.
\item Vyhrazení samostatného vlákna pro~příjem
   odchozích zpráv \acr{smt} řešiče po~blocích.
\item Implementace odvozené třídy pro~implementaci
   \acr{ode} řešiče \acr{sundials}.
\item Umožnit obecnější nastavení fází výpočtu v~řídící komponentě.
\item Umožnit obecnější koncové podmínky diferenciálních rovnic,
   např. podle koncové hodnoty funkce.
\item Implementace efektivnějšího algoritmu
   redukujícího počet operací ověření splnitelnosti vstupu.
\item Implementace výstupu \id{unknown} pro~případy,
   kdy výpočet pravděpodobně nikdy neskončí
   (např. pro~intervalové počáteční podmínky).
\end{itemize}
\end{section} %%Seznam dalších úkolů

%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Experimentální část}\label{ch:exp}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{conclusion}\label{ch:outro}
\end{conclusion}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\appendix

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bibliographystyle{csn690}
\bibliography{dp_kolarto5}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\printglossary[type=\acronymtype, title=Seznam použitých symbolů a zkratek]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \chapter{Obsah přiloženého CD}

% \begin{figure}
%    \dirtree{%
%    .1 readme.txt\DTcomment{stručný popis obsahu CD}.
%    .1 exe\DTcomment{adresář se spustitelnou formou implementace}.
%    .1 src.
%       .2 impl\DTcomment{zdrojové kódy implementace}.
%       .2 thesis\DTcomment{zdrojová forma práce ve formátu \LaTeX{}}.
%    .1 text\DTcomment{text práce}.
%       .2 thesis.pdf\DTcomment{text práce ve formátu \acr{pdf}}.
%       .2 thesis.ps\DTcomment{text práce ve formátu PS}.
%    }
% \end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \chapter{Instalační příručka}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
